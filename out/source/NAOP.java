/* autogenerated by Processing revision 1286 on 2023-03-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.serial.*;
import oscP5.*;
import netP5.*;
import java.util.Arrays;
import sync.*;
import peasy.*;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.spi.*;
import ddf.minim.ugens.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class NAOP extends PApplet {

PNetwork net; 
int networkSize = 6;
int nbBalls=networkSize;



// MANAGE ARDUINO && TENNSY

Serial DueSerialNativeUSBport101; // The native serial port of the DUE fibish with 101
Serial teensyport;

String dataTransformed ;
String dataFromMode ;

boolean startZ=false; // to trig opposite way of propaagtion in addSignalOneAndTwoQuater

float signalToSplit, oldSignalToSplit ;  // signal oscillant entre 0 et 1 ou entre - TWO_PI et TWO_PI. oldSignalTosplit est la valeur du signal a la frame precedente. 

float timeLfo; // met à l'echelle le "signalToSplit" afin qu'il soit limité entre 0 et 1000

float splitTime, oldSplitTime ; // // renvoie la valeur discontine du time. Quand le temps s'ecoule de maniere cconstante et lineaire

float splitTimeLfo, oldSplitTimeLfo; // renvoie la valeur discontine du timeLFO. Quand timeLFO va de 0 à 1000, splitTimeLfo renvoie la valeur restante du timeLfo

int propagationSpeed=20;; // " vitesse " à laquelle on change d'oscillateur

int oscillatorChanging; // next or last changing oscillator
//******************         followSignalLfo
 
 char  modeStartKey;
 String modeStartKeyToFollow;
 
 float [] oscillator = new float [networkSize];
 int [] countFollowSignalLfo = new int [networkSize];
 int [] oldOldPositionToMotor = new int [networkSize];
 int [] trigFollowSignalLfo = new int [networkSize];

// ALIGNEMENT Trig 0
int[] result;


 public int[] multiMatchData(int matchValue, int newValue, int [] theArray) {
  IntList list = new IntList();
  for (int i = 0; i <  theArray.length; i++)
    if (theArray[i] == matchValue) list.append(i);
  if (list.size() > 1)
  list.forEach(element -> { theArray[element] = newValue; } );
  return theArray;
}

 public void showArray(int[] array) {
  for (int i = 0; i < array.length; i++)
    print(array[i] + "   ");
    println();
}

//

float []  velocityBis =  new float[networkSize]; //;
float []  oldVelocityBis =  new float[networkSize]; //;
float []  accelerationBis =  new float[networkSize]; //;
//float []  oldaccelerationBis =  new float[networkSize]; //;

float [] phaseAcceleration =  new float[networkSize]; //;
float [] oldPhaseAcceleration =  new float[networkSize]; //;


//******************         FollowMovement addSignalOneAndTwo and addSignalOneAndTwoBis

char letter;
boolean doA,doQ,doZ;

int oldOscillatorChange, oscillatorChange;
boolean oscillatorChanged;




int [] recordLastDataOfMotorPosition = new int[networkSize];  // not used

//float [] phaseShiftingFollowLFO = new float[12];


int frameCountRed;
String overKeyMode,keyMode,keyModeRed;  // to read and change mode of pattern arrangement
String mappingMode; 
int   controlTrigLfoPattern;
float phaseShiftingFollowLFO;

int decayTimeLfo;
int formerDecayTimeLfo;


 //int [] j = new int[networkSize];// number of the last changed oscillator
float [] phaseKeptAtChange =  new float[networkSize]; //;
float [] phasePatternFollow =  new float[networkSize]; //;

float [] newPosXaddSignal =  new float[networkSize]; //;
float [] newPosX =  new float[networkSize]; //;
float [] oldPosX =  new float[networkSize]; //;


int decayTimeBis;
int formerDecayTimeBis;

//******************         FollowMovement   

float oldYsampled,  ySampled;
int formerDecayTime, decayTime;
int frameCountBis = 0;
int decayshiftFollowMov = 0;


float [] ableton = new float[networkSize]; //;
float [] signal = new float[networkSize]; //;
float [] phaseAbleton =  new float[networkSize]; //;
float [] oldPhaseAbleton =  new float[networkSize]; //;

float [] oldPhaseLfo = new float[networkSize]; //;
float [] newPhaseLfo = new float[networkSize]; //;

float [] newPosY = new float[networkSize]; //;
float [] LFO = new float[networkSize]; //;

float [] phaseFollowLFO= new float[networkSize]; // 
float [] oldPosF= new float[networkSize]; // 
float [] newPosF= new float[networkSize]; //
float [] oldLfoPhase=  new float[networkSize]; //
float [] lfoPhase=  new float[networkSize]; //
int[] dataMappedForMotor =  new int[networkSize]; //
int[] positionToMotor =  new int[networkSize];
int[] oldPositionToMotor =  new int[networkSize];
int[] revLfo =  new int[networkSize];

// for mode keyMetro < in fonction PatternFollowLfo()
int[] dataToChange =  new int[networkSize]; //
float [] oldMotorToVisualPhase = new float[networkSize];
float [] motorToVisualPhase = new float[networkSize ];
//float [] phaseShiftingFollowLFO = new float[12];




  
//int frameRatio = 20;
//int nbBall = 9;
//int nbMaxDelais = 2000;




//******************       INTERPOLATION AND  SamplingMovement
int v1;// position motor from Teensy 
int virtualV2; // position virtual to simulate v1
int v3;
int phase11;
float addPhase;
float addPhaseAllMode;
float trigLfo; // send only to float to osc
float oldMov;
float movementRecording; 

// to interpolate angle
 public float mlerp(float x0, float x1, float t, float M ){
   float dx = (x1 - x0 + 1.5f*M) % M - 0.5f*M;
   return (x0 + t * dx + M) % M;
}



int formerBeatPrecised, beatPrecised, formerMeasure, formerBeatOnMeasure; // autmationWithMeasureAndNote
int lastMeasureRecordStart, measureRecordStart, beginSample, endSample;
boolean beatPrecisedTrigged;
int timeFrameOffsetFollowing;


// RECORD MOTOR 0 and SAMPLING MOVEMENT and PLAIY IT in LOOP

int frameSampling; 
int v2 =400;
int z;

int  counterV1;
int  oldv1;
//Record and repeat movement

boolean trigFollowSampling=true;
boolean trigRatio;
int  delayTimeFollowPhase11=0;
float phaseShiftingFollowPhase11=0;
int num = 40; // you need normally 45 frameSamplings/s but actually with a 3D setting you  need only 40 frameSamplings
int numberSec = 5;

float mx[] = new float[num*numberSec]; // memorised frameSampling played 
float my[] = new float[num*numberSec]; // 

float rx[] = new float[num*numberSec]; // recorded frameSampling
float ry[] = new float[num*numberSec]; 

int beginTime,endTime,TimeMiddleElapsed,LastTimeMiddleElapsed,LastTimeElapsed;
int restartTimer;
float Timer,Timer2;

// END RECORD MOTOR 0 and SAMPLING MOVEMENT and PLAIY IT in LOOP


// fonction FOLLOW phase Jo
String debug ="";
String dataToControlMotor;

int nbBall = 12;
int nbMaxDelais = 2000;

// Variable pour suivre un mouvement avec un decalage en frame et phase. DANS les FONCTIONS commencant par follow
boolean firstFollowingLast = true;
float deltaFollow = PI/180;
boolean firstFollowingStarted = false;

float [][] phases = new float[nbBall][nbMaxDelais];
int[] phaseToMotor;
float [] phaseMapped;
float [] phaseMappedFollow;

float b, a;
// fin fonction JO

int bg = rcolor();
 public int rcolor() {
  return ( color( random(255), random(255), random(255) ) );
}
// Variable pour fonction avec starter et inteerphase

float [] interFrequency =  new float[networkSize];
float [] interPhase  =  new float[networkSize];
float [] interPhaseCircular  =  new float[networkSize];
int oldOldOldMemoryi, oldOldMemoryi;
int lastTimeTrigged;
int TimeTrigged;
float [] TrigRightTemp  =  new float[networkSize];
float [] interPosition = new float[networkSize];
int [] upstairVpos = new int[networkSize];
int [] upstairOldVpos = new int[networkSize];
int [] LasttimeTrigged = new int[networkSize];
int [] timeTrigged = new int[networkSize];
int lastTimeUpstair;
boolean [] upstairShifting;
boolean [] clockWay;
boolean [] oldClockWay;
int [] ClockWay = new int[networkSize];
int [] FactorWay = new int[networkSize];
//boolean upstairShifting; 

int upstairTime=0;
int TimeUpstair=0;
float [] PhaseDecay;
int oldMemoryi;
int oscillatorMoving;
int OldoscillatorMoving;
boolean [] oldOscillatorMoving; 
boolean [] OscillatorMoving; 
int millisRatio;
String JoDebug;
int incrementSpeed; // the speed of periodic wave
int[] formerEvent = new int[networkSize];
int[] TimeEllapsedBall = new int[networkSize];

float [] automationLFO;
int numberOfStep=6400;
int speedDelta=18; // ratio of speed and acceleration in Arduino
float averageDeltaPhase;
boolean twoTree=false;
boolean treeFour=false;
boolean fourFive=false;
boolean fiveSix=false;
boolean sixSeven=false;
boolean sevenEight=false;
boolean eightNine=false;
boolean nineTen=false;
boolean tenEleven=false;
boolean elevenTwo=false;
boolean [] followNumber;
int currentTime;
float [] pseudoTimer;
float [] timer;
float [] phaseReturned;
float k=0; // factor of phiShift in fonction formerkeyo
int d=0; // factor of timeOffset before trigging phaseshifting in fonction formerkeyo
boolean [] factorWay; // factor of phiShift according the oscillator moving in upstairx in cw or ccw
int timeOffset=1;
float phiShift=-PI/4;
float mapShiftPendular; // map the scale of K * phiShift
float mapShiftCircular;
float LFOX;
float LFOY;

//import the necessary libraries to use send, receive and understand OSC data



// OSC loading stuff
OscP5 o;//Receive Piano/ Only track 1 from live 
OscP5 oII;//Receive Data/ Automation from Live
OscP5 oscP5;//send data
OscP5 oscP5bis;//send data
NetAddress myRemoteLocation; // send data  to Live
NetAddress myRemoteLocationII; // send data  to Live

float[] dataToLive; 
int[] upVelocity = new int[networkSize]; 
int[] downVelocity = new int[networkSize]; 
float Velocity;
int autmationWithMeasureAndNote;
int beatOnMeasure;
int actualMeasure;

int formerFrameBeat;
float formerAutomation ;
int LastBeat=0;
boolean beatTrigged;

// potar position scaled 0 to 1
float formerAutomation1;
float automation1, automation2, automation3, automation4, automation5, automation6, automation7, automation8, automation9  = 0; 


// midi note data
B_String string1, string2, string3, string4, string5, string6, string7, string8;
int velocity1, velocity2, velocity3, velocity4, velocity5, velocity6, velocity7, velocity8 = 0;
float ver_move1, ver_move2, ver_move3, ver_move4, ver_move5, ver_move6, ver_move7, ver_move8;
float duration1, duration2, duration3, duration4, duration5, duration6, duration7, duration8;
int note1, note2, note3, note4, note5, note6, note7, note8  = 0;

// END OF OSC DATAS

int oscillatorBlocked;

int pendular;  //actualise datas. 
boolean circularMov; //switch datas of positions in a pendular way
boolean trigTest; // Trig data when oscillator is on the left

// variable to manage graphics 
PNetwork netG;
int numRows = 12;
int numCols = 12;
int networkSizeGraphic = numRows * numCols;
int gridSize = 16;  

float Coupling;
float sigma; 
float Freq; 
// end of variable to manage graphics 

int orderframe;
int stoploop ;
int memoryi;
float f=0.05f; // FOLLOW MODE to incremente phase with  formerkey =='f'
float fmemory;

boolean F11 = true;  
//MANAGE START STOP into LIVE

int startStop;

int nextScene=0; // Do not trig nextScene
int cohesionTrig;

//Manage when oscillator 11 trig his position=0
boolean ready = false;
float pulsation; // nnot used
int pause_start_time, sketch_pause_interval = 0;
int prev_time;

// MANAGE Time according the frame.
float TimeFrame;
int lastMillis = 0;
int sec; 

float timeFrame;
boolean running = true;

int pair=0; // to manage wether I control oscillator odd or even.

// MANAGE NETWORK of OSCILLATOR




// variable of the setting of oscillator network

float x, y;
float side;  
float displacement;
float NaturalF;
//float coupling;
float noiseScale= 1;
float radius;
float orderParameter;
float coupling;
float formerCoupling;
float averagePhase;
float averageFrequency;

float stepSize;
int[] rev; //(counter of revolution of each oscillator);

// MANAGE data TO SEND POSITION or SPEED to ARDUINO
int[] oldVirtualPosition =new int[networkSize];
int[] VirtualPosition  = new int[networkSize];
int[] pos= new int[networkSize];
int[] oldPos = new int[networkSize];
int[] Pos = new int[networkSize]; // to convert data of position always positively
int[] modPos = new int[networkSize]; // ta have special position  quarter or half round
int[] modOldPos = new int[networkSize]; //to have former
int[] modOldOldPos = new int[networkSize]; //to have former
int[] TrigmodPos = new int[networkSize]; // to trig accordinag modPos;

int[] counter= new int[networkSize];


float[] metroPhase; 
float[] metroOldPhase; // convert circular to pendular
float[] abstractPhase; // to compute abstract phase
float[] OldFrequency;
float[] divideFrequency;

int[] PendularVirtualPosition = new int[networkSize];
int[] CircularVirtualPosition  = new int[networkSize];;
int[] DataToDueCircularVirtualPosition  = new int[networkSize];;
int[] ActualVirtualPosition  = new int[networkSize];;
int[] ActualVirtualPositionFromOtherMode  = new int[networkSize];;
int[] oldActualVirtualPosition  = new int[networkSize];;
int[] PendularOldVirtualPosition  = new int[networkSize];;
int[] CircularOldVirtualPosition  = new int[networkSize];;
int[] PendularLeftVirtualPosition  = new int[networkSize];;
int[] PendularOldLeftVirtualPosition  = new int[networkSize];;
int[] PendularOldOldLeftVirtualPosition  = new int[networkSize];;
int[] PendularOldOldOldLeftVirtualPosition  = new int[networkSize];;

int[] revolution;
int[] pseudoRevolutionTodeblock;
// WHAT TO CHOSSE?????  200*4 ou 200*8=?????
int[] decompte; // decremente a number when a revolution is trigged
int[] mapAcceleration;
int[] mapAccelerationinversed;


int [] j; // to reduce the number of revolution to their number even or odd  

//MANAGE VARIABLE TO MODULATE MOVEMENT with different CASES AUTOMATICALY
int caseNumber;
char caseLetter;

// MANAGE COUNTER of COHESION to manage sound
// Trig counter when cohesion is >=0.99
int orderCohesion;
int cohesionCounterHigh;
int cohesionCounterLow;

// Trig counter when cohesion is <=0.01
int orderCohesionLow;
int cohesionCounterHighLow;
float LevelCohesionToSend;

// MANAGE PERSPECTIVE

PeasyCam cam;

// change these for screen size
float fov = 45;  // degrees
float w = 1000;
float h = 800;

// don't change these
float cameraZ, zNear, zFar;
float w2 = w / 2;
float h2 = h / 2;

int frameRatio;

// SPECIFIED DATAS TO MAX MSP
float bPM9;
int BPM9;
int constrainedBPM; 
int onOFF;

//********** to RECORD and  playback data in the skecth folder
int formerKey; 
int formerSartKey; 
int formerKeyCode;
int formerFormerKey; 
int formerKeyCodeAzerty;
int formerFrame;
int formerKeyMetro;

int Key;
int KeyCode;

int couplingRed;
float couplingRecorded;

String[] lines;
int index = 0, nextFrame = 0; // these stay the same
// To outpout data recorded as sequences of case on Keypressed
PrintWriter output;

//********************* Data mapped to send To MAX 4 LIVE
int  orderToexpMappedOpposedLive; 
int  acc0ToexpMappedBisLive, acc9ToexpMappedBisLive; 

//BPM
float [] bpmFrequency;
float bpmToSend= 0.0f;

//frame where to stop
//int framecount=10040;//4440 //5040  0à°)-_
int framecount=30040;//4440 //5040  0à°)-_

 public void frameStop() { 
  if (frameCount%framecount ==  0 ) { /// choose the in the   frame where you want to stop
    stoploop = 10; // incrmente the step to the next frame
    framecount = framecount  + stoploop ;
    noLoop();
    //       print (" last or : ");   println (orderframe );
    orderframe  = framecount;
    //       print ("a:ctual order : ");   println (orderframe );
  }
}     
 public void setup() {
  sampler = new Sampler();

  LastTimeMiddleElapsed=1980;
  LastTimeElapsed=4000-20;
  //  noStroke();
  fill(255, 0, 0, 50); 
  println("Start Drawing!");
  //  frameRate(45);
  v1=counterV1=height/2;

  // end sampling

  int midiNoteAndOtherData  = 300;
  int networkSize = 6;
 
  formerEvent= new int[300];
  formerSartKey='#';
  autmationWithMeasureAndNote=1;
  oscillatorBlocked = 2;

 
  automationLFO = new float [networkSize];
  followNumber= new boolean [networkSize];
  pseudoTimer = new float [networkSize];
  timer =  new float [networkSize];
  phaseReturned =  new float [networkSize];
  
  k=0; // set phase offset to 0
  d=0; // set time offset to 0

  TimeEllapsedBall= new int[networkSize];
  timeTrigged = new int[networkSize];
  TrigRightTemp = new float[networkSize];
  upstairVpos = new int[networkSize];
  upstairOldVpos = new int[networkSize];
  LasttimeTrigged = new int[networkSize];
  interPosition = new float[networkSize];
  PhaseDecay = new float[networkSize];
  interPhase = new float[networkSize];
  interFrequency = new float[networkSize];
  interPhaseCircular = new float[networkSize];
  factorWay = new boolean[networkSize];


  float noiseLevel = 0 ; // Usefull only with case Q?

  // Osc midi potar
  automation1= automation2= automation3= automation4= automation5= automation6= automation7 = 0.5f;
  o = new OscP5(this, 2346);//receive data from a port number - it has to be same as in your Max for Live device // careful to oveflow
  oII = new OscP5(this, 2350);//receive data piano partitionII

  oscP5 = new OscP5(this, 7999);//receive data to himself
  //  oscP5bis = new OscP5(this, 8002);//receive data to himself

  // myRemoteLocation = new OscP5(this, 8000); // rsend data to live. define address ove which the communication takes place. Requires host address (127.0.0.1 for localhost and the port number previously defined.)
  // myRemoteLocationII = new OscP5bis(this, 8001); // receive data fto live. define address ove which the communication takes place. Requires host address (127.0.0.1 for localhost and the port number previously defined.)

  myRemoteLocation = new NetAddress("127.0.0.1", 8000); // rsend data to live. define address ove which the communication takes place. Requires host address (127.0.0.1 for localhost and the port number previously defined.)
  myRemoteLocationII = new NetAddress("127.0.0.1", 8001); // receive data fto live. define address ove which the communication takes place. Requires host address (127.0.0.1 for localhost and the port number previously defined.)

  dataToLive= new float[networkSize];
  upVelocity= new int[networkSize];
  downVelocity= new int[networkSize];
  //OSC midi note data

  string1=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.2f, 250);
  string2=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.3f, 50);
  string3=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.4f, 150);
  string4=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.5f, 100);
  string5=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.6f, 200);
  string6=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.7f, 0);
  string7=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.8f, 133);
  string8=new B_String (width*0.1f, width*0.3f, width*0.7f, width*0.9f, height*0.9f, 278);

  //  noLoop ();

  startStop = 0; // data used in Live
  frameRatio = 30;///30/5=> 108/5 BPM 21.6  or 114/5 = 22.8
  frameRate(frameRatio); //57 frame pour 1 tour. // joure avec G et g et cf le p

  stepSize = 10; // no effect //  net.stepSize = 1; // no effect  
  // Creat text with cases, in order to have a sequence according cases
  //================ record data to the skecth folder
  output = createWriter("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis5FINAL39.txt");// 
  output.println("0:0:0:0:0: addSignalOneAndTwo ");   
  //================ donwload data from the skecth folder

  //********************  
  // lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEcontinueBisElague.txt");//retire o garde pendulaire 5366:36:56:42
  lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis2.txt");// // to play to trig LIVE
  lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis5FINAL6.txt");// drole d'effet vers frame 16000 
  lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis5FINAL13.txt");//
  lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis5FINAL16.txt");//
  
  lines = loadStrings("OVERCOOL/viergelentAlongRecBisVitesse8FRAMEFaireVVraimentBis5FINAL33.txt");//  // 33 fonctione


  //********************  fichier vierge
 //  lines = loadStrings("vierge.txt");
   lines = loadStrings("viergechar.txt");
  // lines = loadStrings("madrushstart.txt");
  readOneLine(); // play case frame by frame. Uncomment if you want play in live
  textSize(200);

  //********to send value to serialport

  String[] ports = Serial.list();
  printArray(Serial.list());
  //*************** WITH TEENSY connected
    teensyport = new Serial(this, ports[1], 115200);// si port non connecte
 //   teensyport = new Serial(this,ports[2],115200); //  si port connecté
  //*************** WITHOUT TEENSY connected
  //  DueSerialNativeUSBport101 = new Serial(this, Serial.list()[3], 115200);

  // Read bytes into a buffer until you get a linefeed (ASCII 10):
  //  DueSerialNativeUSBport101.bufferUntil('\n');

  //********************************************************* BEGIN GRAPHIC CHIMERA STATE SETUP
  float[][] Coupling = new float[networkSizeGraphic][networkSizeGraphic];
  float sigma = 0.25f; // play with this? How can I do?
  initializeCoupling(Coupling, sigma);
  float[] phase = new float[networkSizeGraphic];
  initializePhase(phase);
  float[] naturalFrequency = new float[networkSizeGraphic];
  Freq = PI / 8; // play with this PI/8
  initializeNaturalFrequency(naturalFrequency, Freq);
  netG = new PNetwork(this, phase, naturalFrequency, Coupling);

  colorMode(HSB, TWO_PI, 100, 100);
  noStroke();

  //********************************************************* END GRAPHIC CHIMERA STATE SETUP
  rev = new int[networkSize]; // counter of rev
  j= new int[networkSize]; // reduce  the number of rev  to the number even or odd with 0 or 1 /

  oldVirtualPosition= new int[networkSize];
  VirtualPosition= new int[networkSize];
  pos= new int[networkSize];
  oldPos= new int[networkSize];
  Pos= new int[networkSize];
  modPos= new int[networkSize];
  modOldPos= new int[networkSize]; 
  modOldOldPos=new int[networkSize]; 

  metroPhase= new float[networkSize]; 

  metroOldPhase= new float[networkSize]; 
  abstractPhase = new float[networkSize]; 
 
  OldFrequency = new float[networkSize]; 
  PendularVirtualPosition = new int[networkSize]; 
  CircularVirtualPosition = new int[networkSize]; 
  DataToDueCircularVirtualPosition =new int[networkSize]; 
  ActualVirtualPosition = new int[networkSize];
  ActualVirtualPositionFromOtherMode = new int[networkSize];
  oldActualVirtualPosition = new int[networkSize];

  PendularOldVirtualPosition = new int[networkSize]; 
  CircularOldVirtualPosition = new int[networkSize]; 
  PendularLeftVirtualPosition = new int[networkSize];
  PendularOldLeftVirtualPosition = new int[networkSize];
  PendularOldOldLeftVirtualPosition = new int[networkSize];
  PendularOldOldOldLeftVirtualPosition = new int[networkSize];
  TrigmodPos = new int[networkSize]; 
  revolution= new int[networkSize];
  pseudoRevolutionTodeblock= new int[networkSize];
  decompte=  new int[networkSize];
  mapAcceleration=new int[networkSize];
  mapAccelerationinversed=new int[networkSize];
  divideFrequency= new float[networkSize];

  coupling = 0; 

  net = new PNetwork(this, networkSize, coupling, noiseLevel);
  side = height*0.15f*1/networkSize;
  displacement = width/2;

  minim   = new Minim(this);

  // this opens the file and puts it in the "play" state.                           
  filePlayer = new FilePlayer( minim.loadFileStream(fileName) );
  // and then we'll tell the recording to loop indefinitely
  // filePlayer.loop();

  // this creates a TickRate UGen with the default playback speed of 1.
  // ie, it will sound as if the file is patched directly to the output
  rateControl = new TickRate(1.f);

  // get a line out from Minim. It's important that the file is the same audio format 
  // as our output (i.e. same sample rate, number of channels, etc).
  out = minim.getLineOut();

  // patch the file player through the TickRate to the output.
  filePlayer.patch(rateControl).patch(out);
  //**************************
  // to play synthesis with minim. Not used anymore

  phazi=  new float[networkSize];
  speedi= new float[networkSize];
  freqi=  new float[networkSize];
  volumei= new float[networkSize];
  bpmFrequency= new float[networkSize];
  //**************************
  /*  to manage later reflection on sphere
   colorMode(RGB, 1);
   //  fill(0.4);
   */
  //***************************************** SET 3D CAM 
  cam = new PeasyCam(this, 2000);
  cameraZ = (h / 2.0f) / tan(radians(fov) / 2.0f);
  zNear = cameraZ / 10.0f;
  zFar = cameraZ * 10.0f;
  println("CamZ: " + cameraZ);
  rectMode(CENTER);
  //***************************************** END 3D CAM   
  //***************************************** SET minim library to discriminate 3 differents frequencies in a mp3 

  //  minim = new Minim(this);
  //** song = minim.loadFile("09-The Secret Agent Ending.mp3", 1024);
  //**song.play();

  //  beat = new BeatDetect(song.bufferSize(), song.sampleRate());
  //  beat.setSensitivity(400);//300 ou 100? 

  kickSize = snareSize = hatSize = 16;
  // make a new beat listener, so that we won't miss any buffers for the analysis
  bl = new BeatListener(beat, song);  
  textFont(createFont("Helvetica", 16));
  textAlign(CENTER);
  //***************************************** set position and coupling of oscillators
  mouseX= width/2;
  // in order to have coupling=0;
  //   formerKeyMetro = '£'; // to begin with circular phase;
  formerKeyMetro = '$'; // to begin setting of phase with pendular phase in the menu $ ; 
 // formerKeyMetro = 's';
  circularMov=false;
  for (int i = 0; i < networkSize; i++) {
    //   net.phase[i] = (i*PI/2);// position 0 at the top
    net.phase[i] = PI/2;// position 0 at the top
    //   net.phase[i]=-PI+0.5*PI+PI/12; // position 0+PI/12
  }
  upstairShifting = new boolean [networkSize];
  clockWay = new boolean [networkSize];
  oldClockWay = new boolean [networkSize];
 // ClockWay = new int [networkSize];
  FactorWay = new int [networkSize];
  oldOscillatorMoving = new boolean [networkSize];
  OscillatorMoving = new boolean [networkSize];

  for (int i = 0; i < networkSize; i++) {

    oldOscillatorMoving[i]=false;
    OscillatorMoving[i]=false;
    // factorWay=new int [networkSize];
    // PhaseDecay=new float [networkSize];

    //   net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-1-i)); // TWOPI/10--> 10 hit * 3%PI/3 with and oscillator11 not affected

    //    net.phase[i] += ((TWO_PI/(networkSize/3))*(i+1)); // TRES BIEN  ==     net.phase[i] += (i+1)*TWO_PI/4; //4hit  ==   net.phase[i] +=  (i+1)*3.5*PI; 
    //    net.phase[i] = net.phase[i]%TWO_PI; // TRES BIEN
    // key='e'; keyReleased();
    // arduinoPos();
    //  printSummary(i);  
    //    keyCode =BACKSPACE;
  }

  for (int i = 0; i < networkSize; i++) {
    //   ActualVirtualPosition[i]=80*i;


    // DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i]+800;
    DataToDueCircularVirtualPosition[i]= (int) map ( DataToDueCircularVirtualPosition[i], -800, 800, 1600, 4800)+ ActualVirtualPosition[i];  // mapped for 6400 step/round +800

    //  dataToLive[i]=(float)  map(DataToDueCircularVirtualPosition[i], 1600, 4800, 0f, 1f);
  }
  for (int i = 0; i < 300; i++) {
    // which+1 is the smallest (the oldest in the array)
    //  formerEvent[i]=0; //Time elapsed before trigging event
  }
  for (int i = 2; i <  networkSize; i++) {
    phaseToMotor= new int [networkSize];
    phaseMapped= new float [nbBall];
    phaseMappedFollow= new float [nbBall];
    ActualVirtualPosition[i]= 0;

    for (int j = 2; j < nbMaxDelais; j++)
      phases[i][j] = -PI;
      
  }
//keyMode = " addSignalOneAndTwoBis ";  
keyMode = " samplingModeInternal ";                                                                                                                                                                                                                 
formerKeyMetro = '*';
 
}
// END SETUP
 public void mouseXY () {  // MODULATION OF SIGMA and FREQ into GRAPHIC chimera state. No effect
  sigma =  (  map ((PApplet.parseFloat (mouseX)/width*1), 0, 1, 0.0f, 1.0f ));
  print ("Sigma"); 
  println (sigma);
  Freq  =  (  map ((PApplet.parseFloat (mouseY)/width*1), 0, 1, 0.0f, 0.05f ));
}
public void settings() {
  size(600, 600, P3D);
//  windowRatio(600, 600);
} 
 public void goZero () {
  for (int i = 0; i < 12; i++) {
    //  net.phase[i]=-PI+0.5*PI+PI/12;
    net.phase[i]= -PI/2;
  }
}

int numFrame = 900;
float LFOmemory[] = new float[numFrame];
float Automation1[] = new float[numFrame];
int formerAuto;



boolean[] moveKeys = new boolean[99];

 public void setMovement(int k, boolean b) {//azeqsdwxcrty
  switch (k) {
  case 'a':
    moveKeys[0] = b;
    break;
  case 'z':
    moveKeys[1] = b;
    break;
  case 'e':
    moveKeys[2] = b;
    break;
  case 'q':
    moveKeys[3] = b;
    break;
  case 's':
    moveKeys[4] = b;
    break;
  case 'd':
    moveKeys[5] = b;
    break;
  case 'w':
    moveKeys[6] = b;
    break;
  case 'x':
    moveKeys[7] = b;
    break;
  /*       if (keyCode == CONTROL){ // .. in Keypressed =true, inKeyRelesed == false  // moveKeys[8]=true; }   */
  case 'c':
  moveKeys[9] = b;
  break;
  case 'r':
  moveKeys[10] = b;
  break;
  case 'f':
  moveKeys[11] = b;
  break;
  case 'v':
  moveKeys[12] = b;
  break;
    case 't':
  moveKeys[13] = b;
  break;
   
  }
}

 public void mousePressed() {  
  mouseRecorded = true;
  measure = 0;
  }
// before draw


 public void draw() {
  
    background(0);
//  printDataOnScreen();
  
 println (" ");
 print ("BEGIN OF MAIN KEYCODE  ");   
 
  print (PApplet.parseChar(keyCode)); 
  print (" Key ");  
  print (PApplet.parseChar(key)); 
  print (" formerKey "); 
  print (PApplet.parseChar(formerKey)); 
  print (" formerFormerKey "); 
  print (PApplet.parseChar(formerFormerKey)); 
  print (" formerSartKey ");  
  print (PApplet.parseChar(formerSartKey));
  print (" formerKeyMetro ");  
  print (PApplet.parseChar(formerKeyMetro));
  print (" keyMode ");  
  print (keyMode);
  print (" beatTrigged ");  
  print (beatTrigged);
  print ( " mouseRec ");  println (  mouseRecorded );
  
    if (moveKeys[0]==true){ // CONTROL && a pressed
 //   mappingMode = " circular " ;
    print (" ***************** ", mappingMode);
   
    }
    
    if (moveKeys[1]== true){ // CONTROL a && z pressed
 //   mappingMode = " pendular " ;
    print (" ***************** ", mappingMode);
   
    }  

  
    if (moveKeys[8]==true && moveKeys[0]==true){ // CONTROL && a pressed
  //  keyMode = " signal " ;
    keyMode = " addSignalOneAndTwoTer " ;
  // formerKeyMetro = '@';
    print (" keyMode ", keyMode );
    }
  
    if (moveKeys[8]==true && moveKeys[1]==true){ // CONTROL && z pressed
    keyMode = " addSignalOneAndTwo " ;
   // formerKeyMetro = '@';
    print (" keyMode ",  keyMode );
    }
    
    if (moveKeys[8]==true && moveKeys[2]==true){ // CONTROL && e pressed
    keyMode = " addSignalOneAndTwoBis "  ;
  //  formerKeyMetro = '*';
    print (" keyMode ",  keyMode );
    }

      if (moveKeys[8]==true && moveKeys[10]==true){ // CONTROL && r pressed
    keyMode = " addSignalOneAndTwoQuater "  ;
  //  formerKeyMetro = '*';
    print (" keyMode ",  keyMode );
    }
    
        
    if (moveKeys[8]==true && moveKeys[3]==true){ // CONTROL && q pressed
    keyMode = " followDirectLfo " ;
    formerKeyMetro = '@';
    print (" keyMode ",  keyMode );
    }
    
    if (moveKeys[8]==true && moveKeys[4]==true){ // CONTROL && s pressed
    keyMode = " followDistribueAddphasePattern " ;
    
    formerKeyMetro = '*';
    print (" keyMode ",  keyMode );
    }
    
    if (moveKeys[8]==true && moveKeys[5]==true){ // CONTROL && d pressed
    keyMode = " followDistribueAddLfoPattern " ;
    
    formerKeyMetro = '*';
    print (" keyMode ",  keyMode );
    }
    
    if (moveKeys[8]==true && moveKeys[6]==true){ // CONTROL && w pressed
    keyMode = " samplingMode " ;
    
   // formerKeyMetro = '*';
    print (" keyMode ",  keyMode );
    }
    
    if (moveKeys[8]==true && moveKeys[7]==true){ // ALT && x pressed
    overKeyMode = " null " ;
    
   //formerKeyMetro = '*';
    print (" keyMode ",  keyMode, " formerKeyMetro ", formerKeyMetro );
    }
    
   if (moveKeys[8]==true && moveKeys[9]==true){ // ALT && c pressed  moveKeys[9]==true  //  r pressed  moveKeys[10]==true
    keyMode = " followDistribueAddLfoPatternControl " ;
    formerKeyMetro = '*';
     
 //  formerKeyMetro = '#';  // can't add phasee
    print (" keyMode ",  keyMode, " formerKeyMetro ", formerKeyMetro );
    }

   if (moveKeys[8]==true && moveKeys[11]==true){ // ALT & f
    keyMode = " methodAbleton " ;
    formerKeyMetro = '*';
  }
    
     if (key == '%' ){ // % pressed
    keyMode = " phasePattern " ;
   
    
   formerKeyMetro = '*';
    print (" keyMode ",  keyMode, " formerKeyMetro ", formerKeyMetro );
    }
    
        if (key == 'ù' ){ // % pressed
    keyMode = " abletonPattern " ;
    abletonPattern();
   
    
   formerKeyMetro = '*';
    print (" keyMode ",  keyMode, " formerKeyMetro ", formerKeyMetro );
    }
    
    
    
    
    
    
    
    
    
    
   
   if (keyMode == " followDistribueAddLfoPatternControl " ){ //moveKeys[8]==true && // CONTROL 
   // if (formerFormerKey!='#'){
     /*
     if (Key!='#'){
    controlTrigLfoPattern = millis();
  
     }
       */
 //  keyMode = " followDistribueAddLfoPatternControl " ;
    
  // formerKeyMetro = '';
    }
    
    
    
       
    setMovement(key, false); 
        println (" modeStartKeyToFollow ", modeStartKeyToFollow, " keyModeRed",  keyModeRed,"keyMode",  keyMode, "formerKeyMetro ", formerKeyMetro, " controlTrigLfoPattern ", controlTrigLfoPattern );
    keyModeRed = keyMode; // dont read keyMode in file.txt

    if (keyMode == " addSignalOneAndTwoQuater " || keyModeRed == " addSignalOneAndQuater " ) { //drive ball with lfo
    //   PatternFollowLfo();
     propagationMode();
      text ( keyMode, -width, -height); 
    }
   
    if (keyMode == " addSignalOneAndTwoTer " || keyModeRed == " addSignalOneAndTwoTer " ) { //drive ball with lfo
    //   PatternFollowLfo();
     addSignalOneAndTwoTer();
      text ( keyMode, -width, -height); 
    }
    
    
    if (keyMode == " addSignalOneAndTwoBis " || keyModeRed == " addSignalOneAndTwoBis " ) { //drive ball with lfo
    //   PatternFollowLfo();
     addSignalOneAndTwoBis();
      text ( keyMode, -width, -height); 
    }  

  if (keyMode == " addSignalOneAndTwo " || keyModeRed == " addSignalOneAndTwo " ) { //drive ball with lfo
    //   PatternFollowLfo();
     addSignalOneAndTwo();
      text ( keyMode, -width, -height); 
    }
  
  if (keyMode == " methodAbleton " || keyModeRed == " methodAbleton ") { //drive ball with lfo
     methodAbleton();
     text ( keyMode, -width, -height); 
     
  }
  
  if (keyMode == " followDirectLfo " || keyModeRed == " followDirectLfo ") { //drive ball with lfo
     followDirectLfo();
      text ( keyMode, -width, -height); 
  }
  
  if (keyMode == " followDistribueAddphasePattern " || keyModeRed == " followDistribueAddphasePattern ") { //drive ball with lfo
     followDistribueAddphasePattern();
      text ( keyMode, -width, -height); 
  }
  
  if (keyMode == " followDistribueAddLfoPatternBis " || keyModeRed == " followDistribueAddLfoPatternBis ") { //drive ball with lfo
     followDistribueAddLfoPattern();
      text ( keyMode, -width, -height); 
  }
  
  if (keyMode == " samplingMode " || keyModeRed == " samplingMode ") { //drive ball with lfo
  //   followDistribueAddLfoPattern();
     text ( keyMode, -width, -height);
  }
  
  
  
  if (keyMode ==  " followDistribueAddLfoPatternControl " || keyModeRed == " followDistribueAddLfoPatternControl ") { // drive with CONTROL & r
       if (key!='#'){
    controlTrigLfoPattern = millis();
    }
     followDistribueAddLfoPatternControl();
  }
  
  if (overKeyMode == " null " ) { //|| keyModeRed == " null "
    //  followDistribueAddLfoPattern();
      text (overKeyMode, (width/2), height/2);  

  }
  
   if (keyMode == " phasePattern " ) { 
    //  followDistribueAddLfoPattern();
    // phasePattern();
      text (keyMode, (width/2), height/2); 
    

  }
  
  if (keyMode == " abletonPattern " ) { //drive ball with lfo
    //  followDistribueAddLfoPattern();
      abletonPattern();
      text (keyMode, (width/2), height/2);  

  }

  

  
    if (keyMode == " signal "){ // || formerKeyMetro == 'J'
         text ( keyMode, -width, -height); 
    for (int i = 2; i <  networkSize; i++) {
    net.oldPhase[i] =  net.phase[i]; 
    net.phase[i] =  map (signal[i], 0, 1, 0, TWO_PI);   //  
    println ( " signalTo_net.phase ", (i), net.phase[i] );
    
    if (net.oldPhase[i]>net.phase[i]){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (net.phase[i], TWO_PI, 0, numberOfStep, 0)); 
     net.oldPhase[i]=net.phase[i];
   
     }
       
     else
    
    DataToDueCircularVirtualPosition[i]= (int) map (net.phase[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
  

     }
     sendToTeensy();
     }
     
     
  
  
//  addPhaseAllMode =net.phase[2] + net.phase[3] + net.phase[4] +net.phase[5]+net.phase[6]+net.phase[7]+net.phase[8]+net.phase[9]+net.phase[10]+net.phase[11];
for (int i = 0; i < networkSize; i++) {
 
 addPhaseAllMode = addPhaseAllMode + net.phase[i];
  }
  print (" all automatik  "); println ( addPhaseAllMode);

  addPhaseAllMode =net.phase[0] + net.phase[1] + net.phase[2] +net.phase[3]+net.phase[4]+net.phase[5];//+net.phase[8]+net.phase[9]+net.phase[10]+net.phase[11];
  print (" all one by one "); println ( addPhaseAllMode);
  addPhaseAllMode= map (addPhaseAllMode,-(networkSize-1)*TWO_PI,(networkSize-1)*TWO_PI,0,1); 
  // addPhaseAllMode = 
  print (" all "); println ( addPhaseAllMode);
  formerBeatPrecised=beatPrecised;
  formerMeasure=measure;
  formerBeatOnMeasure=beatOnMeasure;
  if (keyMode != " samplingModeInternal " )
  { 
  measure=(int) map (automation4*10, 0, 7.874016f, 1, 1000); // mapping from Ableton measure
  // measure=(int) map (automation4*10, 1,1000 , 1, 1000);
  print ( " measure ");print ( measure);
  print (" AUTOMATION 5= beatPrecised  "); 
  beatPrecised=(int) map (automation5*10, 0, 7.874016f, 1, 1000); //  mapping from Ableton step in measure
 //  beatPrecised=(int) map (automation5*10, 1,1000 , 1, 1000);
  println (beatPrecised);
  }  
  recordFrame();
 
  print( " begin main loop " ) ;

    trigBeatWithMeasure();
 //   autmationWithMeasureAndNote();
 //**   printDataOnScreen();
 //   printMidiNoteVelocity();
    

    
  if (keyMode != " phasePattern ")
  {   
   if ( key =='B'||  key =='c' ||  key =='>' ||  key =='<' || key =='d' || key =='e'  ) // 
  {
  //  formerKeyMetro = key;   // press l to change formerKeyMetro Mode
   }
  }
  
  if (overKeyMode == " null ")
  {   
   if ( key =='a'||  key =='b' ||  key =='c' ||  key =='d' || key =='e' || key =='f' || key =='s' || key =='z' || key =='J'  ) // 
  {
    if (formerKeyCode == BACKSPACE) {
    modeStartKey = key;   // press l to change formerKeyMetro Mode
    }
   }
       
  switch( modeStartKey) {
    case 'a': 
    modeStartKeyToFollow = " followSignalSampledLPF ";
    print ( " modeStartKeyToFollow " );
    followSignalSampledLPF(frameRatio);
    break;
    case 'b': 
    modeStartKeyToFollow = " followDistribueAddLfoPatternLPF ";
        print ( " modeStartKeyToFollow " );

    text ( " followDistribueAddLfoPatternLPF ", width/4, -height/4);  
    followDistribueAddLfoPatternLPF();
    break;
    case 'c':     
    modeStartKeyToFollow = " followSignalSampledLPF ";
        print ( " modeStartKeyToFollow " );

    text ( modeStartKeyToFollow, width/4, -height/4);  
    followSignalSampledLPF(frameRatio);    
    break;
    case 'f':     
    modeStartKeyToFollow = " followSignalfo ";
        print ( " modeStartKeyToFollow " );

    text ( modeStartKeyToFollow, width/4, -height/4); 
    followSignalLfo(frameRatio, signal[networkSize-1]);
    break;

     case 'd':     
    modeStartKeyToFollow = " followDistribueAddLfoPattern ";
        print ( " followDistribueAddLfoPattern in KeyMode null " );

    text ( modeStartKeyToFollow, width/4, -height/4); 
  
    followDistribueAddLfoPattern ();
    break;


    case 's':     
    modeStartKeyToFollow = " samplingMode ";
        print ( " modeStartKeyToFollow " );

 //   text ( modeStartKeyToFollow, width/4, -height/4); 
     keyMode = " samplingModeInternal " ;
     text ( keyMode, width/4, -height/4); 
    break;

    case 'J':     
    modeStartKeyToFollow = " followSignalSampledOppositeWay(frameRatio) ";
    formerKeyMetro = 'J';  // to enable the method to be trigged to the next pulsation

    text ( modeStartKeyToFollow, width/4, -height/4); 
     keyMode = " modeStartKeyToFollow " ;
     text ( keyMode, width/4, -height/4); 
    break;

    case 'z':     
 //   modeStartKeyToFollow = " samplingMode ";
 //   text ( modeStartKeyToFollow, width/4, -height/4); 
     keyMode = " addSignalOneAndTwoTer " ;
  
     addSignalOneAndTwoTer();
    break;
   }
    text ( keyMode, width/4, -height/4); 
  }

   
    if (beatTrigged==true && formerKeyMetro == 's'){ // formerBeatOnMeasure>=4 && beatOnMeasure<=1 && 
        measureRecordStart=measure;
    //    beginSample=millis();
        print ("*****************************************************************************++++++++++++++++++++++ START SAMPLING  "); 
  
     //  formerKeyMetro = 'S';  // back to normal Mode with formerKeyMetro = '$';
   }
     
     
     
  
   if (formerKeyMetro == 'B' ){
    lfoPattern();
    splitTimeLfo();
  //   splitWithTime();
    addSignal(); 
     
     
 
  } 
  
  if (keyMode == " samplingMode "     ){ // || formerKeyMetro == 'J'
   println ( " IN SAMPLING ");   println ( " IN SAMPLING ");   println ( " IN SAMPLING ");

     beginSample=millis();
    text (keyMode + " samplingMode LFOdecay ", width/4, - height - 100);  
     
 
     
    
 
    //****  mouseY=(int) map (automation1, 0, 1, 0, 400);  //POSITION MOTOR wth serial.port
    
      //  mouseY = (int) map (signal[3], 0, 1, 0, 400);   // POSITION from ABLETON
    
        //  mouseY=(int) map (Movement/1000.0, 0, 1, 0, 400);  // to do WHAT?

     // followMovementAll();
     //  displayfollowMovementAll();
         activeSamplingMeasure(3);
         stopSamplingMeasure(4);
    
   //      activeSamplingInternalClock(7); //do not work
   //      stopSamplingInternalClock(8);  //do not work
         samplingMovementPro(); 
        
  //       print (" v1 ");   print (  v1);  print (" v1 ");   println (  v1); 
   //      sendToTeensy();
 }
 
     print( " INTERNAL CLOCK lastSec " ) ; print( lastSec ) ; print( " actual " ) ; print( actualSec ) ; print( " measure " ) ; println( measure ) ;
    
     if  (actualSec!=lastSec){
         lastSec=actualSec;
     if (keyMode == " samplingModeInternal " ){    
          measure ++;
       }
      }  
         actualSec =(int) (millis()*0.001f); 
         
   //*************    ENDINTERNALCLOCK  
  
  
   if (keyMode == " samplingModeInternal "     ){ // || formerKeyMetro == 'J'
     beginSample=millis();
     text ( keyMode + " mouseY " + measure , width/4, - height - 100);  
  
     
 //    mouseY=(int) map (automationLFO[1], 0, 1, 0, 400);  // position from Ableton LFOdecay
 
    //****  mouseY=(int) map (automation1, 0, 1, 0, 400);  //POSITION MOTOR
    
      //  mouseY = (int) map (signal[3], 0, 1, 0, 400);   // POSITION from ABLETON
    
        //  mouseY=(int) map (Movement/1000.0, 0, 1, 0, 400);  // to do WHAT?

     // followMovementAll();
     //  displayfollowMovementAll();
    //**     activeSamplingMeasure(3);
    //**    stopSamplingMeasure(4);
    
         activeSamplingInternalClock(3); //do not work
         stopSamplingInternalClock(4);  //do not work
         samplingMovementPro(); 
        
  //       print (" v1 ");   print (  v1);  print (" v1 ");   println (  v1); 
      //   sendToTeensy();
 }
 
 
 
 //**************   END MODE SETTING   *************************


  //  followSignal();

  formerAuto= frameCount-1;
  // see storeinput example to create sample


  // midi note data

  string1.display(ver_move1);
  string2.display(ver_move2);
  string3.display(ver_move3);
  string4.display(ver_move4);
  string5.display(ver_move5);
  string6.display(ver_move6);
  string7.display(ver_move7);
  string8.display(ver_move8);

  if (ver_move1>0) {
    ver_move1 = ver_move1 -duration1;
  }
  if (ver_move2>0) {
    ver_move2 = ver_move2 -duration2;
  }
  if (ver_move3>0) {
    ver_move3 = ver_move3 -duration3;
  }
  if (ver_move4>0) {
    ver_move4 = ver_move4 -duration4;
  }
  if (ver_move5>0) {
    ver_move5 = ver_move5 -duration5;
  }
  if (ver_move6>0) {
    ver_move6 = ver_move6 -duration6;
  }
  if (ver_move7>0) {
    ver_move7 = ver_move7 -duration7;
  }
  if (ver_move8>0) {
    ver_move8 = ver_move8 -duration8;
  }

  ver_move1 = - ver_move1;
  ver_move2 = - ver_move2;
  ver_move3 = - ver_move3;
  ver_move4 = - ver_move4;
  ver_move5 = - ver_move5;
  ver_move6 = - ver_move6;
  ver_move7 = - ver_move7;
  ver_move8 = - ver_move8;

  //potar data move the circle

  // translate(width/2, height/2);
  //OSC RECEIVE
  print(" automation3 followMadTrack  "); 
  print (automation3);
  incrementSpeed+=10;
  incrementSpeed=incrementSpeed%width;

  float ver_move = (float) incrementSpeed;
  float triangularLFO = map(automation2, 0, 1, -300, 300); //FollowLFO   .. used to autmationWithMeasureAndNote()
  float hor_move = map(automation3, 0, 1, -300, 300);  // //followMad

  float RColour = map(automation7, 0, 1, 0, 255);
  // float GColour = map(automation4, 0, 1, 0, 255);
  float LFO1= map(automation6, 0, 1, 0, 255);
  float LFO2= map(automation7, 0, 1, 0, 255);


  // println (map (automation4*10, 0, 7.874016, 0, 1000));



  float BColour = map(automation3, 0, 1, 0, 255);
  //  float XSize = map(automation6, 0, 1, 10, 80);
  float XSize = map(automation1, 0, 1, 10, 80);
  float YSize = map(automation3, 0, 1, 0, 320);
  
   float LFOphase1 = map(automation6, 0, 1, -300, 300);
   float LFOphase2 = map(automation7, 0, 1, -300, 300);
  //  fill(RColour, GColour, BColour);
  ellipse(ver_move, hor_move, 50, 50);
  ellipse(ver_move, triangularLFO, XSize, YSize);
//  ellipse(ver_move, LFOphase1, XSize, YSize); // seeAutomationAreverbershaper
//  ellipse(ver_move, LFOphase2, XSize, YSize); // seeAutomationAreverbershaper
  
  stroke (255,255,0);
  
    ellipse(ver_move, LFO1, XSize, YSize); // seeAutomationAreverbershaper
    
    ellipse(ver_move, LFO2, XSize, YSize); // seeAutomationAreverbershaper
  
  noStroke();
  //  ellipse(400, 400, GColour, GColour);



  // END midi note data 

  //  print (char(key)); println (char(formerKey));
  if (running == false) return;

  int m = millis();
  timeFrame += PApplet.parseFloat(m - lastMillis) * 0.001f;
  lastMillis = m;
  // background (0);
  //*********** to read on screen CASES from each frame count 

//**  printDataOnScreen();

  //* ************************ manage strobe with light()
  //  spotLight(102, 153, 100, mouseX, mouseY,cameraZ, 0, 0, -1, PI/2, 1000); 
  //  pointLight(51, 102, 126, mouseX, mouseY, cameraZ);
  if (1000/pulsation*60>=50 && 1000/pulsation*60<=200) { // pulsation of oscillator 11, at the front of the screen; transformed in BPM
    lights();
    if (frameCount%6==0) {
      noLights();
    }
  }
  //************************* end of manage light

  //   doNothing ();// to not repeat case with key
  //==============================TAKE ON BELOW TO RECORD COUPLING

  if (mousePressed != true) {
    coupling = map ((PApplet.parseFloat (mouseX)/width*1), 0, 1, -10, 10 ); //SET COUPLING
    //   key= '#'; keyReleased();
    // keyCode =CONTROL; keyReleased();
    //   net.setCoupling(coupling);
  }


  text(couplingRed, -400, height - 20); 
  //  *********** TAKE ON BELOW TO HAVE THE COUPLING RECORDED RED. AND TAKE OFF ABOVE 
  /*
    couplingRecorded= float (couplingRed)/1000;
   coupling= couplingRecorded;
   net.setCoupling(coupling);
   
   text(couplingRecorded, 400, height - 20);
   */
  //******************************** 

  //======================== TAKE OFF BELOW TO RECORD DATA //======================== TAKE OFF TO RECORD DATA
  if (frameCount == nextFrame) {
    readOneLine();  
    keyReleased(); 
    keyPressed();
  }
  //****************************
  // BEAT_DETECT ();
  //****************************
  print ("FRAMERATIO "); 
  print ((1*frameRatio)); // utilise map (de 1 à 60);
    print ("  ******   FRAMERATIO "); 

  // Calculate the overall order (cohesion) in the network
  PVector order = net.getOrderVector();

  // DATA of cohesion and acceleration of the first and last oscillator
  orderParameter = net.getOrderParameter();

  // averagePhase = order.heading();
 // averagePhase= (net.phase[11]+net.phase[10]+net.phase[9]+net.phase[8]+net.phase[7]+net.phase[6]+net.phase[5]+
 //   net.phase[4]+net.phase[3]+net.phase[2])/(networkSize-2);
  print ("AVERGE PHASE "); 
  print (averagePhase);

 // averageFrequency= (net.naturalFrequency[11]+net.naturalFrequency[10]+net.naturalFrequency[9]+net.naturalFrequency[8]+net.naturalFrequency[7]+net.naturalFrequency[6]+net.naturalFrequency[5]+
 //   net.naturalFrequency[4]+net.naturalFrequency[3]+net.naturalFrequency[2])/(networkSize-2);


  print ("                                   AVERGE FREQUENCY ");  
  print (averageFrequency);

  float deltaPhase = map ((PApplet.parseFloat (mouseY)/width*1), 0, 1, 0, QUARTER_PI ); // option not used
   
//**   averageDeltaPhase=  TWO_PI/ ((net.phase[11]+net.phase[10]+net.phase[9]+net.phase[8]+net.phase[7]+net.phase[6]+net.phase[5]+
// **  net.phase[4]+net.phase[3]+net.phase[2])/ (networkSize-2))*360;
   
  //   averageDeltaPhase=                    (abs((net.phase[11]+net.phase[10])))/TWO_PI*360;
 // averageDeltaPhase=                    (((abs (metroPhase[11])+ abs(metroPhase[10]))))/TWO_PI*360;
//  averageDeltaPhase= map (averageDeltaPhase, 0, TWO_PI, 0, 180);
  print ("                                    averageDeltaPhase ");  
  println (averageDeltaPhase);

  // SHOW_DATA ();
  //****************************
  translate(width/2, -height/2, -1000);// To set the center of the perspective
  rotate(-HALF_PI ); //TO change the beginning of the 0 (cercle trigo) and the cohesion point to - HALF_PI 

  // Draw  spheres corresponding to the phase of each oscillator
  colorMode(RGB, 255, 255, 255);
  //  stroke(75, 190, 70); // do not show the "perspective sphere"
//  print ("formerKeyMetro "); 

  
  if (actualSec==lastSec) {  // trigged on internal clock
      trigRatio = true;
    //  background(127, 40, 60);
   }
   
   else trigRatio = false;
   
   
    if (beatTrigged== true) {  // trigged with measure
      trigRatio = true;
    //  background(127, 40, 60);
   }
  
  else trigRatio = false;
   
  if (formerKeyMetro == 'J' ) { //drive ball with lfo ONCE //  && trigRatio == true
  trigFollowSampling=true;
  }
  
   if (formerKeyMetro != 'J' ) {
//   if (formerKeyMetro == 's' ||  formerKeyMetro ==  '@' || formerKeyMetro ==  'B' ) { //you can't distribuate data to others balls  //formerKeyMetro == '*' || formerKeyMetro == '$' ||
  trigFollowSampling=false;
  }
      
      
  if (trigFollowSampling == true ) {
      print (" trigFollowSampling ");   println (trigFollowSampling); 
  
    //  followMadTrack1bis(); ..  folloLFO with my technique
    //    followSignal();
  //****  delayTimeFollowPhase11=60;  // to control time phase offseet with a lot of delay time. You can wait one seconde before the next ball follow the previous ball
    
    
  //  followSignalSampled(frameRatio);
    samplingMovementPro();
  //  noStroke();
  //  fill( 255, 40, 40 );
  // circle ( 100* cos (movement)+400, 100*sin (movement)+400, 20);
  //   followSignalSampled(frameRatio); //no WORK with frame
     followSignalSampledOppositeWay(frameRatio);// with millis()
  //  phasePattern();
   // pendularPatternNoJoe(); // without transformation of position's datas in the Arduino.
    
    rotate(PI/2);
   //** printDataOnScreen();
    stroke(255);
    
  // display current time with rectange depending elapsed time 2, 4 and 8 sec
    rect( (currTime % 2) / 2 * width, 10, 2, 8 );
    rect( (currTime % 4) / 4 * width, 20, 2, 8 );
    rect( (currTime % 8) / 8 * width, 30, 2, 8 );
    
    rotate(-PI/2);
    countRevs();
   }
   
   modePendulaireModeCirculaire();
   

  
  // ================================= 


  // countRevs();   
  println(frameCount + ": " + Arrays.toString(rev));
  // ================== fonction not used
  // devant_derriere();
  // manageCoupling();
  // mouseMovedPrinted ();
  // SoundmouseMoved(); // to automatise sound with speed. In the setup uncomment the out1, out2 ...

  print ("KEY");    
  print (PApplet.parseChar(key)); 
  print ("formerKey: "); 
  print (PApplet.parseChar(formerKey));  
  print ("formerStartKey: ");  
  println (PApplet.parseChar(formerSartKey));
  if (formerKey== '!') {
    formerSartKey = formerKey;
  }

  if (key=='j') {// send a trig to start record in Ableton live 
    background(255);
    startStop= 3;//
    key='='; 
    keyPressed();
    print ("startStop from the beginning: "); 
    println (startStop);
    key='#'; // reset key to a key doing nothing
  } else {
    startStop= 2;
  } 

  // option to control sound in Live when the animation is stopped then started again and when oscillator 11 touches the left  
  if (formerSartKey == '!' &&  TrigmodPos[11]>=0 && TrigmodPos[11]<1) { 
    println ("TRIG LIVE WITH oscillator 11 on LEFT" ); //
    startStop= 1;  
    print ("MOVEMENT AND TIMER is already started, now START LIVE: "); 
    println (startStop );

    String dataMarkedToDue  ="<" 
      + mapAcceleration[11]+","+  PApplet.parseInt  (1000/avgTimer.average()*60*1000)  +","+cohesionCounterHigh+","
      //+ onOFF+"," +nextScene+","
      //     + mapAcceleration[11]+","+ mapAcceleration[11]+","+mapAcceleration[11]+","+ mapAcceleration[11]+","+mapAcceleration[11]+"," 

      +VirtualPosition[11] +","+VirtualPosition[10] +"," +(VirtualPosition[9]) +","+VirtualPosition[8] +","+VirtualPosition[7] +","
      +VirtualPosition[6] +","+VirtualPosition[5] +","+VirtualPosition[4] +","+VirtualPosition[3] +","+VirtualPosition[2] +","

      +TrigmodPos[11]+","+TrigmodPos[10]+","+TrigmodPos[9]+","+TrigmodPos[8]+","+TrigmodPos[7]+","+TrigmodPos[6]+","+TrigmodPos[5]+","+TrigmodPos[4]+","+TrigmodPos[3]+","+TrigmodPos[2]+","+TrigmodPos[1]+","+TrigmodPos[0]+ "," // to manage 12 note

      +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+ ","+ startStop + ">"; // (2= neither start, neither stop)   cohesionCounterHigh // +orderCohesion+ ">";LevelCohesionToSend ","+ int (map ( LowLevelCohesionToSend, 0, 1, 0, 100))+ 

    print ("dataStart: "); 
    println(frameCount + ": " +  " " + ( dataMarkedToDue ));

    formerKey = '#'; //reset formerkey to not trigging LIVE
    formerSartKey = formerKey;
  }
  print ("KEY ");    
  print (PApplet.parseChar(key)); 
  print ("FORMERKEY "); 
  print (PApplet.parseChar(formerKey)); 
  print ("FORMERSTARTKEY ");  
  println (PApplet.parseChar(formerSartKey));
  // bpmAsfrequencyfunction ();

  textSize (100);


  if ( key=='*' ) {// || key==',' || key==';' || key==':'
    circularMov = true;
  }

  if ( key=='$') {//
    circularMov = false;
  }

  cohesionTrig = PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100));
  println (cohesionTrig);


  // ***** automatise Oscillator Moving with a former Key
   arduinoPos(); // // carefull with arduinoPos and function after arduinopos
    if (formerKeyMetro != 'J' ) { //countRevolutions when it is not the mode J
   countRevs();
       }
       
   //**********************************************************************    
   // STARTERCASE with formerKey
 if ( overKeyMode != " null "  ) {  
    if ( keyMode == " phasePattern "  ) { 
 //       pendularPatternLFO();
      text ( " phase offset " + k + " delay " + d, - width-400, - height+400);
       
  if (formerKey=='o' || key=='ç'|| keyCode==SHIFT || key=='*' || key=='ç' || key==',' || key==';' || key=='A'
    || key=='n' || key=='N'   ) { //  || key=='ç'|| keyCode==SHIFT || key=='*' || key=='ç' || key==',' || key==';'
    //  formerKeyo();
    //  formerKeyoJo();
  }

  if (formerKey=='L') { // like V and shift two frequencies and phases at the same time
    formerSartKey='L';  // do note automatise movement of balls with note 
    // formerKeyL();
  } 
  if (formerSartKey=='L') { // like V and shift two frequencies and phases at the same time
    formerKeyL();
  }
  // oscillator moving
  // upstairauto

  // STARTERV Ar
  if (formerSartKey =='v' && (formerKey=='e' || formerKey=='z' || formerKey=='d' || formerKey=='r' || formerKey=='v')) { //  formerstartKey =='v' && || formerKey=='x'
    if (circularMov==false  ) {//|| circularMov==false
      for (int i = 2; i < (networkSize-0); i++) {
        PendularOldOldOldLeftVirtualPosition[i]=PendularOldOldLeftVirtualPosition[i];
        PendularOldOldLeftVirtualPosition[i]=PendularOldLeftVirtualPosition[i];
        PendularOldLeftVirtualPosition[i]=PendularLeftVirtualPosition[i];
        //    PendularLeftVirtualPosition[i]=CircularVirtualPosition[i];
        //   PendularOldLeftVirtualPosition[i]=CircularOldVirtualPosition[i];
      } 
      print ("STARTERvBIS PendularLeftVirtualPosition "); 
      print (memoryi); 
      print (" ");   
      print (PendularLeftVirtualPosition[memoryi]); 
      print ("STARTERvBIS PendularLeftVirtualPosition%"); 
      print (oldMemoryi); 
      print (" "); 
      println (PendularOldLeftVirtualPosition[oldMemoryi]); 

      if  ( 1>=1
        //        (PendularLeftVirtualPosition[memoryi]%6400 <= 100 &&  (PendularOldOldLeftVirtualPosition[oldMemoryi]%6400 <=  PendularOldLeftVirtualPosition[oldMemoryi]%6400 ) && // you turn on cw
        //        (PendularLeftVirtualPosition[oldMemoryi]%6400 <= PendularOldOldOldLeftVirtualPosition[oldMemoryi]%6400)) ||
        ) { //good with the ordination of the upstairc
        //  background (50,50,50);
        println ("HEREVBIS");   
        println ("HEREVBIS"); 
        print ("PendularLeftVirtualPosition"); 
        print (memoryi); 
        print(" "); 
        print (PendularLeftVirtualPosition[memoryi]);
        print ("PendularLeftVirtualPosition"); 
        print (oldMemoryi); 
        print(" "); 
        println (PendularOldLeftVirtualPosition[oldMemoryi]);            
        if  (millis()>TimeUpstair+d) {
          //  TimeUpstair=millis();
          TimeUpstair=millis();
          key='v'; 
          keyReleased();  
          println (" v  circular Pressed? ");
          //   formerKey='+';
          formerSartKey='v';
        }
      }
    }
  }
  // ***** automatise Oscillator Moving with a former Key

  // triggerv
  if (formerKey=='v') {
    formerKeyv(memoryi, oldMemoryi, k);
    formerSartKey ='v';
  }

 //*** arduinoPos();

  // triggerc

  if (formerSartKey =='c' && (formerKey=='&' || formerKey=='+')) { //  formerstartKey =='v' &&
    if (circularMov==true ) {
      for (int i = 0; i < (networkSize-0); i++) {
        PendularLeftVirtualPosition[i]=CircularVirtualPosition[i];
        PendularOldLeftVirtualPosition[i]=CircularOldVirtualPosition[i];
      } 
      print ("STARTER PendularLeftVirtualPosition "); 
      print (memoryi); 
      print (" ");   
      print (PendularLeftVirtualPosition[memoryi]); 
      print ("STARTER PendularLeftVirtualPosition "); 
      print (oldMemoryi); 
      print (" "); 
      print (PendularOldLeftVirtualPosition[oldMemoryi]); 

      if (millis()>TimeUpstair+d) {
        if  ((PendularLeftVirtualPosition[memoryi]%6400 >=  PendularLeftVirtualPosition[oldMemoryi]%6400 )) { //good with the ordination of the upstairc
          print ("PendularLeftVirtualPosition"); 
          print (memoryi); 
          print(" "); 
          print (PendularLeftVirtualPosition[memoryi]);
          print ("PendularLeftVirtualPosition"); 
          print (oldMemoryi); 
          print(" "); 
          print (PendularOldLeftVirtualPosition[oldMemoryi]);


          key='c'; 
          keyReleased();  
          println (" c circular Pressed? ");
        }
        TimeUpstair=millis();
      }
    }
    if (circularMov==false ) {
      if (millis()>=TimeUpstair+d) {
        if  (PendularLeftVirtualPosition[memoryi]> 400 ||  PendularLeftVirtualPosition[memoryi]<-400 ) { //&&  oldOscillatorMoving[i]== true
          print ("PendularLeftVirtualPosition"); 
          print (memoryi); 
          print(" "); 
          print (PendularLeftVirtualPosition[memoryi]);      
          key='c'; 
          keyReleased();  
          println (" c circular Pressed? ");
        }  
        TimeUpstair=millis();
      }
    }
  }
  
  if (formerKey=='c' ) {
  //  formerKeyc(memoryi, oldMemoryi);
    println (" FORMER formerKeyc ");
    String debug;
    debug = " FORMER formerKeyc string ";
    println (debug); 
    
    formerSartKey ='c';
  } 
  
  //************************************************************ //************************************************************   
  //************************************************************ //************************************************************ 
  //   begin of upstairAuto function 
  //    trigw = trigx
  if (formerKey=='w') {
    print (" formerKeyx? "); 
    print (formerKey );
 //   formerKeyCopposite(memoryi, oldMemoryi, k);
    formerSartKey ='w';
  }  
  //    trigX
  if (formerKey=='X') {
    print (" formerKeyx? "); 
    print (formerKey );
    formerKeyC(memoryi, oldMemoryi, k);
    formerSartKey ='X';
  }  
  // trigx
  if (formerKey=='x') {
    //   interPhase[memoryi]= metroPhase[memoryi];
    print (" formerKeyw? "); 
    print (formerKey );
    formerKeyCu$(memoryi, oldMemoryi, k);
    //  formerKeyCoriginal(memoryi, oldMemoryi, k);
    formerSartKey ='x';
  } 
  //   starterx
  if (formerSartKey =='x' && (formerKey=='e'  )  ) { //  formerstartKey =='v' && || formerKey=='X' || KeyCode== SHIFT
    if (circularMov==true || circularMov==false ) {//|| circularMov==false

      println ("STARTERxBIS DataToDueCircular ");
    

      if  ( 1>=1  ) { 
        if  (millis()>TimeUpstair+d) {
          //  TimeUpstair=millis();
          TimeUpstair=millis();
          key='x'; 
          keyReleased();  
          println ("  x circular Pressed automa? ");
          //   formerKey='+';
          formerSartKey='x';
        }
      }
    }
  }
  }
  
  // END STARTERCASE with formerKey
  //   starterX
  if (formerSartKey =='X' && (formerKey=='e'  )  ) { //  formerstartKey =='v' && || formerKey=='x' || KeyCode== SHIFT
    if (circularMov==true || circularMov==false ) {//|| circularMov==false

      println ("STARTERXBIS DataToDueCircular ");
      //     print (" DataToDueCircularVirtualPosition[oldMemoryi-1] " ) ;  println (DataToDueCircularVirtualPosition[oldMemoryi-1]); BUG x is ased on u$
      print (" DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
      println (DataToDueCircularVirtualPosition[oldMemoryi]);
      print (" 6400-DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
      println (6400 - DataToDueCircularVirtualPosition[oldMemoryi]);

      if  ( 1>=1  ) { 
        if  (millis()>TimeUpstair+d) {
          //  TimeUpstair=millis();
          TimeUpstair=millis();
          key='X'; 
          keyReleased();  
          println (" x  circular Pressed? ");
          //   formerKey='+';
          formerSartKey='X';
        }
      }
    }
  } //end starterX 
  //   starterw
  if (formerSartKey =='w'   )  { //  formerstartKey =='v' && || formerKey=='x' || KeyCode== SHIFT
    if (circularMov==true || circularMov==false ) {//|| circularMov==false
//  printDataOnScreen();
 //     pendularPatternLFO();

   
     //   if  (millis()>TimeUpstair+d) {
              if  (millis()>TimeUpstair) {
          //  TimeUpstair=millis();
          TimeUpstair=millis();
         key='w'; 
          keyReleased();  
           formerKeyCopposite(memoryi, oldMemoryi, k);
          println (" w  circular Pressed? ");
     
          formerSartKey='w';
        
      }
    }
  } //end starterX 



  // *****END of automatise Oscillator Moving with a former Key

  // arduinoPos();
  //metroEND
  if (circularMov==true || circularMov==false ) {
    //     print (" END ");          
    for (int i = 2; i < (12); i++) {// pendular from -800 to 800
      /*
              print (" itPhaseE "); print (i); print (" "); print (interPhase[i]); 
       print (" itPhaCiE "); print (i); print (" "); print (interPhaseCircular[i]);
       
       print (" metrPhaE "); print (i); print (" "); print (metroPhase[i]); 
       print (" meOlPhaE "); print (i); print (" "); print (metroOldPhase[i]);
       
       print (" ne.phasE "); print (i); print (" "); print (net.phase[i]); 
       print (" neOphasE "); print (i); print (" "); println (net.oldPhase[i]);
       */
    }
  } 
  //: noLoop();

  //   end of STARTERX function DELETED

  if (formerKey=='I') {
    formerKeyI();
  }  
  /*
    if (formerKey=='x') { // follow mode. What is w?
   formerx();
   //  key ='#';
   } 
   */
  if (formerKey=='V') { // like V and shift two frequencies and phases at the same time
    formerKeyV();
    //  key ='#';
     }
   }
  //************ arduinoPos(); // to control Pos of motor and Trigging note and computing pulsation
  // countPendularTrig ();
  frameStop(); 
  formerFormerKey= formerKey;

  if ( key!=':' ) {// formerKey!=':' ||  || key=='ç'
     if (  key<65535) { // if there is no SHIFT but the other key
 //   if (formerKeyMetro != 'J') { // if there is no SHIFT but the other key
      formerKey= key;   
      //     formerKeyCodeAzerty = keyCode;
      //       formerKeyCode = keyCode;
    //  }
    }
  }
  if ( keyCode != 0) {// formerKey!=':' ||  || key=='ç'
    //      formerKey= key;   
    formerKeyCodeAzerty = keyCode;
    formerKeyCode = keyCode;
  }
  print (" KEY  ");    
  print  (key); 
  print (" FORMERKEY "); 
  print (formerKey); 
  print (" formerFormerKey "); 
  print (formerFormerKey); 
  print (" FORMERSTARTKEY ");  
  print (formerSartKey);

  print (" KEY  ");    
  print (PApplet.parseChar(key)); 
  print (" FORMERKEY "); 
  print (PApplet.parseChar(formerKey)); 
  print (" formerFormerKey "); 
  print (PApplet.parseChar(formerFormerKey)); 
  print (" FORMERSTARTKEY ");  
  print (PApplet.parseChar(formerSartKey));
  print (" formerKeyMetro ");  
  println (PApplet.parseChar(formerKeyMetro));

  print (" KEYCODE  ");    
  print  (keyCode);   
  print (" char KEYCODE  ");    
  print  (PApplet.parseChar (keyCode));
  print (" former KEYCODE  ");    
  print  (formerKeyCode);   
  print ("char formerKeyCode  ");    
  println  (PApplet.parseChar (formerKeyCode)); 
  print (" former KEYCODEAZERTY  ");    
  print  (formerKeyCodeAzerty);   
  print ("char formerKeyCodeAZERTY  ");    
  println  (PApplet.parseChar (formerKeyCodeAzerty)); 

  if ( key==',') {
    //    formerKey= formerKey;
    //    formerFormerKey= formerFormerKey;
    //    formerKeyCodeAzerty =formerKeyCodeAzerty;
  }
  
  if ( formerKeyMetro == 'J') {
      
    //    formerKey= formerKey;
    //    formerFormerKey= formerFormerKey;
        formerKeyCodeAzerty =formerKeyMetro;
  }

  
  for (int i = 2; i < networkSize; i++) {
    phaseReturned[i]=net.phase[i];
  }
  // =============== =============== =============== =============== =============== =============== =============== END OF MAIN LOOP   
  // =============== =============== =============== =============== =============== =============== =============== END OF MAIN LOOP   
  // =============== =============== =============== =============== =============== =============== =============== END OF MAIN LOOP
  // =============== =============== =============== =============== =============== =============== =============== END OF MAIN LOOP
}

//trigRightTemp[i] = int [] TrigModPos { 
//if former





 public void BEAT_DETECT () {
  // end beatdetect
}

 public void manageCoupling() {
 
  if (orderParameter<=0.01f  ) { //  net.velocity[0]<0 && net.velocity[0]>-1.46c
    coupling= (-coupling);
    //  coupling = exp(abs(coupling));
    net.setCoupling(coupling);
  } else  if (orderParameter>=0.1f  ) {
    coupling = map ((PApplet.parseFloat (mouseX)/width*1), 0, 1, -10, 10 );
    net.setCoupling(coupling);
  } 
  print ("coupling_Managed");    
  println ( coupling);
} 

 public void  doSEVEN() {

  //  if (frequencyEnergy(k)>1.7 ) {
  if ((K>199 && H <200)&& S>150) {
    //   if ((H>199 && H <200)&& S>150){

    print (" doSEVEN()doSEVEN()doSEVEN()doSEVEN()doSEVEN()doSEVEN()doSEVEN()doSEVEN()doSEVEN()");

    //   key='M'; keyPressed();
    key='4'; 
    keyReleased(); // '6';
    // find something actualising or doing case 7 automatical when kick is upper than 1.7
  }
}
 public void devant_derriere() {
  //    if ( (net.phase[networkSize] && rev[networkSize])  > (net.phase[0] && rev[0])){//     (net.phase[0] >  (j[i]==0 && rev[i]<0))  { 

  if ( (net.phase[9]  > net.phase[0]) &&  ( rev[9]  > rev[0]+2)) {//     (net.phase[0] >  (j[i]==0 && rev[i]<0))  { 

    print (" net.phase[9] "); 
    print ( net.phase[9] );  
    print (" net.phase[0 "); 
    print ( net.phase[0] ); 
    key = '3'; 
    keyReleased();
  }

  if ( (net.phase[0]  > net.phase[9]) &&  ( rev[0]  > rev[9]+2)) {//     (net.phase[0] >  (j[i]==0 && rev[i]<0))  { 

    print (" net.phase[9] "); 
    print ( net.phase[9] );  
    print (" net.phase[0 "); 
    print ( net.phase[0] ); 
    //       key = 'O'; keyPressed ();   
    key = '4'; 
    keyReleased();
  }
}


 public void countRevs() { // ============================================= Ter NE PAS TOUCHER LE COMPTEUR ou Reduire l'espace avant et apres 0 pour eviter bug à grande vitesse

  onOFF=0;

  for (int i = 0; i < networkSize; i++) { 
//**    print (net.oldPhase[i]); print ("count rev ");   println (net.phase[i]); 
    // decrement caused by negative angular velocity
    // both positive angles || both negative angles || positive-to-negative angle
    //   if (//(net.oldPhase[i] < 0.25 * PI && net.phase[i] > 1.75 * PI) ||//
    if (
      ((net.oldPhase[i] < 0.25f *PI && net.oldPhase[i]>0)  && (net.phase[i] > -0.25f* PI && net.phase[i] <0))  || 
      (net.oldPhase[i] < -1.75f * PI && net.phase[i] > -0.25f * PI)// ||
      // (net.oldPhase[i] < 0.25 * PI && net.phase[i] > -0.25 * PI)
      ) {
      onOFF = 1;
      //    TrigmodPos[i]=0;
      rev[i]--;
      //      print (" revultion negative  "); println (revolution[i]=i+1);
      //   revolution[i]=i+1;
      revolution[i]=0; // trig 0 to sent 0 in Max4Live
  //**    memoryi=i;


      decompte[i] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
    } else { // if you do twice there is a funny bug
      //    decompte[i]  ++; 
      //   revolution[i]=0;
    }


    // increment caused by positive angular velocity
    // both positive angles || both negative angles || negative-to-positive angle

    if (
      ((net.oldPhase[i] > -0.25f *PI && net.oldPhase[i]<0)  && (net.phase[i] < 0.25f* PI && net.phase[i] >0))  || 
      (net.oldPhase[i] > 1.75f * PI && net.phase[i] < 0.25f*PI)
      ) {
      onOFF = 1;
      //   TrigmodPos[i]=0;
      rev[i]++;
      //   revolution[i]=i+1;
      revolution[i]=0;   // trig 0 to sent 0 in Max4Live
  //**    memoryi=i;
      decompte[i] = 0;  // RESET COUNTER AT 0
    } else {

      decompte[i]  ++; //START COUNTER when a REVOLUTION START OR FINISH

      revolution[i]=1;
    }
     if (  revolution[i]<1) {
  print (" revolution[i] "); print ( memoryi); print ("  "); println (revolution[memoryi]);
    }
  }
  
  /*
  if (

    (net.oldPhase[memoryi] < -1.75 * PI && net.phase[memoryi] >= -0.25*TWO_PI) || ( net.phase[memoryi]<=-TWO_PI+0.23  && net.phase[memoryi] >= -0.25*TWO_PI ) 
    ) {
    onOFF = 1;
    //   background (27,59,78);
    //    TrigmodPos[i]=0;
    rev[memoryi]--;

    // memoryi=i;


    decompte[memoryi] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
  }
 */
} 

 public void printSummary(int i) {
  /*
    print("oldphase "); print(i); print(" ");
   print(net.oldPhase[i]); print(" ");
   print("phase "); print(i); print(" ");
   print(net.phase[i]); print(" ");
   print("velocity"); print(i); print(" ");
   print(net.velocity[i]); print(" ");  
   print("frequency "); print(i); print(" "); 
   print(net.naturalFrequency[i]);
   print("OldFrequency "); print(i); print(" "); 
   println(OldFrequency[i]);
   */
}

 public void arduinoPos() { 
  
  
  

  if (formerKeyMetro == '>') {  // formerKeyMetro == '<' || 
    for (int i = 0; i < networkSize; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (rev[i]!=0  && (newPosF[i] >  0) ) { // number of revolution is even and rotation is clock wise   
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep))+ (rev[i]*numberOfStep);
      }

      if (rev[i]!=0  && (newPosF[i] <  0)) { // number of revolution is even and rotation is Counter clock wise          // pos[i]= int (map (newPosF[i], 0, -TWO_PI, 0,  numberOfStep))+ (rev[i]*numberOfStep);

        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0)) +(rev[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (rev[i]==0 && (newPosF[i] < 0) ) { //  number of revolution is 0 and rotation is counter clock wise 
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0));        
      }         
      if  (rev[i]==0 && (newPosF[i] > 0) ) {  //  number of revolution is 0 and rotation is clock wise     
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW rev=0 ");println (pos[i]);
      }
    }
  }

  //  else if (formerFormerKey=='Q') {
  for (int i = 0; i < networkSize; i++) {

    //rev[i]=rev[0];

    //*******************************  ASSIGN MOTOR WITH POSITION
    //   pos[i]= pos[i]-numberOfStep/4; // The positions 0 of my motors in real are shifted of - half_PI  

    if (rev[i]!=0  && (net.phase[i] >  0) ) { // number of revolution is even and rotation is clock wise   
      Pos[i]= PApplet.parseInt (map (net.phase[i], 0, TWO_PI, 0, numberOfStep));
    }

    //   if (rev[i]!=0  && (net.phase[i] <  0)) { // number of revolution is even and rotation is Counter clock wise   
    if (rev[i]!=0  && (net.phase[i] <  0)) { // number of revolution is even and rotation is Counter clock wise   

      Pos[i]= PApplet.parseInt (map (net.phase[i], 0, -TWO_PI, numberOfStep, 0));
    }

    if (rev[i]==0 && (net.phase[i] < 0) ) { //  number of revolution is 0 and rotation is counter clock wise 
      Pos[i]= PApplet.parseInt (map (net.phase[i], 0, -TWO_PI, numberOfStep, 0));        
      //    print ("pos "); print (i); print (" CCW rev=0");println (pos[i]);
    }         
    if  (rev[i]==0 && (net.phase[i] > 0) ) {  //  number of revolution is 0 and rotation is clock wise     
      Pos[i]= PApplet.parseInt (map (net.phase[i], 0, TWO_PI, 0, numberOfStep));         
    }
  }
  
  
  
  //  }  

  //=======================================================================

  // ATTENTION A ENVOYER LE MEME NOMBRE DE VAARIABLE QUE PEUT EN RECEVOIR l'ARDUINO. Here is 30 datas+1 data of COHESION 

  // TRIGGING 1 when THE COHESION is very Low   

  //  if (orderParameter>=0.999 ) {  //&& decompte[9]<=5// && revolution[9]==10 the first oscillator (in front the secreen) pass trough 0
  if (orderParameter<=0.001f) { 
    cohesionCounterLow++;

    if (cohesionCounterLow==1) { 
      //   background (50);
    } 

    if ( (cohesionCounterLow>=1 && cohesionCounterLow<=1) || (!(cohesionCounterLow>=2 && cohesionCounterLow<=2))|| (!(cohesionCounterLow>=1 && cohesionCounterLow<=4)))
    {
      orderCohesionLow= 1;  // Trig sound and back ground
      //    background (255);
    }
  } else if  ( orderParameter>0.001f ) { 
    cohesionCounterLow=0 ; // Reset cohesionCounterLow at 0

    orderCohesionLow= -1;
  } 

  if (orderParameter<=0.0011f ) { // && orderParameter>=0.099
    cohesionCounterHigh=0 ;
    orderCohesion= 0;
  } 

  if (orderParameter>=0.999f ) {  //&& decompte[9]<=5// && revolution[9]==10 the first oscillator (in front the secreen) pass trough 0
    cohesionCounterHigh++;
    if (cohesionCounterHigh==1) { 
      //   background (75);
    } 

    if ( (cohesionCounterHigh>=1 && cohesionCounterHigh<=1) || (!(cohesionCounterHigh>=2 && cohesionCounterHigh<=2)) || (!(cohesionCounterHigh>=1 && cohesionCounterHigh<=4)))
    {
      orderCohesion= 1;
    }
  } else if  ( orderParameter>=0.0011f  && orderParameter<=0.999f) { 
    cohesionCounterHigh=0 ; // RESET COUNTER AT 0
    orderCohesion= -1;
  } 

  LevelCohesionToSend= orderParameter;

  // ATTENTION A ENVOYER LE MEME NOMBRE DE VARAIABLE 
  //***********METTRE TOUT SUR LA MEME LIGNE
  String counterNoMarked = rev[5]+","+rev[4]+","+rev[3]+","+rev[2]+","+rev[1]+","+rev[0]+","; // rev[9]+","+rev[8]+","+rev[7]+","+rev[6]+","+
  // you have the number of revolution made by each oscillator
  String revolutionNoMarked = revolution[5]+","+revolution[4]+","+revolution[3]+","+revolution[2]+","+revolution[1]+","+revolution[0]+","; //revolution[9]+","+revolution[8]+","+revolution[7]+","+revolution[6]+","+

  // =============== MAP ACCORDING LFO, CIRCULAR, PENDULAR PHASE To ADAPT IT TO the stepper motor
  // ===============* CIRCULAR MODE TO TRIG DATA ACCORDING POSITION *
  if (formerKeyMetro == '£'  || formerKeyMetro == '*' || formerKeyMetro == 'J' || formerKeyMetro == 's' || formerKeyMetro == '@'  ) { //interPosition   || formerKeyMetro == 'c'
     if (   keyMode == " ableton " ) {
     for (int i = 0; i < networkSize; i++) { 
            net.phase[i] = newPosF[i];
    }
   }
     if (  keyMode == " addSignalOneAndTwo " ) {
     for (int i = 0; i < networkSize; i++) {  
        //    net.phase[i] = newPosF[i];
       //    net.phase[i] = newPosXaddSignal[i];
     }
    } 
    
       if (  overKeyMode == " null " ) {
     for (int i = 0; i < networkSize; i++) {  
        //    net.phase[i] = newPosF[i];
        //   net.phase[i] = newPosXaddSignal[i];
    }
   }
   
  if (formerKeyMetro == 's' && millis()<10000 ) { //put netphase 11 to phase 
  //j  net.phase[11]= PI+0.1; // do not forget 
  }
  if (formerKeyMetro == 's' && millis()>10000 ) { //put netphase 11 to phase
  
 //   key= 'j'; keyPressed (); // to start Live 
 
  }
    for (int i = 0; i < networkSize; i++) {
        VirtualPosition[i]= ActualVirtualPosition[i];   // when you change mode of movement, you add last position  DataToDueCircularVirtualPosition[i] +
      // =============== MAP PHASE To ADAPT IT TO the stepper motor    // =============== TRIG 0 when oscillator pass THROUG 0:  No effect on positions datas given to teensyport

      if (net.phase[i] >  0 ) {  
        CircularOldVirtualPosition[i]=CircularVirtualPosition[i]; 
        CircularVirtualPosition[i]= PApplet.parseInt (map (net.phase[i], 0, TWO_PI, 0, numberOfStep));
        Pos[i]= PApplet.parseInt (map (net.phase[i], 0, TWO_PI, 0, 127)); // to Oscsend
        
        

     if ((CircularVirtualPosition[i]>3199 && CircularOldVirtualPosition[i]<3200 && CircularOldVirtualPosition[i]>201  )
          || (CircularVirtualPosition[i]<3201 && CircularOldVirtualPosition[i]>3200 && CircularVirtualPosition[i]>201  )  ) {

       TrigmodPos[i]=0;     
       print (i); 
       print(" CIRCULAR PASS CLOCKWISE THROUG 0: ");
       println (  TrigmodPos[i]=0); 
       print (" virt ");  println (  VirtualPosition[i]); print (" Cirvirt "); print(  CircularVirtualPosition[i]); print (" CirOldvirt "); println (  CircularOldVirtualPosition[i]);
        } else  TrigmodPos[i]=1;
      } else {
        CircularOldVirtualPosition[i]=CircularVirtualPosition[i]; 
        CircularVirtualPosition[i]= PApplet.parseInt (map (net.phase[i], 0, -TWO_PI, numberOfStep, 0));  
        Pos[i]= PApplet.parseInt (map (net.phase[i], 0, -TWO_PI, 127, 0));  // to Oscsend  

    if ((CircularVirtualPosition[i]<3201 && CircularOldVirtualPosition[i]>3200 )   ) {
       TrigmodPos[i]=0;     
       print (i); 
       print(" CIRCULAR PASS CLOCKWISE THROUG 0: ");
       println (  TrigmodPos[i]=0); 
       print (" virt ");  println (  VirtualPosition[i]); print (" Cirvirt "); print(  CircularVirtualPosition[i]); print (" CirOldvirt "); println (  CircularOldVirtualPosition[i]);

        } else  TrigmodPos[i]=1;
      } 
      DataToDueCircularVirtualPosition[i]=CircularVirtualPosition[i];
      VirtualPosition[i]= CircularVirtualPosition[i]+ActualVirtualPosition[i]; 
      ActualVirtualPositionFromOtherMode[i]=VirtualPosition[i];
    }
    for (int i = 2; i < networkSize; i++) {   
      print(" Pos "); 
      print (i); 
      print(" "); 
      print (Pos[i]);
    }
     println(" "); 
  }

  //*************************************TRIG and  MAP PENDULAR PHASE  for TEENSY and !ç (to manage sound)

  if (formerKeyMetro == '$'|| formerKeyMetro == 'à') {

    for (int i = 0; i < networkSize; i++) {
      // VirtualPosition[i]= (int) map ( VirtualPosition[i], 1600, 4800, -800, 800); // mapped at the scale in Max 4 live
      PendularOldOldOldLeftVirtualPosition[i]=PendularOldOldLeftVirtualPosition[i];  
      PendularOldOldLeftVirtualPosition[i]=PendularOldLeftVirtualPosition[i];  
      PendularOldLeftVirtualPosition[i]=PendularLeftVirtualPosition[i];  
      modOldOldPos[i]=modOldPos[i]; 
      modOldPos[i]=modPos[i];    
      PendularOldVirtualPosition[i]=PendularVirtualPosition[i];

      PendularVirtualPosition[i]= PApplet.parseInt (map (metroPhase[i], PI, TWO_PI, 0, numberOfStep/2)); // better : Metronome pass throug position 0


      //   PendularVirtualPosition[i]= int (map (metroPhase[i], -0.5*PI, 1.5*TWO_PI, 0, numberOfStep/2)); // movement with more amplitude?
      PendularVirtualPosition[i]= (int) map ( PendularVirtualPosition[i], -4800, -1600, -800, 800); // mapped at the scale in Max 4 live
      Pos[i]= PApplet.parseInt (map (PendularVirtualPosition[i], -800, 800, 0, 127)); // to Oscsend 

      VirtualPosition[i]= PendularVirtualPosition[i]+ActualVirtualPosition[i]; 
      //  DataToDueCircularVirtualPosition[i]=VirtualPosition[i];
      DataToDueCircularVirtualPosition[i]=PendularVirtualPosition[i];//+VirtualPosition[i]
      //  dataToLive[i]=  map(DataToDueCircularVirtualPosition[i], 0, 6400, 0, 1);

      float rate = map(DataToDueCircularVirtualPosition[i], -800, 800, 0.80f, 1.20f);
      //  rate = 1; //rateSong
      rateControl.value.setLastValue(rate);

      //SET PRECISION OF MODULO
      // PendularLeftVirtualPosition[i]=int(1*(VirtualPosition[i])+800+1)/2%80;
      //***PendularLeftVirtualPosition[i]=VirtualPosition[i];

      //   modPos[i]=int((1*(VirtualPosition[i])+800+0)/2)%80; // si 0 à 80
      modPos[i]=PApplet.parseInt((1*(VirtualPosition[i])+800+0)/2)%800; // si 0 à 800
      //    print (i); print(" PENDULAR ");print (modOldOldPos[i]);  print(" PENDULAR "); print (modOldPos[i]);print(" PENDULAR "); println (  modPos[i]);
      //print (" modOldOldPos "); print ( modOldOldPos[i]); print (" modOldPos "); print ( modOldPos[i]); print (" modPos "); println( modPos[i]); 
      if   ((modOldOldPos[i]>modOldPos[i] && modOldPos[i] >modPos[i] && modOldOldPos[i]>modOldPos[i]) ) {
        trigTest=true;
        //  print ("trigTest "); print (i);  println (trigTest);
      } else {
        trigTest=false;
        // print ("trigTest "); print (i);  println (trigTest);
      }

      if (  trigTest==false //((modOldOldPos[i]>modOldPos[i] && modOldPos[i] >modPos[i] && modOldOldPos[i]>modOldPos[i]))

        && ((PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]>=700  && modOldPos[i]>=modPos[i]  &&  modOldOldPos[i]<=modPos[i] &&  modOldOldPos[i]>=680 &&  modOldOldPos[i]<=800)// && PendularLeftVirtualPosition[i]< PendularOldLeftVirtualPosition[i]  && PendularLeftVirtualPosition[i]<6
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]>=700  && modOldPos[i]>=modPos[i]  &&  modOldOldPos[i]>=modPos[i] &&  modOldOldPos[i]>=680 &&  modOldOldPos[i]<=800 )
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]<=modOldPos[i] &&  modOldOldPos[i]<=modPos[i] &&  modOldOldPos[i]>=500 &&  modOldOldPos[i]<=800)  // discrimination speed 8
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]<=modOldPos[i] &&  modOldOldPos[i]>=modPos[i] &&  modOldOldPos[i]>=600 &&  modOldOldPos[i]<=800)  // discrimination speed 8
        )) {

        println ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"); 
        print ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"); 
        print ("VirtualPosition: ") ; 
        print (i);  
        print (" =Pendularleft: ");  
        println  (PendularLeftVirtualPosition[i]);
        //   background (int ((i+1)*22), int ((i+1)*22),int ((i+1)*22) );

        print (i); 
        print(" OLDOLD PENDULAR ");
        print (modOldOldPos[i]);  
        print("OLD PENDULAR ");  
        print (modOldPos[i]);
        print(" Actual PENDULAR "); 
        println (  modPos[i]); 
        TrigmodPos[i]=0;
      } else { 
        TrigmodPos[i]=1;
      }
    }
  }
  if (formerKeyMetro == '$' && (formerSartKey == 'X' || formerSartKey == 'x' || formerSartKey == 'W' || formerSartKey == 'w')) {

    for (int i = 0; i < networkSize; i++) {
      // VirtualPosition[i]= (int) map ( VirtualPosition[i], 1600, 4800, -800, 800); // mapped at the scale in Max 4 live
      PendularOldOldOldLeftVirtualPosition[i]=PendularOldOldLeftVirtualPosition[i];  
      PendularOldOldLeftVirtualPosition[i]=PendularOldLeftVirtualPosition[i];  
      PendularOldLeftVirtualPosition[i]=PendularLeftVirtualPosition[i];  
      modOldOldPos[i]=modOldPos[i]; 
      modOldPos[i]=modPos[i];    
      PendularOldVirtualPosition[i]=PendularVirtualPosition[i];

      PendularVirtualPosition[i]= PApplet.parseInt (map (metroPhase[i], -HALF_PI, HALF_PI, -4800, -1600)); // better : Metronome pass throug position 0


      //   PendularVirtualPosition[i]= int (map (metroPhase[i], -0.5*PI, 1.5*TWO_PI, 0, numberOfStep/2)); // movement with more amplitude?
      PendularVirtualPosition[i]= (int) map ( PendularVirtualPosition[i], -4800, -1600, -800, 800); // mapped at the scale in Max 4 live
      Pos[i]= PApplet.parseInt (map (PendularVirtualPosition[i], -800, 800, 0, 127)); // to Oscsend 

      VirtualPosition[i]= PendularVirtualPosition[i]+ActualVirtualPosition[i]; 
      //  DataToDueCircularVirtualPosition[i]=VirtualPosition[i];
      DataToDueCircularVirtualPosition[i]=PendularVirtualPosition[i];
      //  dataToLive[i]=  map(DataToDueCircularVirtualPosition[i], 0, 6400, 0, 1);

      float rate = map(DataToDueCircularVirtualPosition[i], -800, 800, 0.80f, 1.20f);
      //  rate = 1; //rateSong
      rateControl.value.setLastValue(rate);

      //SET PRECISION OF MODULO
      // PendularLeftVirtualPosition[i]=int(1*(VirtualPosition[i])+800+1)/2%80;
      PendularLeftVirtualPosition[i]=VirtualPosition[i];

      //   modPos[i]=int((1*(VirtualPosition[i])+800+0)/2)%80; // si 0 à 80
      modPos[i]=PApplet.parseInt((1*(VirtualPosition[i])+800+0)/2)%800; // si 0 à 800
      //    print (i); print(" PENDULAR ");print (modOldOldPos[i]);  print(" PENDULAR "); print (modOldPos[i]);print(" PENDULAR "); println (  modPos[i]);
      //print (" modOldOldPos "); print ( modOldOldPos[i]); print (" modOldPos "); print ( modOldPos[i]); print (" modPos "); println( modPos[i]); 
      if   ((modOldOldPos[i]>modOldPos[i] && modOldPos[i] >modPos[i] && modOldOldPos[i]>modOldPos[i]) ) {
        trigTest=true;
        //  print ("trigTest "); print (i);  println (trigTest);
      } else {
        trigTest=false;
        // print ("trigTest "); print (i);  println (trigTest);
      }

      if (  trigTest==false //((modOldOldPos[i]>modOldPos[i] && modOldPos[i] >modPos[i] && modOldOldPos[i]>modOldPos[i]))

        && ((PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]>=700  && modOldPos[i]>=modPos[i]  &&  modOldOldPos[i]<=modPos[i] &&  modOldOldPos[i]>=680 &&  modOldOldPos[i]<=800)// && PendularLeftVirtualPosition[i]< PendularOldLeftVirtualPosition[i]  && PendularLeftVirtualPosition[i]<6
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]>=700  && modOldPos[i]>=modPos[i]  &&  modOldOldPos[i]>=modPos[i] &&  modOldOldPos[i]>=680 &&  modOldOldPos[i]<=800 )
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]<=modOldPos[i] &&  modOldOldPos[i]<=modPos[i] &&  modOldOldPos[i]>=500 &&  modOldOldPos[i]<=800)  // discrimination speed 8
        || ( PendularLeftVirtualPosition[i]<PendularOldLeftVirtualPosition[i] && modOldPos[i]>720  && modPos[i]<=modOldPos[i] &&  modOldOldPos[i]>=modPos[i] &&  modOldOldPos[i]>=600 &&  modOldOldPos[i]<=800)  // discrimination speed 8
        )) {

        println ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"); 
        print ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"); 
        print ("VirtualPosition: ") ; 
        print (i);  
        print (" =Pendularleft: ");  
        println  (PendularLeftVirtualPosition[i]);
        //   background (int ((i+1)*22), int ((i+1)*22),int ((i+1)*22) );

        print (i); 
        print(" OLDOLD PENDULAR ");
        print (modOldOldPos[i]);  
        print("OLD PENDULAR ");  
        print (modOldPos[i]);
        print(" Actual PENDULAR "); 
        println (  modPos[i]); 
        TrigmodPos[i]=0;
      } else { 
        TrigmodPos[i]=1;
      }
    }
  }
    //*********** COMPUTE ACCELERATION
  
           if (  overKeyMode == " null " || keyMode == " addSignalOneAndTwo " ) {
     for (int i = 0; i < networkSize; i++) {  
       //     net.phase[i] = newPosF[i];  // to compute acceelration
      //**     net.phase[i] = newPosXaddSignal[i];
      oldPhaseAcceleration[i] = phaseAcceleration[i];
      phaseAcceleration[i] = net.phase[i];
   
        oldVelocityBis[i] = velocityBis[i];
     //**   velocityBis[i] = (net.phase[i] - net.oldPhase[i]) / 1;
        velocityBis[i] = (phaseAcceleration[i] - oldPhaseAcceleration[i]) / 1;
   //   VelocityI[i]=velocity[i];
      // Update acceleration
        accelerationBis[i] = (velocityBis[i] - oldVelocityBis[i]) / 1;
        
        mapAcceleration[i]= constrain ((PApplet.parseInt (map (abs(accelerationBis[i] *100), -100, 100, 0, 127))), 0, 127); 
      
  //      print(" velocityBis "); print (i);  print (" ");  print(velocityBis[i]); print (" "); 
        
 //       print(" acc  "); print (i);  print (" "); print(accelerationBis[i]); print(" "); 
        
 //       print(" mapAcc  "); print (i);  print (" "); print(mapAcceleration[i]); println(" "); 
        
       }
      }  
      
     //*********** END COMPUTE ACCELERATION 
  

//  countRevs();  
  bpmAsPulsationFunction();
  printMidiNoteVelocity();
  //SUBZERO


  if (key=='l') {
    formerSartKey='l'; //trig  automatiseWithNote();
    formerKeyL();
  }
  if (key=='L') { //
    formerSartKey='L'; // trig setbpm automatically to 108
  }  

  if (formerSartKey=='l') {// || formerSartKey=='!'

  }

  String ACCELERATION = mapAcceleration[5]+","
    +mapAcceleration[4]+","+ mapAcceleration[3]+","+mapAcceleration[2]+","+ mapAcceleration[1]+","+mapAcceleration[0]+","; // mapAcceleration[9]+","+ mapAcceleration[8]+","+mapAcceleration[7]+","+ mapAcceleration[6]+","+

  String SPEED = speedi[5]+","+speedi[4]+","+speedi[3]+","+speedi[2]+","+speedi[1]+","+speedi[0]+","; // speedi[11]+","+speedi[10]+","+speedi[9]+","+ speedi[8]+","+speedi[7]+","+ speedi[6]+","+
  // DECOMPTE: You trig a 0 when oscillator reach to the position 0, and then you have an incrementation at each frame.

  if (rev[networkSize-1]%8==0 && decompte[networkSize-1]>=-0 && decompte[networkSize-1]<1) {// send a trig to change scene in Ableton live (if oscillator 11 makes 8 round an djust when it pass trought its position 0 -->trig next scene in Live)
    nextScene= 1;//
    println ("nextScenenextScenenextScenenextScenenextScene");
    println ("nextScenenextScenenextScenenextScenenextScene");
    println (nextScene);
  } else {
    nextScene= 0;
  }     
  //*******************

  if (formerKeyMetro == '$') {

    for (int i = 0; i < networkSize; i++) {

      // DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i]+800;
      DataToDueCircularVirtualPosition[i]= (int) map ( DataToDueCircularVirtualPosition[i], -800, 800, 1600, 4800)+ ActualVirtualPosition[i];  // mapped for 6400 step/round +800
      //  dataToLive[i]=(float)  map(DataToDueCircularVirtualPosition[i], 1600, 4800, 0f, 1f);
    }

    // DataToDueCircularVirtualPosition[2] =(int) map (DataToDueCircularVirtualPosition[2], 0, 6400, 0, int (6400/1));
  }  
  if (formerKeyMetro == '*') {

    for (int i = 0; i < networkSize-0; i++) {
      DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i];
      //   dataToLive[i]=(float) map(DataToDueCircularVirtualPosition[i], 0, 6400, 0f, 1f);
      DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i]+ ActualVirtualPosition[i];
    } 
    //  DataToDueCircularVirtualPosition[2]=(int) map (DataToDueCircularVirtualPosition[2], 0, 6400, 0, int (6400/1));
  }

  if (formerKeyMetro == 'J') {

    for (int i = 0; i < networkSize-0; i++) {
    //  net.oldPhase[i]=net.phase[i];
      DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i];
      //   dataToLive[i]=(float) map(DataToDueCircularVirtualPosition[i], 0, 6400, 0f, 1f);
      DataToDueCircularVirtualPosition[i]= DataToDueCircularVirtualPosition[i]+ ActualVirtualPosition[i];
    } 
    //  DataToDueCircularVirtualPosition[2]=(int) map (DataToDueCircularVirtualPosition[2], 0, 6400, 0, int (6400/1));
  }
  //24 data Jo solution

  // OSCsend  

  /*
    if (dataToLive[10]*10>5){
   dataToLive[10]=1;
   } 
   else  if (dataToLive[10]*10<=5){
   dataToLive[10]=0;
   }
   */
  oscSend();
 
//  printDataOnScreen();

  int TeensyJo=3; // trig Joe in Teensy
  int erasePosition=-1; //no
  String dataMarkedToTeensyJo  ="<" // BPM9   

  //  +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
   // +   DataToDueCircularVirtualPosition[6]+","+
    
    + DataToDueCircularVirtualPosition[5]+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","
    + DataToDueCircularVirtualPosition[1]+","+DataToDueCircularVirtualPosition[0]+","

    +  (speedDelta) +","+ 3 +","+TeensyJo+","+ erasePosition+"," 
    

    +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">"; //    cohesionCounterHigh // +orderCohesion+ ">";LevelCohesionToSend ","+ int (map ( LowLevelCohesionToSend, 0, 1, 0, 100))+ 

  // Trig a counter from 0 when cohesionCounterLow is Low +","+ Trig 1  when orderCohesion is High +","+ Map cohesion level


  if (rev[networkSize-1]%8==0 && decompte[networkSize-1]>=-0 && decompte[networkSize-1]<1) {// send a trig to change scene in Ableton live (if oscillator 11 makes 8 round an djust when it pass trought its position 0 -->trig next scene in Live)
    nextScene= 1;//
    println ("nextScenenextScenenextScenenextScenenextScene");
    println ("nextScenenextScenenextScenenextScenenextScene");
    println (nextScene);
  } else {
    nextScene= 0;
  }     
  //*******************
  if ((formerKey == 'o'|| formerKey == 'ç' ) && frameCount%1 == 0 ) {//&& circularMov== false

    //  println(frameCount + ": " +  " dataMarkedToTeensyJoSpecial" + ( dataMarkedToTeensyJo ));
    println(frameCount + ": " +  " JoDebug "  + ( JoDebug ));
    // teensyport.write(dataMarkedToTeensyJo); // Send data to Teensy. only the movement

    //  DueSerialNativeUSBport101.write(dataMarkedToDueBis ); // Send data to Arduino. 
    //      DueSerialNativeUSBport101.write(dataMarkedToDue36data);// teensy simulation
  }

  if ((formerKey != 'o' ) && frameCount%1 == 0 ) {//&& circularMov== false

    //   println(frameCount + ": " +  " dataMarkedToTeensyJo" + ( dataMarkedToTeensyJo ));
    //     teensyport.write(dataMarkedToTeensyJo); // Send data to Teensy. only the movement
  }



  // ================SPEED LIMIT
  // println(frameCount + ": " +  "SPEED" + ( SPEED ));
  if ( abs (speedi[networkSize-1]) > 950 || abs (speedi[0]) > 950) {
    //   key = 'h'; keyReleased();
    text("CAREFULL", width/2, height - 20);
  }

  //    print ("pendular      ");   println (pendular);  
  if (formerKeyMetro!='s') {
    if (formerKeyMetro!='J') {
      if (formerKeyMetro!='<') {
           if (formerKeyMetro!='B') {
              if (formerKeyMetro!='>') {
                 if (formerKeyMetro!='@') {
                     if (formerKeyMetro!='c') {
                       if (keyMode!= " addSignalOneAndTwo ") {
                         if (keyMode!= " methodAbleton ") {
                           if (keyMode!= " addSignalOneAndTwoBis ") {
                             if (keyMode!= " addSignalOneAndTwoTer ") {
                            
                                 if (keyMode!= " followDistribueAddLfoPattern ") {
                                   if (keyMode!= " samplingModeInternal ") {
                                    if (keyMode!= " addSignalOneAndTwoQuater ") {


        println(frameCount + ": " +  " dataMarkedToTeensyJoInMainLoop" + ( dataMarkedToTeensyJo ));
        //   DueSerialNativeUSBport101.write(dataMarkedToDue36data);// Send data to Arduino.
        teensyport.write(dataMarkedToTeensyJo); // Send data to Teensy. only the movement
         
         }
          }
           }
        }
        }
        }
         }
        }
         }
      }
     }
    }
   }
  }
  /*
  if (formerKeyMetro=='<') {
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

      +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
      +   DataToDueCircularVirtualPosition[6]+","+( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

      +  (speedDelta) +","+ driverOnOff +","+decompte[9]+","+decompte[8]+","+decompte[7]+","+decompte[6]+","+decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

      +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ int (map (LevelCohesionToSend, 0, 1, 0, 100))+">";    

    println(frameCount + ": " +  " dataMarkedToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
    //   DueSerialNativeUSBport101.write(dataMarkedToDue36data);// Send data to Arduino.
    teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
  }
  */
}

//****************************************************** 
//******************************************************  
 public void readOneLine() { // read data from recordBis()

  String[] current = split(lines[index], ':');
  frameCountRed = PApplet.parseInt (current[1]);
    print ("  frameCountRed ");  println (  frameCountRed);
 
  keyCode =  PApplet.parseInt (current[2]);
     print ("  keyCode ");  println ( PApplet.parseChar(keyCode) );
  couplingRed= PApplet.parseInt(current[3]);
  Movement= PApplet.parseInt(current[4]);
  keyModeRed= (current[5]);
  print ("  MovementRed ");  println (  Movement );
 // movement=  Movement/1000;
  if (++index == lines.length - 1) {
    exit();
  }
  nextFrame = PApplet.parseInt(split(lines[index], ':')[0]);
}   
 public void recordBis() {
  
if (frameCount>=0) { 
  if (formerFrame!=frameCount) {
  //  if (formerKey!=key  || formerKeyCode!=keyCode) {
   
 //       if (formerCoupling!=coupling) {
      //    if (formerAutomation1!=automation1) { 
       //     if (formerKeyMode!=keyMode) { 
            
    output.println(frameCount +  ":" + PApplet.parseInt (keyCode) + ":" + PApplet.parseInt (coupling*1000) + ":" + PApplet.parseInt (automation1*1000) + ":" + keyMode);
    //    } }  } }
   //   }
    }
  }
}

 public void recordTer() {
  
if (frameCount>=0) { 
  if (formerFrame!=frameCount) {
    if (formerKey!=key) {
      if (formerKeyCode!=keyCode) {
        if (formerCoupling!=coupling) {
          if (formerAutomation1!=automation1) { 
       //     if (formerKeyMode!=keyMode) { 
            
    output.println(frameCount + ":" + (int)key + ":" + (int)keyCode + ":" + PApplet.parseInt (coupling*1000) + ":" + PApplet.parseInt (automation1*1000) + ":" + keyMode);
        } }  } //}
      }
    }
  }
}

 public void bpmAsPulsationFunctionOscillator11 () {

  if (formerKeyMetro == '$' || formerKeyMetro == 'à') { 

    if (decompte[11]>=0 && decompte[11]<1 && isLooping()) {    
      println ("TEST OK");   // if oscillator 11 is at his position 0
      //    if (TrigmodPos[11]>=0 && TrigmodPos[11]<1 && isLooping()){    println ("TEST OK");   // if oscillator 11 is at his position 0
      if (!ready) {
        ready = true;
        prev_time = millis();
      } else {
        int curr_time = millis();

        avgTimer.nextValue(curr_time - prev_time - sketch_pause_interval);

        sketch_pause_interval = 0;

        println("'a' key pressed at " + curr_time);

        prev_time = curr_time;
      }
    }
  }

  if (formerKeyMetro == '£' || formerKeyMetro == '*') { 

    if (decompte[11]>=0 && decompte[11]<1 && isLooping()) {    
      println ("TEST OK");   // if oscillator 11 is at his position 0
      //  if (TrigmodPos[11]>=0 && TrigmodPos[11]<1 && isLooping()){    println ("TEST OK");   // if oscillator 11 is at his position 0

      if (!ready) {
        ready = true;
        prev_time = millis();
      } else {
        int curr_time = millis();

        avgTimer.nextValue(curr_time - prev_time - sketch_pause_interval);

        sketch_pause_interval = 0;

        println("'a' key pressed at " + curr_time);

        prev_time = curr_time;
      }
    }
  }
}

MovingAverage avgTimer = new MovingAverage(2);



/**
 
 * Use  a circular array to store generation step impl. times
 
 * and calculate a moving average.
 
 * 
 
 * Specify the number of values to include in the moving average when
 
 * using the constructor. 
 
 * 
 
 * The implementation time is O(1) i.e. the same whatever the number 
 
 * of values used it takes the same amount of time to calculate the
 
 * moving average.
 
 * 
 
 * @author Peter Lager 2021
 
 */

private class MovingAverage {

  private float[] data;

  private float total = 0, average = 0;

  private int idx = 0, n = 0;



  /**
   
   * For a moving average we must have at least remember the last 
   
   * two values.
   
   * @param size the size of the underlying array
   
   */

  public MovingAverage(int size) {

    data = new float[Math.max(2, size)];
  }



  // Include the next value in the moving average

  public float nextValue(float value) {

    total -= data[idx];

    data[idx] = value;

    total += value;

    idx = ++idx % data.length;

    if (n < data.length) n++;

    average = total / (float)n;

    return average;
  }



  public void reset() {

    for (int i = 0; i < data.length; i++)

      data[i] = 0;

    total = n = 0;
  }


  public float average() {

    return average;
  }
}
 public void frameratio() { 
  //**************************FRAME RATE    ***********CONTROL FRAME RATIO SPEED

  if ((key == ',')) {
    if (frameRatio>4 ) {// frameRatio !=0 || 
      frameRatio=frameRatio-5;  
      frameRate(frameRatio);
      text((frameRatio), -width/2, -height );
    } else {
      println ("CAREFULLLLLLLLLLLLLLLLLLLLLLLLLLL");
      frameRatio =0; 
      frameRate(frameRatio);
      text((frameRatio), -width/2, -height );
    }
  }

  if ((key == ';')) {

    //int frameRation

    frameRatio +=5;
    if ( frameRatio >=180) {
      frameRatio=60;
    }
    frameRate(frameRatio);
    text((frameRatio), -width/2, -height );
  }
  /*
   if (key == ':') {
   //  frameRatio=30;frameRate(frameRatio); // 30/5 = 6 frameRate ==> 124/5 = 24.8 BPM record. 124/3
   text((frameRatio), -width/2, -height ); 
   if (key == '='){
   frameRatio=30;frameRate(frameRatio);
   text((frameRatio), -width/2, -height ); 
   } 
   
   }
   */
  if (key == '=') {
    //  frameRatio=45;
    frameRatio=30;
    frameRate(frameRatio);
    text((frameRatio), -width/2, -height ); 
    //processingnodata
  } 



  //***********CONTROL FRAME RATIO SPEED
  if (key == '+') {
    frameRatio=120;
    frameRate(frameRatio);
    println ("MAXIMMMMMMMMMMUMMMMMMM");
    text((frameRatio), -width/2, -height );
  }
} 
 public void keyPressed() {
  
  setMovement(key, true);
  
 if (keyCode == ALT){ // .. in Keypressed
    moveKeys[8]=true;
   }
  
 
  if (key == '@'|| keyCode == ESC) {
    startStop=3;
    OscMessage myMessage15= new OscMessage("/startStop");
    myMessage15.add(startStop);
    oscP5.send(myMessage15, myRemoteLocation);
  }   

  frameratio();

  if ((key == '!'  ) ) {  
    text ("STOP MOVEMENT AND TIMER: and BPM ;) when restart slowly", 400, -400); //     // Toggle between sketch paused - running
    formerKey = '!'; // to prepare the next start. With the touch A you can trig play in live

    startStop= 3; 
    println ( startStop ); // = STOP
    //stopboolean= true;

    String dataMarkedToDue  ="<" 
     // + mapAcceleration[11]+","+ int  (bpmToSend)  +","+cohesionCounterHigh+","+ onOFF+","+nextScene+","
      + mapAcceleration[4]+","+ mapAcceleration[3]+","+mapAcceleration[2]+","+ mapAcceleration[1]+","+mapAcceleration[0]+"," 

     // +(VirtualPosition[11]) +","+VirtualPosition[2] +","+VirtualPosition[11] +","+VirtualPosition[0] +","+VirtualPosition[11] +","
    //  +int (phazi[11])+","+int (phazi[0])+","+int (phazi[11])+","+int (phazi[0])+","+int (phazi[11])+","

    //  +modPos[11]+","+modPos[10]+","+modPos[9]+","+modPos[8]+","+modPos[7]+","+modPos[6]+","+modPos[5]+","+modPos[4]+","+modPos[3]+","+modPos[2]+","+modPos[1]+","+modPos[0]+ "," // to manage 12 note

      +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+ ","+ startStop + ">"; 

    print ("dataStop: ");  
    println(frameCount + ": " +  " dataMarkedToDue" + ( dataMarkedToDue ));

    //      DueSerialNativeUSBport101.write(dataMarkedToDue ); 

    running = false;


    if (isLooping()) {

      pause_start_time = millis();

      noLoop();
    }
  } 
 // else if (keyCode == BACKSPACE) {
   else if (key == '!')  {
    /*
      running = true; // TRIG the TIMER
     int m = millis();
     lastMillis = m;
     
     sketch_pause_interval = millis() - pause_start_time;
     
     println("Paused at " + millis() + " for " + sketch_pause_interval + "ms");
     */
    noLoop();
    lastMillis=0;// restart period  oscillation number 11 to 0 ms 
    timeFrame=1;
    frameCount=1; // restart the begining of the program
  } 
  if (key == ':'||key == '=') {
    if (key == ':') {
      //    frameRatio=30;
      //    frameRate(frameRatio);
    }
    if (key == '=') {
      //    frameRatio=frameRatio+30;;
      //   frameRate(frameRatio);
    }

    running = true; // TRIG the TIMER
    int m = millis();
    lastMillis = m;

    sketch_pause_interval = millis() - pause_start_time;

    println("Paused at " + millis() + " for " + sketch_pause_interval + "ms");

    loop();
  }


  if (key == '-'  ) //&& song.isPlaying()
  {
  //  song.pause();
  }
  if (key == '_')
  {
    // simply call loop again to resume playing from where it was paused
    //  song.rewind();
  }
} 

 public void recordFrame() { 

  if (key == '@' || keyCode == ESC) {

    keyMode = " phasePattern ";
    key = '9'; // aligne les ballee
     for (int i = 0; i < networkSize; i++)  {
  // DataToDueCircularVirtualPosition[i]=0;
  
  }

    send24DatasToTeensy6motors (10,3,-3,1); // 1 means erase data in Teensy
    //  key='j'; keyReleased();
    output.println("1999999:0:0:0:0");
    output.println("2000000:0:0:0:0");
    output.flush();
    output.close();
    // startStop= 3;
    exit();
  }

  // if (frameCount !=formerFrame && (key != '!' && key != ':')  ){// do not record ! && :   // (frameCount !=formerFrame && key != '!' && key != ':') do not record ! only
  //if (frameCount !=formerFrame || key != key || key != '!' || key != ':' || key != ',' || key != ';'|| key != '=') {// do not record ! && :   // (frameCount !=formerFrame && key != '!' && key != ':') do not record ! only
  if (2>=1 ) { // frameCount !=formerFrame  && ( key != '!' || key != ':' || key != ',' || key != ';'|| key != '=')
    recordBis();
    formerFrame= frameCount;
  }
 if ( overKeyMode == " null " ) {
  
     text (" delayTimeFollowPhase11  ",  200,-1200);
     text ( delayTimeFollowPhase11  ,  200,-1100);
    
    text (" phaseShiftingFollowPhase11  ",  200,-1000);
    text ( phaseShiftingFollowPhase11  ,  200,-900);
    }
}

 public void keyReleased() {
    if (keyCode == ALT){
    moveKeys[8]=false;
   }

  
   recordFrame();
   
    if (formerKeyMetro == 'B')  {

      if (keyCode == CONTROL) {
         oscillatorChange++;
         oscillatorChange=oscillatorChange%12;
      if (oscillatorChange<=0) {
         oscillatorChange=2;
     }
         keyCode =SHIFT; // to trig once keyPressedLFO
  }

     if (keyCode == LEFT) {  
    println( " LEFT INCREASE decay offseft shiftFollowMov ")  ; 
 //   decayshiftFollowMov=decayshiftFollowMov+50;
    decayshiftFollowMov+=1;
    decayshiftFollowMov=decayshiftFollowMov%200;
  
    println ("d= timeOffsetRatio: "); 
    println ( decayshiftFollowMov);
    textSize (100);


    keyCode=SHIFT; // to trig once keyPressedLFO
  }

     if (keyCode == RIGHT) { 

    println( " right INCREASE decay offseft shiftFollowMov")  ; 
     decayshiftFollowMov=decayshiftFollowMov-1;  
      println ("d= timeOffsetRatio: "); 
    println ( decayshiftFollowMov);
    textSize (100);
    text (" decayshiftFollowMov  ",  200,200);
    text ( decayshiftFollowMov,  200,300);
   keyCode=SHIFT; // to trig once keyPressedLFO
  }
  
   if (keyCode == UP) {
     println(" lfoPhase phase shifting"); 
        println(" lfoPhase INCREASE phase shifting"); 
           println(" lfoPhase INCREASE phase shifting"); //
    phaseShiftingFollowPhase11= phaseShiftingFollowPhase11+QUARTER_PI/8;
    phaseShiftingFollowPhase11=phaseShiftingFollowPhase11%PI;
    phaseShiftingFollowLFO= phaseShiftingFollowLFO+QUARTER_PI/8;  
    phaseShiftingFollowLFO= phaseShiftingFollowLFO%PI;
    
 /*       
  if (phaseShiftingFollowPhase11>=8*QUARTER_PI/2) { 
      phaseShiftingFollowPhase11=-phaseShiftingFollowPhase11;
    } 
    */
   
    print ("phaseShiftingFollowPhase11 Ratio ");
    println (degrees (phaseShiftingFollowLFO));
    key= '#';
  }
  
    if (keyCode == DOWN) {
     println(" lfoPhase DECREASE phase shifting"); //
      println(" lfoPhase DECREASE phase shifting"); //
       println(" lfoPhase DECREASE phase shifting"); //
     phaseShiftingFollowLFO= 0;   
     phaseShiftingFollowPhase11= phaseShiftingFollowPhase11-QUARTER_PI/8;
 //   phaseShiftingFollowPhase11= phaseShiftingFollowPhase11%(8*QUARTER_PI/2);   
   /*     
  if (phaseShiftingFollowPhase11<=-8*QUARTER_PI/2) { 
      phaseShiftingFollowPhase11=-phaseShiftingFollowPhase11;
    }   
    print ("phaseShiftingFollowPhase11 Ratio ");
    println (degrees (phaseShiftingFollowPhase11));
    */
    keyCode = SHIFT;
  }
  
   
  
 } 
 
 

  if (formerKeyMetro == 'J' || overKeyMode == " null ")  {
    
  
    if (keyCode == LEFT) {
      
  //   float timeReleased= (millis()/5)%1000;
    println(" followSignal right INCREASE timeOffset ")  ; // Incremente together without changing phases
    delayTimeFollowPhase11=delayTimeFollowPhase11+1;
    delayTimeFollowPhase11=delayTimeFollowPhase11%65;  
    print ("delayTimeFollowPhase11: ");
    println (delayTimeFollowPhase11);
    if ( delayTimeFollowPhase11<=0 && delayTimeFollowPhase11>=0){
      trigLfo=0;
       }
     else if (delayTimeFollowPhase11>0){   trigLfo=1;   }
      keyCode = SHIFT;
  }
  
  if (keyCode == RIGHT) {
    println(" right INCREASE timeOffset ")  ; // Incremente together without changing phases
    delayTimeFollowPhase11=delayTimeFollowPhase11-1;
    if (delayTimeFollowPhase11<0) {
      delayTimeFollowPhase11=60;
       }
 //   delayTimeFollowPhase11=delayTimeFollowPhase11%61;
    print ("delayTimeFollowPhase11: ");
    println (delayTimeFollowPhase11);
      if ( delayTimeFollowPhase11<=0 && delayTimeFollowPhase11>=0){
      trigLfo=0;
       }
     else if (delayTimeFollowPhase11>0){ trigLfo=1;  }    // 
    keyCode = SHIFT;
  }

  if (keyCode == UP) {
     println(" left INCREASE phase shifting"); //
    phaseShiftingFollowPhase11= phaseShiftingFollowPhase11+QUARTER_PI/8;
    phaseShiftingFollowPhase11= phaseShiftingFollowPhase11%(8*QUARTER_PI/2);   
        
  if (phaseShiftingFollowPhase11>=8*QUARTER_PI/2) { 
      phaseShiftingFollowPhase11=-phaseShiftingFollowPhase11;
    }   
    print ("phaseShiftingFollowPhase11 Ratio ");
    println (degrees (phaseShiftingFollowPhase11));
    keyCode = SHIFT;
  }
  
    if (keyCode == DOWN) {
     println(" left INCREASE phase shifting"); //
    phaseShiftingFollowPhase11= phaseShiftingFollowPhase11-QUARTER_PI/8;
    phaseShiftingFollowPhase11= phaseShiftingFollowPhase11%(8*QUARTER_PI/2);   
        
  if (phaseShiftingFollowPhase11<=-8*QUARTER_PI/2) { 
      phaseShiftingFollowPhase11=-phaseShiftingFollowPhase11;
    }   
    print ("phaseShiftingFollowPhase11 Ratio ");
    println (degrees (phaseShiftingFollowPhase11));
    keyCode = SHIFT;
  }
  
  
  
  } 
  // Choose TimeSpace of Sampling with Sculdy Sampling Method


  // ADJUST DATA TO CONTROL MOTOR with TEENSYJO

  if (key == '?'&& millis()>=millisRatio+1000  ) { //&& frameCount%10==0
    speedDelta-= 1;
    if ( speedDelta<=2) {
      speedDelta=1;
    }
    print(speedDelta);  
    println ("slow down acceleration in Teensy Duino == PCTer0");
    millisRatio=millis();
  }

  if (key == '.' && millis()>=millisRatio+1000 ) { //&& frameCount%10==0 && frameCount <=3999

    speedDelta+= 1;  // decompte is always positive, here it is the signal to control acceleration in Teensy Duino
    if ( speedDelta>=20) {
      speedDelta=16;
    }
    print(speedDelta);  
    println ("up acceleration in Teensy Duino == PCTer0");
    millisRatio=millis();
  }
  
  if (key == ')') {
    // song.play();
    /*
    float rate = map(mouseX, 0, width, 0.5f, 1f);
     rate = 1; //rateSong
     rateControl.value.setLastValue(rate);
     */
    filePlayer.loop();
  }

  if ( (key == '°') )
  {
    filePlayer.pause();
  }       
  if (key == 'J') { 
    formerKeyMetro = key;
    print ("KEY LFO MODE "); 
    print ("FormerkeyMetro"); 
    print (PApplet.parseChar(formerKeyMetro));
    print ("key"); 
    println (PApplet.parseChar(key));
  }

/*
  if (key == '<') { 
    formerKeyMetro = key;
    print ("KEY CIRCULAR FOLLOW MODE "); 
    print ("FormerkeyMetro"); 
    print (char(formerKeyMetro));
    print ("key"); 
    println (char(key));
  }
*/
  if (key == '£' || key == '*') {//|| key == '£') {
    for (int i = 0; i < networkSize; i++) {
      rev[i]=0;// set revolution of all oscillator to 0  at the beginning if circular way

      formerKeyMetro = key;
      print ("KEY  CICULAR "); 
      print ("FormerkeyMetro: "); 
      print (PApplet.parseChar(formerKeyMetro));
      print ("Actualkey"); 
      println (PApplet.parseChar(key));
    }
  }  
  // ***********************************************************************************************  
  // ***********************************************************************************************  
  //********************* TRY PENDULAR PATTERN
  if (key == 'à' ) {//|| key == '£') {
    //   formerKeyMetro = key;
    print ("KEY PENDULAR OTHER PATTERN "); 
    print ("FormerkeyMetro"); 
    print (PApplet.parseChar(formerKeyMetro));
    print ("key"); 
    println (PApplet.parseChar(key));
    //      pendularOtherPattern ();
  }
  if (key == '$' ) {//|| key == '£') {
    formerKeyMetro = key;
    print ("KEY PENDULAR "); 
    print ("FormerkeyMetro"); 
    print (PApplet.parseChar(formerKeyMetro));
    print ("key"); 
    println (PApplet.parseChar(key));
  }

  if (formerKeyMetro == 'à') {  
    println ("Frequencie adatped to PENDULAR way WITH OTHER PATTERN trigged with à");
    //  pendularOtherPattern ();
  }
  if (formerKeyMetro == '$') {  
    println ("Frequencies adatped to PENDULAR way trigged with $");
    phasePattern();
  } 

  //*********************************************CIRCULAR

  if (formerKeyMetro == '£' ) {    
    println ("Frequencies adatped to circular way");

    circularWay();
    // MAKE A SORT OF FOLLOW MODE
  } 
  if ( formerKeyMetro == '*' || formerKeyMetro == '<') {   // formerKeyMetro == 'J'  
    println ("Frequencies adatped to ÒTHER circular way");

    //  circularOTHERWay();
    //  circularPENDULARWay();
    phasePattern(); //same as $
    // MAKE A SORT OF FOLLOW MODE
  }
}

 public void bpmAsPulsationFunction () {
  // MIDDLE if ((PendularOldLeftVirtualPosition[i]+800 <= 800 && PendularLeftVirtualPosition[i]+800 >=800) ||
  //     (PendularOldLeftVirtualPosition[i]+800 >= 800 && PendularLeftVirtualPosition[i]+800 <=800)) {

     if ( revolution[networkSize-1]>=0 && revolution[networkSize-1]<1){    println ("TEST OK");   //revolution[11]>=0 && revolution[11]<1 &&// in pendular way, revolution trig 0 on the right and rev trig 0 on left side
 // if (TrigmodPos[0]>=0 && TrigmodPos[0]<1 ||  revolution[0]>=0 && revolution[0]<1) {    
    println ("TEST OK");   // if oscillator 11 is at his position 0. 0 mean on the right
    if (!ready) {
      ready = true;
      prev_time = millis();
    } else if (TrigmodPos[0]>0 ||  revolution[0]>0 ) {
      int curr_time = millis();
      pulsation = avgTimer.nextValue(curr_time - prev_time);
      prev_time = curr_time;
      println("Average time between two pulsation = " + pulsation + "ms");
    }
  }
}

 public void bpmAsfrequencyfunction () { 
  for (int i = 0; i < networkSize; i++) {
    //  bpmFrequency[i]= net.naturalFrequency[i]*60/4.608*4; // frequencey=1 ==> 1 round in 4.68 sec // *4 is to give an good beat scale
    bpmFrequency[i]= net.naturalFrequency[i]*54.54f;
  }          
  if (abs (bpmFrequency[networkSize-1])>= abs (bpmFrequency[0])) {
    bpmToSend= abs(bpmFrequency[networkSize-1]);
  } else  bpmToSend= abs(bpmFrequency[0]);

  print (" bpmToSend");    
  print (" "); 
  print (bpmToSend); 
  println (" ");
}

 public void SoundmouseMoved()
{

  //      rez= constrain( map( orderParameter, 0, 1, -1, 1), 0, 1 );  
  //       rez= abs (constrain( map( orderParameter, 0, 1, -1, 1), -1, 1 ));

  //   volumei[0]= abs (speedi[0])*vol; // when vol = -1 && speed (0, 10)--> vol decrease.

  //    volumei[0]= abs (-speedi[0])*vol; // when vol = -1 && speed (0, 10)--> vol decrease.

  // volume to go from -50 to 0


  for (int i = 0; i < networkSize; i++) {

    speedi[i]=  (map ((net.velocity[i]*10000), -1000, 1000, -1, 1));
    //         print ("speedi[i "); print (i); print (" "); print  ( speedi[i]); // with this map until case 4 we go from -60 to 60
    //   speedi[i]= map ( (phazi[i]), 0, 14000, -1, 1); // Chnager d'echelle
    //     print ("velocity9 "); print (i);  print (" "); print ( net.velocity[i]); print (" ");  
    print ("speedi "); 
    print (i);  
    print (" "); 
    print ( speedi[i]);         


    volumei[i]= map ((speedi[i]), -1, 35, -50, 6); // 35 is the speed max.
    //       print ("volumei "); print (i); print (" "); print ( volumei[i]);  
    //**************************************************************   SET     VOLUME   WITH SPEED     
    /*
           out0.setGain(volumei[0]);
     out1.setGain(volumei[1]);
     out2.setGain(volumei[2]);
     out3.setGain(volumei[3]);
     out4.setGain(volumei[4]);
     out5.setGain(volumei[5]);
     out6.setGain(volumei[6]);
     out7.setGain(volumei[7]);
     out8.setGain(volumei[8]);
     out9.setGain(volumei[9]);
     
     */
  }

  float RealVelocity9 =   net.velocity[9]/20*2.4f; // round*s-1
  float RealVelocity0 =   net.velocity[0]/20*2.4f; // round*s-1

  float   bPM_Boundary9 = map (  RealVelocity9, 0, 0.5f, 0, 120);// Half a round is the tempo.
  float   bPM_Boundary0 = map (  RealVelocity0, 0, 0.5f, 0, 120);// Half a round is the tempo.

  if (bPM_Boundary9 >= bPM_Boundary0) { 
    bPM9= abs(bPM_Boundary9);
  } else  bPM9= abs(bPM_Boundary0);

  print ("velocityReel9 ");    
  print (" "); 
  print ( RealVelocity9); 
  println (" ");  

  print ("BPM9  ");    
  print (" "); 
  print ( bPM9); 
  println (" ");  

  //     constrainedBPM = int (map (bPM9, 0, 400, 20, 200));

  constrainedBPM = PApplet.parseInt (bPM9);

  print ("constrainedBPM");    
  print (" "); 
  print ( constrainedBPM); 
  println (" ");  




  for (int i = 0; i < networkSize; i++) {

    volumei[i]=-50;
  }
  println ();
}

 public void devant_derriereAutre() {
  if ( (net.phase[9]  > net.phase[0]) &&  ( rev[9]  > rev[0]+1)) {//     (net.phase[0] >  (j[i]==0 && rev[i]<0))  { 

    print (" net.phase[9] "); 
    print ( net.phase[9] );  
    print (" net.phase[0 "); 
    print ( net.phase[0] ); 
    key = 'O'; 
    keyPressed ();
  }

  if ( (net.phase[0]  > net.phase[9]) &&  ( rev[0]  > rev[9]+1)) {//     (net.phase[0] >  (j[i]==0 && rev[i]<0))  { 

    print (" net.phase[9] "); 
    print ( net.phase[9] );  
    print (" net.phase[0 "); 
    print ( net.phase[0] ); 
    key = '3'; 
    keyReleased ();
  }
}

 public void SHOW_DATA () {

  // float orderParameter = net.getOrderParameter();
  orderParameter = net.getOrderParameter();

  stroke(100);
  fill(100);


  // float ordometer=  net.orderParameter;  //float ordometer=  orderParameter;
  String ordometer = String.format("Order: %.2f", orderParameter);
  text(ordometer, -width*1.5f, 0);

  String couplingFormat = String.format("Coupling: %.2f", coupling);
  text(couplingFormat, -width*-1, 0);


  float ordoMapped= map (orderParameter, 0, 1, 1, 0);



  float orderToexpOpp= 1- exp(-ordoMapped); // ( 0 to 0.632)
  text (orderToexpOpp, -width*1.5f, -100);

  //******* THIS ONE (opposed and exponentionalised)?
  float orderToexpOppNormalised = map ( orderToexpOpp, (1-exp(-1)), 0, 1, 0); //( 0 to 1)
  text ( orderToexpOppNormalised, -width*1.5f, -200);

  int orderToexpOppNormalisedLive = PApplet.parseInt (map ( orderToexpOpp, (1-exp(-1)), 0, 127, 0)); //( 0 to 1)
  text ( orderToexpOppNormalisedLive, -width*1.5f, -300);



  float orderToexp= 1- exp(-orderParameter); //(0 to 0.632***
  text (orderToexp, -width*1.5f, 100);


  float orderToexpMapped = map (orderToexp, 0, (1-exp(-1)), 0, 1);
  text (orderToexpMapped, -width*1.5f, 200);

  //******* THIS SECOND ONE    
  float orderToexpMappedBis = map (orderToexp, 0, (1-exp(-1)), 1, 0); // map order from "orderexponnentionnalised scale 0 to 0.640" to linear 1 to 0 
  text (orderToexpMappedBis, -width*1.5f, 300);  

  orderToexpMappedOpposedLive =PApplet.parseInt  (map (orderToexpMappedBis, 0, 1, 0, 127)); // map "order exp and linearised from 0 to 127 to use it in Ableton
  text (orderToexpMappedOpposedLive, -width*1, -300); // BEST MAPPING

  int  orderParameterLiveSimple  =PApplet.parseInt  (map (orderParameter, 0, 1, 127, 0));
  text (orderParameterLiveSimple, -width*0.5f, -300);


  // ********************    
  //    mapAcceleration[i]= constrain ((int (map (abs(net.acceleration[i] *100), 0, 1000, 0, 255))), 0, 255); 

  text (map (mapAcceleration[0], 0, 255, 0, 127), -width*2, -1000); 
  text (map (mapAcceleration[9], 0, 255, 0, 127), -width*0, -1000); 


  float normalizeAcc0 = map ( mapAcceleration[0], 0, 255, 0, 1); 

  float acc0Toexp= 1- exp(-normalizeAcc0);
  text (acc0Toexp, -width*1.5f, -700); 

  float acc0ToexpMappedBis = map (acc0Toexp, 0, (1-exp(-1)), 0, 1); // map acceleration0 from "orderexponnentionnalised scale 0 to 0.640" to linear 1 to 0 
  text (acc0ToexpMappedBis, -width*1, -700);  

  acc0ToexpMappedBisLive =PApplet.parseInt (map ( acc0ToexpMappedBis, 0, 1, 0, 127));
  text (acc0ToexpMappedBisLive, -width*1, -1000); // BEST MAPPING

  float normalizeAcc9 = map ( mapAcceleration[9], 0, 255, 0, 1);
  float acc9Toexp= 1- exp(-normalizeAcc9);

  float acc9ToexpMappedBis = map (acc9Toexp, 0, (1-exp(-1)), 0, 1);
  text (acc9ToexpMappedBis, -width*-0.5f, -700);  

  acc9ToexpMappedBisLive=PApplet.parseInt (map (acc9ToexpMappedBis, 0, 1, 0, 127)); // it stay no too long between 0 and 60, more 60 to 127
  text (acc9ToexpMappedBisLive, -width*-1, -1000); // BEST MAPPING

  print ("acc0 & acc9 exp "); 
  print (acc9ToexpMappedBisLive); 
  print (" ");  
  println (acc9ToexpMappedBisLive);

  /* 
   float orderToexpOpposed= 1- exp(-ordoMapped);
   text (orderToexpOpposed,  -width*1.5, 200);
   */
}

 public void record() {

  // to STOP record touch @

  if (key == '@') {
    output.flush();
    output.close();
    exit();
  }// else { 
  //   else if (((formerCoupling != coupling) && frameCount %2==0 )|| ((formerCoupling == coupling) && frameCount %2==1)) { // tester l'ancien couple 
  // 
  //      else if (frameCount !=formerFrame){

  if (((((coupling <0 && formerCoupling <0) && coupling < formerCoupling-0.1f) || ((coupling >0 && formerCoupling>0) && coupling>formerCoupling+0.1f )) || 
    (((coupling >0 && formerCoupling >0) && coupling < formerCoupling-0.1f) || ((coupling <0 && formerCoupling<0) && coupling>formerCoupling+0.1f ))) 

    //  
    //&& (frameCount !=formerFrame )

    // ||  ((formerKey < Key))

    //||(formerKeyCode == int (keyCode)))))


    )
  {

    output.println(frameCount + ":" + (int)key + ":" + (int)keyCode + ":" + PApplet.parseInt (coupling*1000));
  }
}

 public void pendularPatternLFO(){ // trigged with J
    println( "pendularPatternLFO right DECREASE phase shifting  witch formerStartKey ")  ; // Incremente together without changing phases   

       
 //   if ((formerSartKey == 'X' || formerSartKey == 'x' || formerSartKey == 'W' || formerSartKey == 'w' || formerKeyMetro  == 'J')) {
       if (keyCode == RIGHT) { 
        k=k-QUARTER_PI/8;
     
   /*  
     if (k<=-8*QUARTER_PI/2) { 
         k = 8*QUARTER_PI;
      }
   */   
  
    }
//  }
  if (keyCode == LEFT) { 
//    println(" pendularPatternLFO left INCREASE phase shifting"); // Incremente together without changing phases  
    if ((formerSartKey == 'X' || formerSartKey == 'x' || formerSartKey == 'W' || formerSartKey == 'w' || formerKeyMetro == 'J')) {
      k= k+QUARTER_PI/8;
      k= k%(8*QUARTER_PI/8);
    }
    if (k>=9*QUARTER_PI/8) { 
   //   k=-k;
    }    
   
  } 

  if (keyCode == DOWN) { 
    println("pendularPatternLFO UP by 2 and change way of LFO2 "); //   TAB -
    for (int i = 2; i < 3; i++) { 
      LFO[i]= map (LFO[i], 0, 1, 0, TWO_PI);
      /*
         if (LFO[i]>=0 && LFO[i]<=1 ) {  
       LFO[i]= map (LFO[i], 0, 1, 0, TWO_PI);
       }
       if (LFO[i]<=1 && LFO[i]>=0) {  
       LFO[i]= map (LFO[i], 1, 1, 0, -TWO_PI);     
       }
       */
    } 
    d=d-25;
    d=d%525;
    keyCode =SHIFT; // to trig only once
  } 
  if (keyCode == UP) { 
    d=d+25;
    d=d%525;
    println("pendularPatternLFO UP by 2 and change way of LFO2 "); //   TAB -
    for (int i = 2; i < 3; i++) { 
      //   LFO[i]= automation3;
      LFO[i]= map (LFO[i], 0, 1, 0, PI);
      printSummary(i);
    }
     keyCode =SHIFT; // to trig only once
  }

  if (keyCode == CONTROL) { 
    println("pendularPatternLFO INCREASE phases with special modulo   "); //P$ 
    //else if (key == 'π') { println("INCREASE phases with special modulo   "); //P$ 
    //  LFO[2]= automation3;
    for (int i = 0; i < networkSize; i++) {

      LFO[i]+= (HALF_PI/(networkSize-2))*(1*(networkSize-1-i)); //
      LFO[i] = LFO[i]%(TWO_PI/1);

      net.phase[i]=  LFO[i]%(TWO_PI/1);

      interPhase[i]= LFO[i]%(TWO_PI/1);
      printSummary(i);  
      keyCode =SHIFT; // to trig only once
    }
  }
  
   keyCode = SHIFT; // to trig only once
   print ("k= shiftingPhaseRatio ");println (k);
   
      text ( " k "+ (k*360) + " delay " + d, -width+800, - height+400);

}

 public void abletonPattern()
{
    for (int i = 0; i < (networkSize); i++) { 
    {
     oscillator[i]= map (oscillator[i], 0,1, 0, TWO_PI);  //************************************ SET LAST FREQUENCIES as OLD FREQUENCIES
     net.phase[i]= oscillator[i];
    }
  }
  
  /*
 if (formerKey == 'A') { //A$  Shift frequencies one by one. 
    float speeed    = map ((float (mouseY)/width*1.0), 0, 1, -1, 1); 
    speeed=1;
    for (int i = 0; i < networkSize; i++) {
      net.naturalFrequency[i]=OldFrequency[i]; 
      printSummary(i);
    }
    memoryi=11;
//    net.naturalFrequency[memoryi]= speeed;//4.68/2; // 124 bpm
    net.phase[memoryi]= speeed*oscillator[11];//4.68/2; // 124 bpm
  }

  if (formerKey == 'a') { //A$  Shift frequencies one by one. 
    float speeed    = map ((float (mouseY)/width*1.0), 0, 1, -1, 1); 
    for (int i = 0; i < networkSize; i++) {    
      net.naturalFrequency[i]=OldFrequency[i]; 
      printSummary(i);
    }
    memoryi=2;
   net.phase[memoryi]= speeed*oscillator[memoryi];    //4.68/2; // 124 bpm
  }
*/

 }

 public void circularWay () {
  //************************************ DONT TOUCH  //************************************ RESET OLD FREQUENCIES 
  
  ///******************************============================================================SHIFT SEVERAL OSCILLATOR AT THE SAME TIME

  if (key == 'i') { 
    print("  Shift frequencies one by one, or 5 by five ");
    // net.shiftPhases(5);   
    net.shiftPhases(1);
  }

  if (key == 'u') { //ucircular  Shift frequencies one by one. 
    //  net.shiftPhases(2); 
    net.shiftPhases(-1);
  } 

  if (key == 'I') { //  Shift frequencies one by one, or 5 by five
    // net.shiftPhases(5);   
    net.shiftPhases(1);
  }

  if (key == 'U') { //  Shift frequencies one by one. 
    //  net.shiftPhases(2); 
    net.shiftPhases(-1);
  } 


  // key ='#';  
} 

 public void circularOTHERWay() { 
  print ("circularOTHERWay based ");
  //  pendularPattern ();
 
} 

 public void circularPENDULARWay() { 
  print ("circularPENDULARWay based ");
  phasePattern();
  //    pendularOtherPattern ();
}  



 public void formerx () {
  float k = 0.25f;
  print ("char formerFormerKey x?  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==true ) {
    for (int i = 0; i < (networkSize-1); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= CircularVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]= CircularOldVirtualPosition[i+1];
      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularVirtualPosition[i]);
    }
  } 
  for (int i = 0; i < networkSize-1; i++) {
    //  net.phase[i]=net.phase[11];

    print ("f: "); 
    println (f);

    net.phase[i]=(net.phase[11]+abstractPhase[i])%(TWO_PI/1);
    // net.phase[i] += (i+1)*0.05;
    net.phase[i]=  net.phase[i]%(TWO_PI);

    //    printSummary(i);


    print ("fmemory: "); 
    println (fmemory);

    //  key='#';
  }
  if (fmemory==k) {

    fmemory=0;
  }
} 

// Mexican-Hat spatial coupling
 public void initializeCoupling(float[][] Coupling, float sigma) {
  float[][] distance = distanceMatrix();
  for (int i = 0; i < networkSizeGraphic; i++) {
    for (int j = 0; j < networkSizeGraphic; j++) {
      float d = pow(distance[i][j] / sigma, 2);
      float c = (1 / (PI * pow(sigma, 4))) * (1 - 0.5f * d) * exp(-0.5f * d);
      Coupling[i][j] = c;
    }
  }
}

// Calculate the distance between oscillators
 public float[][] distanceMatrix() {
  float[][] distance = new float[networkSizeGraphic][networkSizeGraphic];
  for (int i = 0; i < networkSizeGraphic; i++) {
    int i1 = i % numCols;
    int j1 = PApplet.parseInt(floor(i / numCols));
    for (int j = 0; j < networkSizeGraphic; j++) {
      int i2 = j % numCols;
      int j2 = PApplet.parseInt(floor(j / numCols));
      distance[i][j] = dist(i1, j1, i2, j2);
    }
  }

  return distance;
}

// Set initial phases randomly
 public void initializePhase(float[] phase) {
  for (int i = 0; i < numRows; i++) {
    for (int j = 0; j < numCols; j++) {
      int index = i * numCols + j;
      phase[index] =  (QUARTER_PI*i);//FREQ ;//
    }
  }
}

// Set natural frequencies to the same random value
 public void initializeNaturalFrequency(float[] naturalFrequency, float freq) {
  for (int i = 0; i < numRows; i++) {
    for (int j = 0; j < numCols; j++) {
      int index = i * numCols + j;
      naturalFrequency[index] = freq;
    }
  }
} 

 public void printDataOnScreen() { 
   noStroke();
//**   /*
  text(formerFormerKey, -300, height +300); 
  text(formerKeyCodeAzerty, -100, height + 300);
  text(PApplet.parseChar (key), 100, height + 300);
  text(PApplet.parseChar (keyCode), 200, height +300)  ; 
  
    for (int i = 0; i < networkSize; i++) {
      
        text ("trig", -1200, height-500 - 75*i);
        text (TrigmodPos[i], -1000, height-500 - 75*i);
    
    }
  
  text ("mem", -800, height +300+100);
  text (memoryi, -600, height +300+100);
  if (TrigmodPos[networkSize-1]==0) {
   // counter11++;
    counter[networkSize-1]++;
  }  
  if (TrigmodPos[0]==0) {
    counter[0]++;
  } 
  text ( counter[networkSize-1], -600, height +300); 
  text ( counter[networkSize-1], -800, height +300); 
  text ("old", -1200, height +300+100);
  text (oldMemoryi, -1000, height +300+100);
  text ("mem", -800, height +300+100);
  text (memoryi, -600, height +300+100);
  text ("Ratio", -400, height +300+100);
  text (speedDelta, -200, height +300+100);
  text ("block", 0, height +300+100);
  text (oscillatorBlocked, 200, height +300+100);
  String Kratio = nf (k, 0, 1);
  text ("K phi", 0, height +300+200);
  text (Kratio, 200, height +300+200);
  text ("Fratio", 400, height +300+100);
  text (frameRatio, 600, height +300+100);
  text ("D btw case", 600, height +300+200);
  text (d, 1000, height +300+200);
//** */ 
  text ("FrameOffsetPhase11", -1000, height +400+200);
  text (delayTimeFollowPhase11, -200, height +400+200);
  text ("SpacephaseOffset11", 400,  height +400+200);
  text (degrees (phaseShiftingFollowPhase11), 1200, height +400+200);
  text ("measure ", -1000, height +800+200);
//  text (measure , -200, height +800+200);

  text ("Rec ", 800, height +300+0);
  text (measureRecordStart, 1000, height +300+0);
  
  text ("Llast ", 1200, height +300+0);
  text (lastLastSec, 1400, height +300+0);
  text ("last ", 1600, height +300+0);
  text (lastSec, 1800, height +300+0);
  text ("act ", 2000, height +300+0);
  text (actualSec, 2200, height +300+0);
  
  

  /// text (formerFrame, 700, height +300+100);
  text (frameCount, 1000, height +300+100);

  text(coupling, 400, height +300);
  text (frameCount, width/8, -height-200);
  String ONE_DEC = nf (timeFrame, 0, 1); 
  text(ONE_DEC, width/2+100, -height-200);
  String PULSATION = nf (pulsation, 0, 2); 
  text ("W", -width-800, -height -200);
  text (PULSATION, -width-550, -height -200);


  String BPM_PULSATION = nf (1000/pulsation*60, 0, 0); // transform time elapsed betwween two pulsation in BPM
  text ("BPM-W", -width-200, -height );
  text (BPM_PULSATION, -width+200, -height );

  String BPM = nf (bpmToSend, 0, 2); 
  text ("BPM", -width-200, -height -200);
  text (BPM, -width+100, -height-200);
 
  //********
  textSize (50);
  
    text ("BOTT F0", -width-900, height -100);
   text ("XXXX F9", -width-900, height -820);
   text ("FRON F11", -width-900, height -964);
   
  textSize (75);

  for (int i = 0; i < networkSize; i++) {
    if ( factorWay[i]==false) {
      FactorWay[i]=-1;
    } else  FactorWay[i]=1; 
    String FW= nf (FactorWay[i], 0, 0);
    text(FW, -width-800, height -20 - (i+1)*80);
  }

  textSize (75);

  for (int i = 0; i < networkSize; i++) {
    if ( clockWay[i]==false) {
      ClockWay[i]=-1;
    } else  ClockWay[i]=1;     
    String CW = nf (ClockWay[i], 0, 0); 
    text((CW), -width-700, height -20 - (i+1)*80);
  }
/*
  if ( oldClockWay[memoryi]==false) {
    oldC = -1;
  } else 

  oldC = 1;

  String oldClock = nf (oldC, 0, 3); 
  int k = 12;

  text((oldClock), -width-700, height -20 - (k+1)*80);
*/
  /* 
   textSize (50);
   for (int i = 0; i < networkSize; i++) {
   
   String REV = nf (rev[i], 0, 0); 
   //  text(  (net.naturalFrequency[i]), -width-200, height -20 - (i+1)*80); 
   text((REV), -width-700, height -20 - (i+1)*80);
   }
   */
   
 //************** REMETRRE
 
  textSize (50);
  for (int i = 0; i < networkSize; i++) {
    String TWO_DEC = nf (net.naturalFrequency[i], 0, 2); 
    //  text(  (net.naturalFrequency[i]), -width-200, height -20 - (i+1)*80); 
    text((TWO_DEC), -width-400, height -20 - (i+1)*80);
  }  
  textSize (50);

  for (int i = 0; i < 1; i++) {  // metroPhaseOnScreen

    String om = nf (metroPhase[oldMemoryi]-  metroPhase[memoryi], 0, 3); 
    //  text(  (net.naturalFrequency[i]), -width-200, height -20 - (i+1)*80); 
    text(("om " ), -width-300, height -20 - (i+1)*80);
    text((om), -width-200, height -20 - (i+1)*80);
  }

  for (int i = 1; i < 2; i++) {  // metroPhaseOnScreen

    String om = nf (metroPhase[networkSize-1]-  metroPhase[networkSize-1-1], 0, 3); 
    text(("10 "), -width-300, height -20 - (i+1)*80);
    text((om), -width-200, height -20 - (i+1)*80);
  }

  String inter = nf (interPhase[memoryi], 0, 3); 
  int j = networkSize;
  text(("i" ), -width-300, height -20 - (j+1)*80);
  text((inter), -width-200, height -20 - (j+1)*80);

  for (int i = 2; i < networkSize; i++) {  // metroPhaseOnScreen

    String m = nf (metroPhase[i], 0, 3); 
    text(("m" ), -width-300, height -20 - (i+1)*80);
    text((m), -width-200, height -20 - (i+1)*80);
  }

  textSize (50);

  String interCircular = nf (interPhaseCircular[memoryi], 0, 3); 
  int l = networkSize;
  text(("iC" ), -width-100, height -20 - (j+1)*80);
  text((interCircular), -width-0, height -20 - (j+1)*80);

  for (int i = 0; i < networkSize; i++) {  // netPhaseOnScreen

    String n = nf (net.phase[i], 0, 3); 
    text(("n" ), -width-100, height -20 - (i+1)*80);
    text((n), -width-0, height -20 - (i+1)*80);
  }

  for (int i = 2; i < networkSize; i++) {  // metroPhaseOnScreen

    String interPhaseM = nf (interFrequency[i], 0, 3); 
    text(("iF" ), -width+100, height -20 - (i+1)*80);
    text((interPhaseM), -width+200, height -20 - (i+1)*80);
  }
  
}


 public void formerW() {
   print  (" ACTUAL POSITION ");  print  (" ACTUAL POSITION ");  print  (" ACTUAL POSITION ");
    print  (" ACTUAL POSITION ");
    
  println  ("wwwwwwwwwwwwwwww");
  for (int i = 0; i < networkSize; i++) {    
    ActualVirtualPosition[i]+=0;  
    /*
        ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
     ActualVirtualPosition[i]=ActualVirtualPosition[i]%numberOfStep;
     ActualVirtualPosition[i]+=ActualVirtualPosition[i];
     */
    //*****

    //***  ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;// less conventional than numberOfStep/6*i
    //**   ActualVirtualPosition[i]+=ActualVirtualPosition[i]%numberOfStep;
    //**  ActualVirtualPosition[i]=ActualVirtualPosition[i]%numberOfStep*5;

    //    ActualVirtualPosition[i]=+3200;
    ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
    //VirtualPosition[i]= VirtualPosition[i]+(1600); 

    key='#';
    //formerKey='#';
  }
}
//********  OSCRECEIVE
//RECEIVE OSC AUTOMATION with port 2346 or 2349 and 2350 and analyse OSC messages
 public void oscEvent(OscMessage theMsg) {
  if (theMsg.checkAddrPattern("/LFO1")==true) {
    automationLFO[0] = theMsg.get(0).floatValue();
  }

  if (theMsg.checkAddrPattern("/LFOdecay")==true) {
    automationLFO[1] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/LFO2")==true) {
    automationLFO[2] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/LFO3")==true) {
    automationLFO[3] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/LFO4")==true) {
    automationLFO[4] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/LFO5")==true) {
    automationLFO[5] = theMsg.get(0).floatValue();
  }  
/*
  if (theMsg.checkAddrPattern("/LFO6")==true) {
    automationLFO[6] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/LFO7")==true) {
    automationLFO[7] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/LFO8")==true) {
    automationLFO[8] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/LFO9")==true) {
    automationLFO[9] = theMsg.get(0).floatValue();
  }
  
*/  
  


  if (theMsg.checkAddrPattern("/oscillator2")==true) {
    oscillator[2] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/oscillator3")==true) {
    oscillator[3] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/oscillator4")==true) {
    oscillator[4] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/oscillator5")==true) {
    oscillator[5] = theMsg.get(0).floatValue();
  }  
/*
  if (theMsg.checkAddrPattern("/oscillator6")==true) {
    oscillator[6] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/oscillator7")==true) {
    oscillator[7] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/oscillator8")==true) {
    oscillator[8] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/oscillator9")==true) {
    oscillator[9] = theMsg.get(0).floatValue();
  }
  
      if (theMsg.checkAddrPattern("/oscillator10")==true) {
    oscillator[10] = theMsg.get(0).floatValue();
  }

  if (theMsg.checkAddrPattern("/oscillator11")==true) {
    oscillator[11] = theMsg.get(0).floatValue();
  } 
  
  */
  


  if (theMsg.checkAddrPattern("/madTempoShaper")==true) {
    formerAutomation1=automation1;
    automation1 = theMsg.get(0).floatValue();
    for (int i = 0; i < networkSize; i++) {   
      //   net.phase[i]= map (automation2, 0, 1, -PI, PI );
    }
  }
  if (theMsg.checkAddrPattern("/speedTempo")==true) {
    automation2 = theMsg.get(0).floatValue();
    //  LFOX=automation2;
  }
  if (theMsg.checkAddrPattern("/followMadTrack1bis")==true) {
    automation3 = theMsg.get(0).floatValue();
    //  LFOY=automation3;
  }  

  if (theMsg.checkAddrPattern("/measureGood")==true) {
    automation4 = theMsg.get(0).floatValue();

  }  

  if (theMsg.checkAddrPattern("/beatPrecised")==true) {
    automation5 = theMsg.get(0).floatValue();
  
  }  

  if (theMsg.checkAddrPattern("/lfo1")==true) {
    automation6 = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/lfo2")==true) {
    automation7 = theMsg.get(0).floatValue();
  } 
  
    if (theMsg.checkAddrPattern("/lfo3")==true) {
    automation8 = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/LPF")==true) {
    automation9 = theMsg.get(0).floatValue();
  } 
  
   //***** ableton[i]
  

  if (theMsg.checkAddrPattern("/ableton0")==true) {
    ableton[0] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/ableton1")==true) {
    ableton[1] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/ableton2")==true) {
    ableton[2] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/ableton3")==true) {
    ableton[3] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/ableton4")==true) {
    ableton[4] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/ableton5")==true) {
    ableton[5] = theMsg.get(0).floatValue();
  } 
/*
  if (theMsg.checkAddrPattern("/ableton6")==true) {
    ableton[6] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/ableton7")==true) {
    ableton[7] = theMsg.get(0).floatValue();
  }
  
  if (theMsg.checkAddrPattern("/ableton8")==true) {
    ableton[8] = theMsg.get(0).floatValue();
  }

  if (theMsg.checkAddrPattern("/ableton9")==true) {
    ableton[9] = theMsg.get(0).floatValue();
  } 
  */
  
  

  if (theMsg.checkAddrPattern("/signal0")==true) {
    signal[0] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/signal1")==true) {
    signal[1] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/signal2")==true) {
    signal[2] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/signal3")==true) {
    signal[3] = theMsg.get(0).floatValue();
  }  

  if (theMsg.checkAddrPattern("/signal4")==true) {
    signal[4] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/signal5")==true) {
    signal[5] = theMsg.get(0).floatValue();
  } 
/*
  if (theMsg.checkAddrPattern("/signal6")==true) {
    signal[6] = theMsg.get(0).floatValue();
  } 

  if (theMsg.checkAddrPattern("/signal7")==true) {
    signal[7] = theMsg.get(0).floatValue();
  }
  
    if (theMsg.checkAddrPattern("/signal8")==true) {
    signal[8] = theMsg.get(0).floatValue();
  }

  if (theMsg.checkAddrPattern("/signal9")==true) {
    signal[9] = theMsg.get(0).floatValue();
  } 
  */

  //***  MIDI NOTE

  if (theMsg.checkAddrPattern("/Velocity1")==true) {
    velocity1 = theMsg.get(0).intValue();
    ver_move1 = map(velocity1, 0, 127, 0, 60);
  }

  if (theMsg.checkAddrPattern("/Velocity2")==true) {
    velocity2 = theMsg.get(0).intValue();
    ver_move2 = map(velocity2, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Velocity3")==true) {
    velocity3 = theMsg.get(0).intValue();
    ver_move3 = map(velocity3, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Velocity4")==true) {
    velocity4 = theMsg.get(0).intValue();
    ver_move4 = map(velocity4, 0, 127, 0, 60);
  }

  if (theMsg.checkAddrPattern("/Velocity5")==true) {
    velocity5 = theMsg.get(0).intValue();
    ver_move5 = map(velocity5, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Velocity6")==true) {
    velocity6 = theMsg.get(0).intValue();
    ver_move6 = map(velocity6, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Velocity7")==true) {
    velocity7 = theMsg.get(0).intValue();
    ver_move7 = map(velocity7, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Velocity8")==true) {
    velocity8 = theMsg.get(0).intValue();
    ver_move8 = map(velocity8, 0, 127, 0, 60);
  }  

  if (theMsg.checkAddrPattern("/Note1")==true) {
    note1 = theMsg.get(0).intValue();
    duration1 = map(sq(note1), 1, sq(127), 0.05f, 0.5f);
  }

  if (theMsg.checkAddrPattern("/Note2")==true) {
    note2 = theMsg.get(0).intValue();
    duration2 = map(sq(note2), 1, sq(127), 0.05f, 0.5f);
  } 

  if (theMsg.checkAddrPattern("/Note3")==true) {
    note3 = theMsg.get(0).intValue();
    duration3 = map(sq(note3), 1, sq(127), 0.05f, 0.5f);
  }

  if (theMsg.checkAddrPattern("/Note4")==true) {
    note4 = theMsg.get(0).intValue();
    duration4 = map(sq(note4), 1, sq(127), 0.05f, 0.5f);
  } 

  if (theMsg.checkAddrPattern("/Note5")==true) {
    note5 = theMsg.get(0).intValue();
    duration5 = map(sq(note5), 1, sq(127), 0.05f, 0.5f);
  }

  if (theMsg.checkAddrPattern("/Note6")==true) {
    note6 = theMsg.get(0).intValue();
    duration6 = map(sq(note6), 1, sq(127), 0.05f, 0.5f);
  } 

  if (theMsg.checkAddrPattern("/Note7")==true) {
    note7 = theMsg.get(0).intValue();
    duration7 = map(sq(note7), 1, sq(127), 0.05f, 0.5f);
  }

  if (theMsg.checkAddrPattern("/Note8")==true) {
    note8 = theMsg.get(0).intValue();
    duration8 = map(sq(note8), 1, sq(127), 0.05f, 0.5f);
  }
}




/*float log10 (int x) {
 return (log(x) / log(10));
 }*/

class B_String {
  float osc_points, p11, p21, p31, p41, shade;

  B_String(float a1, float b1, float c1, float d1, float i, int colour) {
    noFill();
    //fill(250, 0, 0, 55);
    stroke(200, colour, 0);
    bezier(a1, i, b1, i, c1, i, d1, i);
    osc_points = i;
    p11 = a1;
    p21 = b1;
    p31 = c1;
    p41 = d1;
    shade = colour;
    //fill(0, 0, 0);
  }

   public void display(float velocity) { 
    noFill();
    stroke(200, shade, 0);
    /*
    bezier(p11, osc_points, p21, osc_points+velocity, p31, osc_points+velocity, p41, osc_points);
    bezier(p11, osc_points, p21, osc_points+0.8*velocity, p31, osc_points+0.8*velocity, p41, osc_points);
    bezier(p11, osc_points, p21, osc_points+0.6*velocity, p31, osc_points+0.6*velocity, p41, osc_points);
    bezier(p11, osc_points, p21, osc_points+0.4*velocity, p31, osc_points+0.4*velocity, p41, osc_points);
    bezier(p11, osc_points, p21, osc_points+0.2*velocity, p31, osc_points+0.2*velocity, p41, osc_points);
    bezier(p11, osc_points, p21, osc_points, p31, osc_points, p41, osc_points);
    */
  }
} 

 public void printMidiNoteVelocity() {

  if  (note1>0) {

    print ("note "); 
    print (1); 
    print (" "); 
    print (note1);
    print ("note "); 
    print (2); 
    print (" "); 
    print (note2);
    print ("note "); 
    print (3); 
    print (" "); 
    print (note3);
    print ("note "); 
    print (4); 
    print (" "); 
    print (note4);
    print ("note "); 
    print (5); 
    print (" "); 
    print (note5);
    print ("note "); 
    print (6); 
    print (" "); 
    print (note6);
    print ("note "); 
    print (7); 
    print (" "); 
    println (note7);
  } else {
    //   println (" ");
  }

  if  (velocity1>0) {

    print ("velo "); 
    print (1); 
    print (" "); 
    print (velocity1);
    print ("velo "); 
    print (2); 
    print (" "); 
    print (velocity2);
    print ("velo "); 
    print (3); 
    print (" "); 
    print (velocity3);
    print ("velo "); 
    print (4); 
    print (" "); 
    print (velocity4);
    print ("velo"); 
    print (5); 
    print (" "); 
    println (velocity5);
    print ("velo"); 
    print (6); 
    print (" "); 
    print (velocity6);
    print ("velo"); 
    print (7); 
    print (" "); 
    println (velocity7);
  }

  //  print ("measure "); println (measure);

  //  if  (1!=0) {
  if  (velocity1>0) {
    rotate (PI/2);
    //  String NOTE1= nf (note1, 0, 0); // transform time elapsed betwween two pulsation in BPM
    text (measure, (-width+1350), -height );  
    text ("1", (-width-150), -height );
    text (note1, -width-50+50, -height );
    text ("2", (-width+50+50), -height );
    text (note2, -width+150+50, -height );   
    text ("3", (-width+250+50), -height );
    text (note3, -width+350+50, -height );
    text ("4", (-width+450+50), -height);
    text (note4, -width+550+50, -height );
    text ("5", (-width+650+50), -height);
    text (note5, -width+750+50, -height );
    text ("6", (-width+850+50), -height);
    text (note6, -width+950+50, -height );
    text ("7", (-width+1050+50), -height);
    text (note7, -width+1150+50, -height );

    text (velocity1, -width-50+50, -height+100 );
    text (velocity2, -width+150+50, -height+100 );   
    text (velocity3, -width+350+50, -height+100 );
    text (velocity4, -width+550+50, -height+100 );
    text (velocity5, -width+750+50, -height+100 );
    text (velocity6, -width+950+50, -height+100 );   
    text (velocity7, -width+1150+50, -height+100 );
  } else {
    rotate (PI/2);
    note1=note2=note3=note4=note5=note6=note7=note8=0;
    velocity1=velocity2=velocity3=velocity4=velocity5=velocity6=velocity7=velocity8=0;

    text (measure, (-width+1350), -height );  
    text ("1", (-width-150), -height );
    text (note1, -width-50+50, -height );
    text ("2", (-width+50+50), -height );
    text (note2, -width+150+50, -height );   
    text ("3", (-width+250+50), -height );
    text (note3, -width+350+50, -height );
    text ("4", (-width+450+50), -height);
    text (note4, -width+550+50, -height );
    text ("5", (-width+650+50), -height);
    text (note5, -width+750+50, -height );
    text ("6", (-width+850+50), -height);
    text (note6, -width+950+50, -height );
    text ("7", (-width+1050+50), -height);
    text (note7, -width+1150+50, -height );

    text (velocity1, -width-50+50, -height+100 );
    text (velocity2, -width+150+50, -height+100 );   
    text (velocity3, -width+350+50, -height+100 );
    text (velocity4, -width+550+50, -height+100 );
    text (velocity5, -width+750+50, -height+100 );
    text (velocity6, -width+950+50, -height+100 );   
    text (velocity7, -width+1150+50, -height+100 );
    //println (" ");
  }
}

 public void trigBeatWithMeasure()
 {
 //   beatTrigged=false;
 //   beatPrecisedTrigged=false; 
   if (formerMeasure!=measure) {
    //   background (127, 50, 50);
    beatTrigged=true;
    
    
    

    //    autmationWithMeasureAndNote++;

    beatOnMeasure=(measure%4)+1;
    print("  ******** "); 
    print("  ******** "); 
    print("  ******** "); 
    print("  ******** "); 
    print("  ******** "); 
    println(measure);
    formerFrameBeat=frameCount;
    //    if (formerBeatPrecised
 }
 
 else beatTrigged=false;
 
      if (formerBeatPrecised!=beatPrecised) {   
    //     background (127, 50, 50);
    beatPrecisedTrigged=true;
    print("  ******** "); 
    print("  ******** "); 
    print(" automation1*100 ");  println( automation1*100 );
    print("  ******** "); 
    print("  ******** "); 
    print("  beatPrecised "); 
    println(beatPrecisedTrigged);
  }
  
  else  beatPrecisedTrigged=false; 

  
  
   
} 

 public void autmationWithMeasureAndNote() {
 // if (formerSartKey!=L){
  autoNote1VelInf64();
 //  }

  if (measure<5 ) {
    //  speedDelta=15;
    speedDelta=4; 
    autoNote2();
  } 
  if (measure>=5 && measure<=5 && beatTrigged==true) {
    speedDelta=4 ;
    //   autoNote2();
  } 
  if ( measure<=2 ) {

    key='$';
    keyReleased();
  }
  if ( measure<=5 ) {
    // d=0;
    oscillatorBlocked=6;
//    d=100;
  }
  if ( measure>=6 && measure<=7 ) {
    d=200;
  }

  if ( measure<8 && beatTrigged==true) {
    //   key='?'; // slow acceleration
    //     keyReleased();
  } 


  if  (measure>=24 && measure<=38 ) {// measure>=41 && measure<=42
    //    autoNote2(); mis dans la vers FIVE
    //     key='Y';keyReleased();
    //     key='Y';keyReleased();
  }

  if  (measure>=61 && measure<=61 && beatTrigged==true  ) {

    key='o';
    keyReleased();
  }
  if  (measure>=66 && measure<67 ) {

    //   key='e';keyReleased();// shift phase mod   PI/3
  }
  if  (measure>=71 && measure<78 ) {

    autoNote2();
  }

  if  (measure>=40 && measure<41 && beatTrigged==true ) {//77  //&& beatTrigged==true
    //    key='o';
    //    keyReleased();
    key=9;
    keyReleased();
    key=CONTROL;
    keyReleased();
    oscillatorBlocked=10;
    speedDelta=4;
  }
  if  (measure>=43 && measure<44 && beatPrecised>=4 && beatPrecisedTrigged==true ) {//77  //&& beatTrigged==true
    //    key='9';
    //    keyReleased();
    key='o';
    keyReleased();
  } 
  if  (measure>=45 && measure<46 && beatPrecised>=4 && beatPrecisedTrigged==true ) {//77  //&& beatTrigged==true
    //    key='9';
    //    keyReleased();
    key='o';
    keyReleased();
  }   

  if  (measure>=47 && measure<48 && beatPrecised>=4 && beatPrecisedTrigged==true ) {//77  //&& beatTrigged==true

    key='o';
    keyReleased();
  }

  if  (measure>=50 && measure<51 && beatPrecised>=4 && beatPrecisedTrigged==true ) {//77  //&& beatTrigged==true

    key='o';
    keyReleased();
  }

  if ((( measure>40 && measure<58) && (millis()>formerEvent[74]+1000+d)) &&
    ((note1>73 && note1<75 && velocity1>=1 && velocity1<=64)|| (note2>73 && note2<75 && velocity2>=1 && velocity2<=64)|| (note3>73 && note3<75 && velocity3>=1 && velocity3<=64) ||
    (note4>73 && note4<75 && velocity4>=1 && velocity4<=64)|| (note5>73 && note5<75 && velocity5>=1 && velocity5<=64)|| (note6>73 && note6<75 && velocity6>=1 && velocity6<=64)
    )) {
    //  key='u'; //u=117 
    //   key='d'; //u=117 
    //     key='9'; //TROUVE AUTRE CHOSE QUE l'ALIGNEMENT   pas cool à 60
    key='t'; //TROUVE AUTRE CHOSE QUE l'ALIGNEMENT   pas cool à 60
    keyReleased();
    formerEvent[74]=millis();
  }

  if  (measure>=53 && measure<54 && beatTrigged==true) {
    //    oscillatorBlocked=10;
    //  key='ç';
    //  keyReleased();
    //      key='2';keyReleased();// frequencies equal
    //  key='l';
    //  keyReleased();
    //  formerSartKey='l'; //automatise movement with note
  }

  if (measure>=76 && measure<77 && beatTrigged==true) {//77  //&& beatTrigged==true
  }


  if  (measure>=77 && measure<78 && beatTrigged==true  ) {//77  //&& beatTrigged==true
  }

  if  (measure>=77 && measure<78 && beatTrigged==true ) { //
  }

  if  (measure>=78 && measure<=78 && beatTrigged==true) {
    key='A'; 
    keyReleased();
    key='o'; 
    keyReleased();

    key='*';
    keyReleased();

    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();

    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();

    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='T';
    keyReleased();
    key='t';
    keyReleased();
    keyCode=CONTROL;
    keyReleased();
    speedDelta=12;

    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();


    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
    key='Y';
    keyReleased();
  //    key='Y';keyReleased();
    //   key='Y';keyReleased();
  }
  if  (measure>=79 && measure<=79 && beatTrigged==true) {
    speedDelta= 11;
//    key='Y';
  //  keyReleased();
  //  key='y';
//    keyReleased();
  }

  if  (measure>=79+1 && measure<=79+1 && beatTrigged==true) {
    speedDelta= 8;
  }  
  if  (measure>=79+1 && measure<=200 ) {//129
    autoNote2();
  }
  if  (measure>=79+2 && measure<=79+2 && beatTrigged==true) {
    speedDelta= 4;
  }
  if  (measure>=79+3 && measure<=79+3 && beatTrigged==true) {
    speedDelta= 4;
  }
  
  if  (measure>=79+4 && measure<=79+4 && beatTrigged==true) {
    speedDelta= 2;
  }

  if  (measure>=84 && measure<=92 && beatTrigged==true) {

    //   key='y';keyReleased();
  }
   if ( measure>=106 && measure<=106 && beatTrigged==true) {
       speedDelta= 2;
  //     key='e'; keyReleased();
    
  } 
  if ( measure>=107 && measure<=107 && beatTrigged==true) {
       speedDelta= 2;
  //     key='e'; keyReleased();
      keyCode =CONTROL; keyReleased();
    
  } 
    if ( measure>=109 && measure<=109 && beatTrigged==true) {
       speedDelta= 2;
     
  } 
    if ( measure>=115 && measure<=115 && beatTrigged==true) {
       speedDelta= 2;
    //   key='e'; keyReleased();
    
  } 
      if ( measure>=116 && measure<=116 && beatTrigged==true) {
       speedDelta= 2;
     
  } 


  if  (measure>=129 && measure<130 && beatTrigged==true) {// measure>=41 && measure<=42
    speedDelta=4;
    key='$';
    keyReleased();
    key='H';
    keyReleased();
    key='H';
    keyReleased();
    key='H';
    keyReleased();
    key='H';
    keyReleased();

    key='H';
    keyReleased();
    key='H';
    keyReleased();
    key='H';
    keyReleased();
    key='H';
    keyReleased();

    //  key='O';
    ///   keyReleased();

    //   key='°';keyReleased(); // speed=0 
    key='0';
    keyReleased(); // speed=0
    key='q';
    keyReleased(); // speed=0
    key='n';
    keyReleased(); // speed=0
  }
  if  (measure>=129 ) {// measure>=41 && measure<=42
    //  autoNote1();
  }


  if  (measure>=133 && measure<=137 && beatTrigged==true) {// measure>=41 && measure<=42

    //  key='o';    keyReleased();
    key='*';    
    keyReleased();
    key='w';    
    keyReleased();
  }
  if  (measure>=137 && measure<=137 && beatTrigged==true) {// measure>=41 && measure<=42

    //  key='o';    keyReleased();
    key='*';    
    keyReleased();
    
  }
   if  (measure>=166 && beatTrigged==true) {// measure>=41 && measure<=42
    key='°';    keyReleased();
    key='o';    keyReleased();
    key='*';    keyReleased();
    
  }
  // autoNote1Original(); // !=0
  // autoNote2();
}

 public void autoNote1VelInf64() {//1 61 63 64 66 85 

 // keyPressedLFO();


 // if (((formerSartKey!='a')) 
  if (((formerSartKey!='L')) 
    ) 
  {

    if (( measure>=12 && measure<=12 && beatPrecised>=4 && beatPrecisedTrigged==true )
      ) {
      //    key='K';keyReleased();
    }
    if (( measure>=12 && measure<=34 && millis()>formerEvent[76]+1000) &&
      ((note1>75 && note1<77 && velocity1>=1 && velocity1<=127)|| (note2>75 && note2<77 && velocity2>=1 && velocity2<=127)|| (note3>75 && note3<77 && velocity3>=1 && velocity3<=127) ||
      (note4>75 && note4<77 && velocity4>=1 && velocity4<=127)|| (note5>75 && note5<77 && velocity5>=1 && velocity5<=127)|| (note6>75 && note6<77 && velocity6>=1 && velocity6<=127)
      )) {
      key='9';
      keyReleased();

      key='P';
      keyReleased();
      key='P';
      keyReleased();

      formerEvent[76]=millis();
    }
    if (( measure>=24 && measure<=34 && millis()>formerEvent[76]+1000) &&
      ((note1>75 && note1<77 && velocity1>=1 && velocity1<=127)|| (note2>75 && note2<77 && velocity2>=1 && velocity2<=127)|| (note3>75 && note3<77 && velocity3>=1 && velocity3<=127) ||
      (note4>75 && note4<77 && velocity4>=1 && velocity4<=127)|| (note5>75 && note5<77 && velocity5>=1 && velocity5<=127)|| (note6>75 && note6<77 && velocity6>=1 && velocity6<=127)
      )) {
      key='9';
      keyReleased();
      key='P';
      keyReleased();
      key='P';
      keyReleased();
      key='p';
      keyReleased();


      formerEvent[76]=millis();
    }

    if  (measure>=12 && measure<=15  && beatTrigged==true ) {// beatPrecised2=true
      for (int i = 0; i < networkSize; i++) {
      }
    }
    if  (measure>16 && measure<=18  && beatTrigged==true ) {// beatPrecised2=true
      for (int i = 0; i < networkSize; i++) {


        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>=36 && measure<=36  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {
        key='0';
        keyReleased();
        key='q';
        keyReleased();
        key='n';
        keyReleased();
        key='q';
        keyReleased();
        key='n';
        keyReleased();
        key='o';
        keyReleased();

        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>41 && measure<=42  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //    ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
      }
    }
    //%ADMAD
    if (( measure<=40 && millis()>formerEvent[67]+50+d )&&
      (
      (note1>66 && note1<68  && velocity1>=1 && velocity1<=64)|| (note2>66 && note2<68 && velocity2>=1 && velocity2<=64) || (note3>66 && note3<68 && velocity3>=1 && velocity3<=64) || 
      (note4>66 && note4<68  && velocity4>=1 && velocity4<=64)|| (note5>66 && note5<68 && velocity5>=1 && velocity5<=64) || (note6>66 && note6<68 && velocity6>=1 && velocity6<=64)
      )) {
      //   key='E'; 
          key='r'; 
          keyReleased(); //u=117
      formerEvent[67]=millis();
      print ("formerEvent[67] INSIDE"); 
      println (formerEvent[67]);
    }

    if (( measure<=15 && millis()>formerEvent[64]+950+d )&&
      (
      (note1>63 && note1<65  && velocity1>=1 && velocity1<=64)|| (note2>63 && note2<65 && velocity2>=1 && velocity2<=64) || (note3>63 && note3<65 && velocity3>=1 && velocity3<=64) || 
      (note4>63 && note4<65  && velocity4>=1 && velocity4<=64)|| (note5>63 && note5<65 && velocity5>=1 && velocity5<=64) || (note6>63 && note6<65 && velocity6>=1 && velocity6<=64)
      )) {
      //    key='f'; 
      //     keyReleased(); //u=117
      formerEvent[64]=millis();
      print ("formerEvent[64] INSIDE"); 
      println (formerEvent[64]);
    }

    if (( measure<=40  && millis()>formerEvent[69]+900+d )&& // from Track1 and Track 0
      (
      (note1>68 && note1<70  && velocity1>=1 && velocity1<=64)|| (note2>68 && note2<70 && velocity2>=1 && velocity2<=64) || (note3>68 && note3<70 && velocity3>=1 && velocity3<=64) || 
      (note4>68 && note4<70  && velocity4>=1 && velocity4<=64)|| (note5>68 && note5<70 && velocity5>=1 && velocity5<=64) || (note6>68 && note6<70 && velocity6>=1 && velocity6<=64)
      )) {
      //      key='r'; 
      //   keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if (( measure>=123 && millis()>formerEvent[69]+100+d )&&
      (
      (note1>68 && note1<70  && velocity1>=1 && velocity1<=64)|| (note2>68 && note2<70 && velocity2>=1 && velocity2<=64) || (note3>68 && note3<70 && velocity3>=1 && velocity3<=64) || 
      (note4>68 && note4<70  && velocity4>=1 && velocity4<=64)|| (note5>68 && note5<70 && velocity5>=1 && velocity5<=64) || (note6>68 && note6<70 && velocity6>=1 && velocity6<=64)
      )) {
      key='U'; 
      keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if ( measure>=123 && measure<=123 && beatTrigged==true 

      ) {
      //   key='9'; 
      //   keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+4 && measure<=123+4 && beatTrigged==true 

      ) {
      //    key='9'; 
      //    keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='9'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='p'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }


    if (( measure<=11 && millis()>formerEvent[72]+350+d )&& //250 to adjust with 172 (the other hand of mad rush)
      ((note1>71 && note1<73  && velocity1>=1 && velocity1<=64)|| (note2>71 && note2<73 && velocity2>=1 && velocity2<=64) || (note3>71 && note3<73 && velocity3>=1 && velocity3<=64) ||
      (note4>71 && note4<73  && velocity4>=1 && velocity4<=64)|| (note5>71 && note5<73 && velocity5>=1 && velocity5<=64) || (note6>71 && note6<73 && velocity6>=1 && velocity6<=64)
      )) {

      key='U';//i= 105 
      keyReleased(); 
      formerEvent[72]=millis();
      print ("formerEvent[72] INSIDE"); 
      println (formerEvent[72]);
    }

    if (( measure>11 && measure<41 && millis()>formerEvent[72]+350+d-300 )&& //250 to adjust with 172 (the other hand of mad rush)
      ((note1>71 && note1<73  && velocity1>=1 && velocity1<=64)|| (note2>71 && note2<73 && velocity2>=1 && velocity2<=64) || (note3>71 && note3<73 && velocity3>=1 && velocity3<=64) ||
      (note4>71 && note4<73  && velocity4>=1 && velocity4<=64)|| (note5>71 && note5<73 && velocity5>=1 && velocity5<=64) || (note6>71 && note6<73 && velocity6>=1 && velocity6<=64)
      )) {

      key='U';//i= 105 
      keyReleased(); 
      formerEvent[72]=millis();
      print ("formerEvent[72] INSIDE"); 
      println (formerEvent[72]);
    }
    /*
      if (( measure>40 && measure<61 && millis()>formerEvent[72]+25+d) && // RETROUVE joli d. Plus coherent sur 64
     ((note1>71 && note1<73  && velocity1>=1 && velocity1<=64 )|| (note2>71 && note2<73 && velocity2>=1 && velocity2<=64) || (note3>71 && note3<73 && velocity3>=1 && velocity3<=64)||
     (note4>71 && note4<73  && velocity4>=1 && velocity4<=64 )|| (note5>71 && note5<73 && velocity5>=1 && velocity5<=64) || (note6>71 && note6<73 && velocity6>=1 && velocity6<=64)
     )) { 
     key='d'; 
     keyReleased(); 
     key='d'; 
     keyReleased(); 
     key='d';    
     formerEvent[72]=millis();
     }
     */
    if (( measure>25 && measure<35 && millis()>formerEvent[70]+300 )&& // from Track1 and Track 0
      (
      (note1>69 && note1<71  && velocity1>=1 && velocity1<=64)|| (note2>69 && note2<71 && velocity2>=1 && velocity2<=64) || (note3>69 && note3<71 && velocity3>=1 && velocity3<=64) || 
      (note4>69 && note4<71  && velocity4>=1 && velocity4<=64)|| (note5>69 && note5<71 && velocity5>=1 && velocity5<=64) || (note6>69 && note6<71 && velocity6>=1 && velocity6<=64)
      )) {
      // oscillatorBlocked=10;  
      key='R'; 
      keyReleased(); 
      //   key='f'; 
      //   keyReleased(); 

      formerEvent[70]=millis();
      print ("                                                   formerEvent[64] INSIDE> f  "); 
      println (formerEvent[64]);
    }



    if (( measure>40 && measure<61  && millis()>formerEvent[64]+100 )&& // from Track1 and Track 0
      (
      (note1>63 && note1<65  && velocity1>=1 && velocity1<=64)|| (note2>63 && note2<65 && velocity2>=1 && velocity2<=64) || (note3>63 && note3<65 && velocity3>=1 && velocity3<=64) || 
      (note4>63 && note4<65  && velocity4>=1 && velocity4<=64)|| (note5>63 && note5<65 && velocity5>=1 && velocity5<=64) || (note6>63 && note6<65 && velocity6>=1 && velocity6<=64)
      )) {
      oscillatorBlocked=10;  
      key='f'; 
      keyReleased(); 
      //   key='f'; 
      //   keyReleased(); 

      formerEvent[64]=millis();
      print ("                                                   formerEvent[64] INSIDE> f  "); 
      println (formerEvent[64]);
    }




    if (( measure>40 && measure<61  && millis()>formerEvent[69]+100 )&& // from Track1 and Track 0
      (
      (note1>68 && note1<70  && velocity1>=1 && velocity1<=64)|| (note2>68 && note2<70 && velocity2>=1 && velocity2<=64) || (note3>68 && note3<70 && velocity3>=1 && velocity3<=64) || 
      (note4>68 && note4<70  && velocity4>=1 && velocity4<=64)|| (note5>68 && note5<70 && velocity5>=1 && velocity5<=64) || (note6>68 && note6<70 && velocity6>=1 && velocity6<=64)
      )) {
      oscillatorBlocked=1;
      key='d'; 
      keyReleased(); 
      //  key='d'; 
      //  keyReleased(); 


      formerEvent[69]=millis();
      print ("                                                   formerEvent[69] INSIDE> d  "); 
      println (formerEvent[69]);
    }

    if (( measure>40 && measure<61  && millis()>formerEvent[67]+100 )&& // pour equilibrer le trop plein de f
      (
      (note1>66 && note1<68  && velocity1>=1 && velocity1<=64)|| (note2>68 && note2<68 && velocity2>=1 && velocity2<=64) || (note3>68 && note3<68 && velocity3>=1 && velocity3<=64) || 
      (note4>68 && note4<68  && velocity4>=1 && velocity4<=64)|| (note5>68 && note5<68 && velocity5>=1 && velocity5<=64) || (note6>68 && note6<68 && velocity6>=1 && velocity6<=64)
      )) {
      //   oscillatorBlocked=1;
      key='d'; 
      keyReleased(); 
      //  key='d'; 
      //  keyReleased(); 


      formerEvent[67]=millis();
      print ("                                                   formerEvent[67] INSIDE> d  "); 
      println (formerEvent[67]);
    }


    if (( measure>60 && measure<78 && millis()>formerEvent[72]+1000) && //25+d
      ((note1>71 && note1<73  && velocity1>=1 && velocity1<=64 )|| (note2>71 && note2<73 && velocity2>=1 && velocity2<=64) || (note3>71 && note3<73 && velocity3>=1 && velocity3<=64)||
      (note4>71 && note4<73  && velocity4>=1 && velocity4<=64 )|| (note5>71 && note5<73 && velocity5>=1 && velocity5<=64) || (note6>71 && note6<73 && velocity6>=1 && velocity6<=64)
      )) {
      // key='d'; 
      key='i'; // u bloque 
      keyReleased(); //u=117
      formerEvent[72]=millis();
    }

    if  ( measure>60 && measure<78 && (millis()>formerEvent[73]+0+d+150) &&
      ((note1>71+1 && note1<73+1  && velocity1>=1 && velocity1<=64 )|| (note2>71+1 && note2<73+1 && velocity2>=1 && velocity2<=64) || (note3>71+1 && note3<73+1 && velocity3>=1 && velocity3<=64) ||
      (note4>71+1 && note4<73+1  && velocity4>=1 && velocity4<=64 )|| (note5>71+1 && note5<73+1 && velocity5>=1 && velocity5<=64) || (note6>71+1 && note6<73+1 && velocity6>=1 && velocity6<=64)
      )) {
      //  key='d';
      //  key='U';
      //    keyReleased(); //u=117
      formerEvent[73]=millis();
    }



    if ((( measure<41 && measure<41) && (millis()>formerEvent[74]+100)) &&
      ((note1>73 && note1<75 && velocity1>=1 && velocity1<=64)|| (note2>73 && note2<75 && velocity2>=1 && velocity2<=64)|| (note3>73 && note3<75 && velocity3>=1 && velocity3<=64) ||
      (note4>73 && note4<75 && velocity4>=1 && velocity4<=64)|| (note5>73 && note5<75 && velocity5>=1 && velocity5<=64)|| (note6>73 && note6<75 && velocity6>=1 && velocity6<=64)
      )) {
      key='r';
      keyReleased();
      key='r';
      keyReleased();
      formerEvent[74]=millis();
    }
    if (( measure>61 && measure<78 && millis()>formerEvent[74]+200) &&  // wiat 200 ms before consideration of the next event 74. Here is note 74
      ((note1>73 && note1<75 && velocity1>=1 && velocity1<=64)|| (note2>73 && note2<75 && velocity2>=1 && velocity2<=64)|| (note3>73 && note3<75 && velocity3>=1 && velocity3<=64) ||
      (note4>73 && note4<75 && velocity4>=1 && velocity4<=64)|| (note5>73 && note5<75 && velocity5>=1 && velocity5<=64)|| (note6>73 && note6<75 && velocity6>=1 && velocity6<=64)
      )) {

      oscillatorBlocked=6; 
      key='f'; 
      keyReleased();//i= 105
      ///   key='f'; 
      //  keyReleased();//i= 105
      formerEvent[74]=millis();
    }

    if  ( measure<78 && millis()>formerEvent[75]+0+d &&

      ((note1>73+1 && note1<75+1 && velocity1>=1 && velocity1<=64)|| (note2>73+1 && note2<75+1 && velocity2>=1 && velocity2<=64) || (note3>73+1 && note3<75+1 && velocity3>=1 && velocity3<=64) ||
      (note4>73+1 && note4<75+1 && velocity4>=1 && velocity4<=64)|| (note5>73+1 && note5<75+1 && velocity5>=1 && velocity5<=64) || (note6>73+1 && note6<75+1 && velocity6>=1 && velocity6<=64)
      )) {

      //  key='k'; 
      //  keyReleased();//i= 105

      formerEvent[75]=millis();
    }



    if  (note1>65 && note1<67 && velocity1 >79  && velocity1 <81) {

      //     key='J'; keyReleased();
    }
    if  (note1>73 && note1<75 && velocity1 >79  && velocity1 <81) {//
      //   key='f'; keyReleased();
      //      key='K'; keyReleased();



      if  (   (note1>59 && note1<61 && velocity1 >95 && velocity1 <97) || (note2>59 && note2<61 && velocity2 >95 && velocity2 <97)) {
        //       if  (note1<1){
        //  key='p'; keyReleased();
        //    formerFrame=millis();

        //   key='p'; 
        //   keyReleased();//p=112;
        //   formerEvent[60]=millis();

        //    key='d'; keyReleased();
        //     formerKey=key;

        // doNothing();
      }   

      if  (   (note1>75 && note1<77) || (note2>75 && note2<77)  ) {

        //   key='d'; 
        //   keyReleased();//d=100;
        formerEvent[76]=millis();
      }
      if  (note2>82 && note2<84 || note1>82 && note1<84) {

        //   key='f'; 
        //   keyReleased();//f=102
        formerEvent[83]=millis();
        //    key='g'; keyReleased();
        //     key='g'; keyReleased();
        //    doNothing();
      }
    }
  }
}


 public void  autoNote2() {//1 61 63 64 66 85 
 // keyPressedLFO();

  print (millis()); 
  print (" auto2  formerEvent[167]  "); 
  print (formerEvent[167]);
  print (" auto2  formerEvent[172]  "); 
  println (formerEvent[172]);

  if ((formerSartKey!='L') 
    ) 
  {
    if  (measure>40 && measure<=41 && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //   key='W'; 
        //   keyReleased();
        //  formerW();
      }
    }
    if  (measure>41 && measure<=42  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //    ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
        //     ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
        //    key=';';keyPressed(); print ("rise up frameratio +5 ");
        //    key=';';keyPressed(); print ("rise up frameratio +5 ");
        //    key=';';keyPressed(); print ("rise up frameratio +5 ");
      }
    }
    //%ADMAD
    if (( measure<=40 && millis()>formerEvent[167]+450+d)&&
      ((note1>66 && note1<68  && velocity1>=96 && velocity1<=96)|| (note2>66 && note2<68 && velocity2>=96 && velocity2<=96) || (note3>66 && note3<68 && velocity3>=96 && velocity3<=96))) {
      formerEvent[167]=millis();
      //  key='E'; 
      //  keyReleased(); //u=117


      print ("formerEvent[167] INSIDE ");  
      print ("formerEvent[167] INSIDE ");  
      print ("formerEvent[167] INSIDE ");   
      print ("formerEvent[167] INSIDE "); 
      println (formerEvent[167]);
    }

    if (( measure<=40 && millis()>formerEvent[169]+1000+d)&&
      ((note1>68 && note1<70  && velocity1>=96 && velocity1<=96)|| (note2>68 && note2<70 && velocity2>=96 && velocity2<=96) || (note3>68 && note3<70 && velocity3>=96 && velocity3<=96))) {

      key='E'; //E=69
      keyReleased(); //u=117
      formerEvent[169]=millis(); 

      print ("formerEvent[169] INSIDE ");  
      println (formerEvent[169]);
    } 

    if (( measure>40 && measure<75 && millis()>formerEvent[169]+450+d)&&
      ((note1>68 && note1<70  && velocity1>=96 && velocity1<=96)|| (note2>68 && note2<70 && velocity2>=96 && velocity2<=96) || (note3>68 && note3<70 && velocity3>=96 && velocity3<=96))) {

      key='P'; //P=80
      keyReleased(); //u=117


      print ("formerEvent[169] INSIDE ");  
      println (formerEvent[169]);
      formerEvent[169]=millis();
    } 

    if (( measure>78 && measure<=129 && millis()>formerEvent[169]+2950 )  && //1400 with P
      ((note1>68 && note1<70  && velocity1>=96 && velocity1<=96)|| (note2>68 && note2<70 && velocity2>=96 && velocity2<=96) || (note3>68 && note3<70 && velocity3>=96 && velocity3<=96))) {

   //   key='R'; //P=80    R when frequency are negative
      key='p';
      keyReleased(); //u=117
      key='#'; //P=80    R when frequency are negative
      //  keyReleased(); //u=117

      formerEvent[169]=millis();
      print ("formerEvent[269] INSIDE ");  
      println (formerEvent[169]);
    } 
    
     if (( measure>=80 && measure<=80 && beatPrecised>=1 && beatPrecised<=1 && beatPrecisedTrigged==true )
      ) {
      //    key='p';keyReleased();
    //      keyCode=CONTROL;keyReleased();
          key='#';
    }
    
         if (( measure>=83 && measure<=83 && beatPrecised>=1 && beatPrecised<=1 && beatPrecisedTrigged==true )
      ) {
        //  key='p';keyReleased();
      //    keyCode=CONTROL;keyReleased();
          key='#';
    }



    if (( measure<=5 && millis()>formerEvent[172]+300+d)&&
      ((note1>71 && note1<73  && velocity1>=96 && velocity1<=96 )|| (note2>71 && note2<73 && velocity2>=96 && velocity2<=96) || (note3>71 && note3<73 && velocity3>=96 && velocity3<=96))) {

      //   key='i';//i= 105 
      oscillatorBlocked=6;
      //     key='d';
      //   key='f'; //f=102;
      //  keyReleased();
      formerEvent[172]=millis();
      print ("formerEvent[172] INSIDE ");  
      print ("formerEvent[172] INSIDE ");  
      print ("formerEvent[172] INSIDE ");  
      print ("formerEvent[172] INSIDE "); 
      println (formerEvent[172]);
    }
    if ((( measure>40 && measure<61) && (millis()>formerEvent[172]+100+d) && //200
      ((note1>71 && note1<73  && velocity1>=96 && velocity1<=96 )|| (note2>71 && note2<73 && velocity2>=96 && velocity2<=96) || (note3>71 && note3<73 && velocity3>=96 && velocity3<=96)))) {
      //   key='t'; keyReleased();//i= 105   
      //     key='d';//   to much case d with autonote1
      //     keyReleased(); 
      //     key='d'; 
      //     keyReleased(); 
      formerEvent[172]=millis();
    }
    if (( measure>60 && (millis()>formerEvent[172]+200+d) &&
      ((note1>71 && note1<73  && velocity1>=96 && velocity1<=96 )|| (note2>71 && note2<73 && velocity2>=96 && velocity2<=96) || (note3>71 && note3<73 && velocity3>=96 && velocity3<=96)))) {
      // key='d'; 
      //  key='u'; 
      //   keyReleased(); //u=117
      formerEvent[172]=millis();
    }

    if  ( (millis()>formerEvent[173]+1000+d) &&
      ((note1>71+1 && note1<73+1  && velocity1>=96 && velocity1<=96 )|| (note2>71+1 && note2<73+1 && velocity2>=96 && velocity2<=96) || (note3>71+1 && note3<73+1 && velocity3>=96 && velocity3<=96))) {
      //  key='d';
      //    key='i';
      //   keyReleased(); //u=117
      formerEvent[173]=millis();
    }
    if ((( measure<41 && measure<41) && (millis()>formerEvent[174]+200+d)) &&
      ((note1>73 && note1<75 && velocity1>=96 && velocity1<=96)|| (note2>73 && note2<75 && velocity2>=96 && velocity2<=96)|| (note3>73 && note3<75 && velocity3>=96 && velocity3<=96))) {
      //   key='u'; //u=117 
      //   key='d'; //u=117 
      //   keyReleased();
      formerEvent[174]=millis();
    }
    if ((( measure>41 && measure<78) && (millis()>formerEvent[174]+200+d) &&
      ((note1>73 && note1<75 && velocity1>=96 && velocity1<=96)|| (note2>73 && note2<75 && velocity2>=96 && velocity2<=96)))) {

      //      key='t'; keyReleased();//i= 105 
  //***    key='d'; 
      keyReleased();//i= 105
      //  key='d'; 
      //  keyReleased();//i= 105
      formerEvent[174]=millis();
    }

    if  ( millis()>formerEvent[175]+300 &&

      ((note1>73+1 && note1<75+1 && velocity1>=96 && velocity1<=96)|| (note2>73+1 && note2<75+1 && velocity2>=96 && velocity2<=96))) {


   //   key='f';  
    //  keyReleased();//i= 105
    
      /*
        keyReleased();//i= 105
       key='f'; 
       keyReleased();//i= 105
       key='f'; 
       keyReleased();//i= 105
       key='f'; 
       keyReleased();//i= 105
       */
      formerEvent[175]=millis();
    }



    if  (note1>65 && note1<67 && velocity1 >79  && velocity1 <81) {
      //       if  (note1<1){
      //  key='p'; keyReleased();

      //   key='d'; keyReleased();
      //     key='J'; keyReleased();

      //       formerFrame=millis();
      // doNothing();
    }
    if  (note1>73 && note1<75 && velocity1 >79  && velocity1 <81) {//
      //   key='f'; keyReleased();
      //      key='K'; keyReleased();

      //       formerFrame=millis();

      //     key='f'; keyReleased();
      //   doNothing();
    }
    /////TRACK 0 BEAT from MADRUSH 

    //   if  ((note1>0 && note1<6  && velocity1 >79 ) || (note2>0 && note2<6  && velocity2 >79 ) || (note3>0 && note3<6  && velocity3 >79 ) 
    //     || (note4>0 && note4<6  && velocity4 >79 ) || (note5>0 && note5<6  && velocity5 >79 ) || (note6>0 && note6<6  && velocity6 >79 ) 
    //   ){
    ///      if  ((note1>84 && note1<86  && velocity1 >78 && velocity1 <201) || (note2>84 && note2<86  && velocity2 >78  && velocity2 <201)
    //     ||   (note3>84 && note3<86  && velocity3 >78 && velocity3 <201)){  

    if  (   (note1>59 && note1<61 && velocity1 >95 && velocity1 <97) || (note2>59 && note2<61 && velocity2 >95 && velocity2 <97)) {
      //       if  (note1<1){
      //  key='p'; keyReleased();
      //    formerFrame=millis();

      //    key='p'; 
      keyReleased();//p=112;
      formerEvent[160]=millis();

      //    key='d'; keyReleased();
      //     formerKey=key;

      // doNothing();
    }   

    if  (   (note1>75 && note1<77) || (note2>75 && note2<77)) {
      //       if  (note1<1){
      //  key='p'; keyReleased();
      //    formerFrame=frameCount;

      //  key='d'; 
      keyReleased();//d=100;
      formerEvent[176]=millis();
      //    key='d'; keyReleased();
      //    formerKey=key;

      // doNothing();
    }
    if  (note2>82 && note2<84 || note1>82 && note1<84) {

  //***    key='d'; 
  //**    keyReleased();//f=102
      formerEvent[183]=millis();
      //    key='g'; keyReleased();
      //     key='g'; keyReleased();
      //    doNothing();
    }
  }
} 

 public void autoNote1Original() {//1 61 63 64 66 85 
  keyPressedLFO();


//  if (((formerSartKey!='a')) 
   if (((formerSartKey!='L')) 
    ) 
  {
    if  (measure>40 && measure<=41  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>41 && measure<=42  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //    ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
      }
    }
    //%ADMAD
    if (( measure<=40 && millis()>formerEvent[67]+50+d )&&
      (
      (note1>66 && note1<68  && velocity1!=0)|| (note2>66 && note2<68 && velocity2!=0) || (note3>66 && note3<68 && velocity3!=0) || 
      (note4>66 && note4<68  && velocity4!=0)|| (note5>66 && note5<68 && velocity5!=0) || (note6>66 && note6<68 && velocity6!=0)
      )) {
      key='E'; 
      keyReleased(); //u=117
      formerEvent[67]=millis();
      print ("formerEvent[67] INSIDE"); 
      println (formerEvent[67]);
    }

    if (( measure<=40 && millis()>formerEvent[64]+50+d )&&
      (
      (note1>63 && note1<65  && velocity1!=0)|| (note2>63 && note2<65 && velocity2!=0) || (note3>63 && note3<65 && velocity3!=0) || 
      (note4>63 && note4<65  && velocity4!=0)|| (note5>63 && note5<65 && velocity5!=0) || (note6>63 && note6<65 && velocity6!=0)
      )) {
      key='f'; 
      //     keyReleased(); //u=117
      formerEvent[64]=millis();
      print ("formerEvent[64] INSIDE"); 
      println (formerEvent[64]);
    }

    if (( measure<=40  && millis()>formerEvent[69]+50+d )&& // from Track1
      (
      (note1>68 && note1<70  && velocity1!=0)|| (note2>68 && note2<70 && velocity2!=0) || (note3>68 && note3<70 && velocity3!=0) || 
      (note4>68 && note4<70  && velocity4!=0)|| (note5>68 && note5<70 && velocity5!=0) || (note6>68 && note6<70 && velocity6!=0)
      )) {
      key='r'; 
      keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if (( measure>=123 && millis()>formerEvent[69]+100+d )&&
      (
      (note1>68 && note1<70  && velocity1!=0)|| (note2>68 && note2<70 && velocity2!=0) || (note3>68 && note3<70 && velocity3!=0) || 
      (note4>68 && note4<70  && velocity4!=0)|| (note5>68 && note5<70 && velocity5!=0) || (note6>68 && note6<70 && velocity6!=0)
      )) {
      key='U'; 
      keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if ( measure>=123 && measure<=123 && beatTrigged==true 

      ) {
 //     key='9'; 
 //     keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+4 && measure<=123+4 && beatTrigged==true 

      ) {
  //    key='9'; 
  //    keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='9'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='p'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }


    if (( measure<=40 && millis()>formerEvent[72]+100+d )&& // to adjust with 172 (the other hand of mad rush)
      ((note1>71 && note1<73  && velocity1!=0)|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0) ||
      (note4>71 && note4<73  && velocity4!=0)|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {

      key='U';//i= 105 
      //    key='f';
      keyReleased(); 
      formerEvent[72]=millis();
      print ("formerEvent[72] INSIDE"); 
      println (formerEvent[72]);
    }

    if (( measure>40 && measure<61 && millis()>formerEvent[72]+0+d) && // RETROUVE joli d
      ((note1>71 && note1<73  && velocity1!=0 )|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0)||
      (note4>71 && note4<73  && velocity4!=0 )|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {
      //   key='t'; keyReleased();//i= 105   
      key='d'; 
      keyReleased(); 
      key='d'; 
      keyReleased(); 

      formerEvent[72]=millis();
    }

    if (( measure>60 && measure<78 && millis()>formerEvent[72]+150+d) &&
      ((note1>71 && note1<73  && velocity1!=0 )|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0)||
      (note4>71 && note4<73  && velocity4!=0 )|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {
      // key='d'; 
      key='u'; 
      keyReleased(); //u=117
      formerEvent[72]=millis();
    }

    if  ( (millis()>formerEvent[73]+0+d+150) &&
      ((note1>71+1 && note1<73+1  && velocity1!=0 )|| (note2>71+1 && note2<73+1 && velocity2!=0) || (note3>71+1 && note3<73+1 && velocity3!=0) ||
      (note4>71+1 && note4<73+1  && velocity4!=0 )|| (note5>71+1 && note5<73+1 && velocity5!=0) || (note6>71+1 && note6<73+1 && velocity6!=0)
      )) {
      //  key='d';
      key='U';
      keyReleased(); //u=117
      formerEvent[73]=millis();
    }
    if ((( measure<41 && measure<41) && (millis()>formerEvent[74]+0+d)) &&
      ((note1>73 && note1<75 && velocity1!=0)|| (note2>73 && note2<75 && velocity2!=0)|| (note3>73 && note3<75 && velocity3!=0) ||
      (note4>73 && note4<75 && velocity4!=0)|| (note5>73 && note5<75 && velocity5!=0)|| (note6>73 && note6<75 && velocity6!=0)
      )) {
      key='u'; //u=117 
      //   key='d'; //u=117 
      keyReleased();
      formerEvent[74]=millis();
    }
    if (( measure>41 && measure<78 && millis()>formerEvent[74]+0+d) &&
      ((note1>73 && note1<75 && velocity1!=0)|| (note2>73 && note2<75 && velocity2!=0)|| (note3>73 && note3<75 && velocity3!=0) ||
      (note4>73 && note4<75 && velocity4!=0)|| (note5>73 && note5<75 && velocity5!=0)|| (note6>73 && note6<75 && velocity6!=0)
      )) {

      //      key='t'; keyReleased();//i= 105 
      key='f'; 
      keyReleased();//i= 105
      ///   key='f'; 
      //  keyReleased();//i= 105
      formerEvent[74]=millis();
    }

    if  ( measure<78 && millis()>formerEvent[75]+0+d &&

      ((note1>73+1 && note1<75+1 && velocity1!=0)|| (note2>73+1 && note2<75+1 && velocity2!=0) || (note3>73+1 && note3<75+1 && velocity2!=0) ||
      (note4>73+1 && note4<75+1 && velocity4!=0)|| (note5>73+1 && note5<75+1 && velocity5!=0) || (note6>73+1 && note6<75+1 && velocity6!=0)
      )) {

      key='k'; 
      keyReleased();//i= 105

      formerEvent[75]=millis();
    }



    if  (note1>65 && note1<67 && velocity1 >79  && velocity1 <81) {

      //     key='J'; keyReleased();
    }
    if  (note1>73 && note1<75 && velocity1 >79  && velocity1 <81) {//
      //   key='f'; keyReleased();
      //      key='K'; keyReleased();



      if  (   (note1>59 && note1<61 && velocity1 >95 && velocity1 <97) || (note2>59 && note2<61 && velocity2 >95 && velocity2 <97)) {
        //       if  (note1<1){
        //  key='p'; keyReleased();
        //    formerFrame=millis();

        key='p'; 
        keyReleased();//p=112;
        formerEvent[60]=millis();

        //    key='d'; keyReleased();
        //     formerKey=key;

        // doNothing();
      }   

      if  (   (note1>75 && note1<77) || (note2>75 && note2<77)  ) {

        //   key='d'; 
        //   keyReleased();//d=100;
        formerEvent[76]=millis();
      }
      if  (note2>82 && note2<84 || note1>82 && note1<84) {

        //   key='f'; 
        //   keyReleased();//f=102
        formerEvent[83]=millis();
        //    key='g'; keyReleased();
        //     key='g'; keyReleased();
        //    doNothing();
      }
    }
  }
} 


 public void formerKeyL() {
  if ( formerSartKey!='@') {

    float tempo= 1000/pulsation*60;

    print ("tempo ");  
    println (tempo);
    float ratioTempo= (oscillatorBlocked-1)%8.0f ;

    // float tempo108= (27*ratioTempo)+27;// pianophase
    float tempo108= (30*ratioTempo);// madrush
    float tempo109= (27*ratioTempo)%108;
    print ("ratioTempo ");  
    println (ratioTempo);
    print ("tempo108 ");  
    println (tempo108);
    print ("tempo109 ");  
    println (tempo109);

    //   if ( TrigmodPos[9]>=0 && TrigmodPos[9]<1 ||  revolution[9]>=0 && revolution[9]<1) {
    if ( TrigmodPos[0]>=0 && TrigmodPos[0]<1 ||  revolution[0]>=0 && revolution[0]<1) {

      if (tempo>tempo108+1.0f) {
        key='h'; 
        keyReleased();
      }
      if (tempo<tempo108-1.0f) {
        key='y'; 
        keyReleased();
      }
    }
  }
}
 public void autoNote1() {//1 61 63 64 66 85 
  keyPressedLFO();


  if (((formerSartKey!='a')) 
    ) 
  {

    if  (measure>13 && measure<=14  && beatTrigged==true ) {// beatPrecised2=true
      for (int i = 0; i < networkSize; i++) {
        key=CONTROL;
        keyReleased();

        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>23 && measure<=24  && beatTrigged==true ) {// beatPrecised2=true
      for (int i = 0; i < networkSize; i++) {
        key=CONTROL;
        keyReleased();

        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>40 && measure<=41  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {
        key='0';
        keyReleased();
        key='q';
        keyReleased();
        key='n';
        keyReleased();
        key='q';
        keyReleased();
        key='n';
        keyReleased();
        key='o';
        keyReleased();

        //   key='W'; 
        //   keyReleased();
      }
    }
    if  (measure>41 && measure<=42  && beatTrigged==true  ) {// measure>=41 && measure<=42
      for (int i = 0; i < networkSize; i++) {

        //    ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
      }
    }
    //%ADMAD
    if (( measure<=40 && millis()>formerEvent[67]+50+d )&&
      (
      (note1>66 && note1<68  && velocity1!=0)|| (note2>66 && note2<68 && velocity2!=0) || (note3>66 && note3<68 && velocity3!=0) || 
      (note4>66 && note4<68  && velocity4!=0)|| (note5>66 && note5<68 && velocity5!=0) || (note6>66 && note6<68 && velocity6!=0)
      )) {
      //   key='E'; 
      //    key='r'; 
      keyReleased(); //u=117
      formerEvent[67]=millis();
      print ("formerEvent[67] INSIDE"); 
      println (formerEvent[67]);
    }

    if (( measure<=15 && millis()>formerEvent[64]+350+d )&&
      (
      (note1>63 && note1<65  && velocity1!=0)|| (note2>63 && note2<65 && velocity2!=0) || (note3>63 && note3<65 && velocity3!=0) || 
      (note4>63 && note4<65  && velocity4!=0)|| (note5>63 && note5<65 && velocity5!=0) || (note6>63 && note6<65 && velocity6!=0)
      )) {
      key='f'; 
      //     keyReleased(); //u=117
      formerEvent[64]=millis();
      print ("formerEvent[64] INSIDE"); 
      println (formerEvent[64]);
    }

    if (( measure<=40  && millis()>formerEvent[69]+900+d )&& // from Track1 and Track 0
      (
      (note1>68 && note1<70  && velocity1!=0)|| (note2>68 && note2<70 && velocity2!=0) || (note3>68 && note3<70 && velocity3!=0) || 
      (note4>68 && note4<70  && velocity4!=0)|| (note5>68 && note5<70 && velocity5!=0) || (note6>68 && note6<70 && velocity6!=0)
      )) {
      //      key='r'; 
      keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if (( measure>=123 && millis()>formerEvent[69]+100+d )&&
      (
      (note1>68 && note1<70  && velocity1!=0)|| (note2>68 && note2<70 && velocity2!=0) || (note3>68 && note3<70 && velocity3!=0) || 
      (note4>68 && note4<70  && velocity4!=0)|| (note5>68 && note5<70 && velocity5!=0) || (note6>68 && note6<70 && velocity6!=0)
      )) {
      key='U'; 
      keyReleased(); //u=117
      formerEvent[69]=millis();
      print ("formerEvent[69] INSIDE"); 
      println (formerEvent[69]);
    }
    if ( measure>=123 && measure<=123 && beatTrigged==true 

      ) {
      key='9'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+4 && measure<=123+4 && beatTrigged==true 

      ) {
      key='9'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='9'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }
    if ( measure>=123+8 && measure<=123+8 && beatTrigged==true 

      ) {
      key='p'; 
      keyReleased(); //u=117
      //   formerEvent[69]=millis();
    }


    if (( measure<=40 && millis()>formerEvent[72]+100+d )&& // to adjust with 172 (the other hand of mad rush)
      ((note1>71 && note1<73  && velocity1!=0)|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0) ||
      (note4>71 && note4<73  && velocity4!=0)|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {

      key='U';//i= 105 
      //    key='f';
      keyReleased(); 
      formerEvent[72]=millis();
      print ("formerEvent[72] INSIDE"); 
      println (formerEvent[72]);
    }

    if (( measure>40 && measure<61 && millis()>formerEvent[72]+100+d) && // RETROUVE joli d
      ((note1>71 && note1<73  && velocity1!=0 )|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0)||
      (note4>71 && note4<73  && velocity4!=0 )|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {
      //   key='t'; keyReleased();//i= 105   
      key='d'; 
      keyReleased(); 
      key='d'; 
      keyReleased(); 

      formerEvent[72]=millis();
    }

    if (( measure>60 && measure<78 && millis()>formerEvent[72]+150+d) &&
      ((note1>71 && note1<73  && velocity1!=0 )|| (note2>71 && note2<73 && velocity2!=0) || (note3>71 && note3<73 && velocity3!=0)||
      (note4>71 && note4<73  && velocity4!=0 )|| (note5>71 && note5<73 && velocity5!=0) || (note6>71 && note6<73 && velocity6!=0)
      )) {
      // key='d'; 
      key='i'; // u bloque 
      keyReleased(); //u=117
      formerEvent[72]=millis();
    }

    if  ( measure>60 && measure<78 && (millis()>formerEvent[73]+0+d+150) &&
      ((note1>71+1 && note1<73+1  && velocity1!=0 )|| (note2>71+1 && note2<73+1 && velocity2!=0) || (note3>71+1 && note3<73+1 && velocity3!=0) ||
      (note4>71+1 && note4<73+1  && velocity4!=0 )|| (note5>71+1 && note5<73+1 && velocity5!=0) || (note6>71+1 && note6<73+1 && velocity6!=0)
      )) {
      //  key='d';
      //  key='U';
      keyReleased(); //u=117
      formerEvent[73]=millis();
    }
    if ((( measure<41 && measure<41) && (millis()>formerEvent[74]+50+d)) &&
      ((note1>73 && note1<75 && velocity1!=0)|| (note2>73 && note2<75 && velocity2!=0)|| (note3>73 && note3<75 && velocity3!=0) ||
      (note4>73 && note4<75 && velocity4!=0)|| (note5>73 && note5<75 && velocity5!=0)|| (note6>73 && note6<75 && velocity6!=0)
      )) {
      //  key='u'; //u=117 
      //   key='d'; //u=117 
      key='i'; //u=117 
      keyReleased();
      formerEvent[74]=millis();
    }
    if (( measure>41 && measure<78 && millis()>formerEvent[74]+0+d) &&
      ((note1>73 && note1<75 && velocity1!=0)|| (note2>73 && note2<75 && velocity2!=0)|| (note3>73 && note3<75 && velocity3!=0) ||
      (note4>73 && note4<75 && velocity4!=0)|| (note5>73 && note5<75 && velocity5!=0)|| (note6>73 && note6<75 && velocity6!=0)
      )) {

      //      key='t'; keyReleased();//i= 105 
      key='f'; 
      keyReleased();//i= 105
      ///   key='f'; 
      //  keyReleased();//i= 105
      formerEvent[74]=millis();
    }

    if  ( measure<78 && millis()>formerEvent[75]+0+d &&

      ((note1>73+1 && note1<75+1 && velocity1!=0)|| (note2>73+1 && note2<75+1 && velocity2!=0) || (note3>73+1 && note3<75+1 && velocity2!=0) ||
      (note4>73+1 && note4<75+1 && velocity4!=0)|| (note5>73+1 && note5<75+1 && velocity5!=0) || (note6>73+1 && note6<75+1 && velocity6!=0)
      )) {

      key='k'; 
      keyReleased();//i= 105

      formerEvent[75]=millis();
    }



    if  (note1>65 && note1<67 && velocity1 >79  && velocity1 <81) {

      //     key='J'; keyReleased();
    }
    if  (note1>73 && note1<75 && velocity1 >79  && velocity1 <81) {//
      //   key='f'; keyReleased();
      //      key='K'; keyReleased();



      if  (   (note1>59 && note1<61 && velocity1 >95 && velocity1 <97) || (note2>59 && note2<61 && velocity2 >95 && velocity2 <97)) {
        //       if  (note1<1){
        //  key='p'; keyReleased();
        //    formerFrame=millis();

        key='p'; 
        keyReleased();//p=112;
        formerEvent[60]=millis();

        //    key='d'; keyReleased();
        //     formerKey=key;

        // doNothing();
      }   

      if  (   (note1>75 && note1<77) || (note2>75 && note2<77)  ) {

        //   key='d'; 
        //   keyReleased();//d=100;
        formerEvent[76]=millis();
      }
      if  (note2>82 && note2<84 || note1>82 && note1<84) {

        //   key='f'; 
        //   keyReleased();//f=102
        formerEvent[83]=millis();
        //    key='g'; keyReleased();
        //     key='g'; keyReleased();
        //    doNothing();
      }
    }
  }
}
 public void followMovementAll() {
  shiftFollowMov();
    for (int i =1; i < 2; i+=1) {
          LFO[0]=  map (automation1 , 0, 1, 0, TWO_PI);//net.phase[11];// map (automation1 , 0, 1, 0, TWO_PI);
          LFO[i]= LFO[0];
  if (millis()>formerEvent[200+i]+0*i) {
   
    
      newPosX[i] = displacement* cos(LFO[i]);
      newPosY[i] = displacement* sin(LFO[i]);
      formerEvent[200+i]= millis();
    }
  }

  if (millis()>formerEvent[200+2]+d*2) {
    // delay();
    LFO[2]= LFO[1];
    //***   LFO[2]= map (automationLFO[0],0, 1, -PI, 0); // gauche droite vers le haut
    newPosX[2] = displacement*cos (LFO[2]);
    newPosY[2] = displacement*sin (LFO[2]);
    formerEvent[200+2]= millis();
  }

  if (millis()>formerEvent[200+3]+d*3) {
    LFO[3]= LFO[2];
     newPosX[3] = displacement*cos (LFO[3]);
     newPosY[3] = displacement*sin (LFO[3]);
    formerEvent[200+3]= millis();
  }

}

 public void displayfollowMovementAll(){
 // keyPressedLFO();
  
  for (int i =0; i < 1; i++) {
    if (millis()>formerEvent[200+i]+0) {
      //   formerPositionLFO[0]=LFO[0];

   //   LFO[0]= map (automation1, 0, 1, 0, 1); // gauche droite vers le haut
     
   //      LFO[0]=  map (automation1 , 0, 1, 0, TWO_PI);//net.phase[11];// map (automation1 , 0, 1, 0, TWO_PI);

  //     LFO[0]= net.phase[11];// map (automation1 , 0, 1, 0, TWO_PI);
 
   //   LFO[0]=net.phase[0];
   //   newPosX[i] = displacement*cos (LFO[0]);
   //   newPosY[i] = displacement*sin (LFO[0]);
      formerEvent[200+0]= millis(); 

      print (" cos LFO  " ); print (cos (LFO[0]) ); print (" automation1 " );  print (automation1); print (" formEvent  " ); print (i); print (formerEvent[200+i]);
      print (" net.phase[11]  " );  println (net.phase[11] );
    }
  } 
// translate( 0, 0, 1000);
  for (int i =0; i < networkSize-2; i++) {

    pushMatrix();  
    

    sphere(side*3); // this sphere serves as a reference
    sphereDetail( 4*5);
    colorMode(HSB, TWO_PI, 100, 100);
    noStroke();

    // Color sphere and Draw them, depending of acceleration or later with "chimera state"
    mapAcceleration[i]= constrain ((PApplet.parseInt (map (abs(net.acceleration[i] *100), 0, 150, 0, 255))), 0, 255); 
    mapAccelerationinversed[i]= abs (PApplet.parseInt (map ((net.acceleration[i] *100), -200, 200, 0, 255)));
    //********************************************************* BEGIN GRAPHIC CHIMERA STATE
    //********************************************************* END GRAPHIC CHIMERA STATE
    translate (newPosX[i], newPosY[i], 200+(50*5*i));  //*-1 go in clockwise, *1 go in CCW
    colorMode(RGB, 255, 255, 255);
    fill (255,255,0);
    fill( mapAccelerationinversed[i], 255, 0 ); // Sepheres are all modulated with the same color. depending of acceleration
    sphere(side*3);

    popMatrix();
  }
  //   rotate (-HALF_PI);
}

 public void followLFO() {
  shiftFollowMov();
  if (millis()>formerEvent[200+3]+d) {
    // delay();
    LFO[9]= LFO[8];
    LFO[8]= LFO[7];
    LFO[7]= LFO[6];
    LFO[6]= LFO[5];
    LFO[5]= LFO[4];
    LFO[4]= LFO[3];
    LFO[3]= LFO[2];
    //***   LFO[2]= map (automationLFO[0],0, 1, -PI, 0); // gauche droite vers le haut
    for (int i =3; i < networkSize; i++) {
      newPosX[i] = displacement*cos (LFO[i]);
      newPosY[i] = displacement*sin (LFO[i]);
      formerEvent[200+3]= millis();
    }
  }

  if (millis()>formerEvent[200+2]+d) {
    // delay();
    LFO[2]= LFO[1];
    //***   LFO[2]= map (automationLFO[0],0, 1, -PI, 0); // gauche droite vers le haut
    newPosX[2] = displacement*cos (LFO[2]);
    newPosY[2] = displacement*sin (LFO[2]);
    formerEvent[200+2]= millis();
  }

  if (millis()>formerEvent[200+1]+d*1) {
    LFO[1]= LFO[0];
    newPosX[1] = displacement*cos (LFO[1]);
    newPosY[1] = displacement*sin (LFO[1]);
    formerEvent[200+1]= millis();
  }


  for (int i =0; i < 1; i++) {
    if (millis()>formerEvent[200+i]+0) {
      //   formerPositionLFO[0]=LFO[0];

      LFO[0]=  map (automation1 , 0, 1, 0, TWO_PI);//net.phase[11];// map (automation1 , 0, 1, 0, TWO_PI);

      newPosX[0] = displacement*cos (LFO[0]);
      newPosY[0] = displacement*sin (LFO[0]);
      formerEvent[200+0]= millis(); 

      print ("LFO  " ); 
      print (i);  
      print (LFO[0] ); 
      print ("automationLFO " ); 
      print (i); 
      print (automationLFO[i]); 
      print ("formEvent " ); 
      print (i); 
      print (formerEvent[200+i]);
    }
  } 
// translate( 0, 0, 1000);
  for (int i =0; i < networkSize-2; i++) {

    pushMatrix();  
    

    sphere(side*3); // this sphere serves as a reference
    sphereDetail( 4*5);
    colorMode(HSB, TWO_PI, 100, 100);
    noStroke();

    // Color sphere and Draw them, depending of acceleration or later with "chimera state"
    mapAcceleration[i]= constrain ((PApplet.parseInt (map (abs(net.acceleration[i] *100), 0, 150, 0, 255))), 0, 255); 
    mapAccelerationinversed[i]= abs (PApplet.parseInt (map ((net.acceleration[i] *100), -200, 200, 0, 255)));
    //********************************************************* BEGIN GRAPHIC CHIMERA STATE
    //********************************************************* END GRAPHIC CHIMERA STATE
    translate (newPosX[i], newPosY[i], 200+(50*5*i));  //*-1 go in clockwise, *1 go in CCW
    colorMode(RGB, 255, 255, 255);
    fill( mapAccelerationinversed[i], 255, 0 ); // Sepheres are all modulated with the same color. depending of acceleration
    sphere(side*3);

    popMatrix();
  }
  //   rotate (-HALF_PI);
}



 public void followLFObis() {
shiftFollowMov();



  // delay();

  //***   LFO[2]= map (automationLFO[0],0, 1, -PI, 0); // gauche droite vers le haut
  for (int i =3; i < networkSize-2; i++) {
    if (millis()>formerEvent[200+i]+0) {
      LFO[i]= LFO[i-1];

      newPosX[i] = displacement*cos (LFO[i]);
      newPosY[i] = displacement*sin (LFO[i]);
      formerEvent[200+i]= millis();
    }
  }


  if (millis()>formerEvent[200+2]+d) {
    // delay();
    LFO[2]= LFO[1];
    //***   LFO[2]= map (automationLFO[0],0, 1, -PI, 0); // gauche droite vers le haut
    newPosX[2] = displacement*cos (LFO[2]);
    newPosY[2] = displacement*sin (LFO[2]);
    formerEvent[200+2]= millis();
  }

  if (millis()>formerEvent[200+0+1]+0*(0+1)) {
    //   formerPositionLFO[0]=LFO[0];

    LFO[1]=LFO[0]; // gauche droite vers le haut
    newPosX[1] = displacement*cos (LFO[1]);
    newPosY[1] = displacement*sin (LFO[1]);
    //  formerEvent[200+0]= millis();
    formerEvent[200+0+1]= millis(); 


    println (" ");
  }


  for (int i =0; i < 1; i++) {
    if (millis()>formerEvent[200+i]+0) {
      //   formerPositionLFO[0]=LFO[0];

      LFO[0]=  map (automation1 , 0, 1, 0, TWO_PI);//net.phase[11];// map (automation1 , 0, 1, 0, TWO_PI);

      newPosX[0] = displacement*cos (LFO[0]);
      newPosY[0] = displacement*sin (LFO[0]);
      formerEvent[200+0]= millis(); 

      print ("LFO  " ); 
      print (i);  
      print (LFO[0] ); 
      print ("automationLFO " ); 
      print (i); 
      print (automationLFO[i]); 
      print ("formEvent " ); 
      print (i); 
      print (formerEvent[200+i]);
    }
  } 


  for (int i =0; i < networkSize-2; i++) {

    pushMatrix();  

    sphere(side*3); // this sphere serves as a reference
    sphereDetail( 4*5);
    colorMode(HSB, TWO_PI, 100, 100);
    noStroke();

    // Color sphere and Draw them, depending of acceleration or later with "chimera state"
    mapAcceleration[i]= constrain ((PApplet.parseInt (map (abs(net.acceleration[i] *100), 0, 150, 0, 255))), 0, 255); 
    mapAccelerationinversed[i]= abs (PApplet.parseInt (map ((net.acceleration[i] *100), -200, 200, 0, 255)));
    //********************************************************* BEGIN GRAPHIC CHIMERA STATE


    //********************************************************* END GRAPHIC CHIMERA STATE
    translate (newPosX[i], newPosY[i], 200+(50*5*i));  //*-1 go in clockwise, *1 go in CCW
    colorMode(RGB, 255, 255, 255);
    fill( mapAccelerationinversed[i], 255, 0 ); // Sepheres are all modulated with the same color. depending of acceleration
    sphere(side*3);

    popMatrix();
  }
  //   rotate (-HALF_PI);
}

 public void shiftFollowMov() {
  
 
  if (keyCode == LEFT) {  
    println( " LEFT INCREASE decay offseft shiftFollowMov ")  ; 
 //   decayshiftFollowMov=decayshiftFollowMov+50;
    decayshiftFollowMov++;
  
    println ("d= timeOffsetRatio: "); 
    println ( decayshiftFollowMov);
    textSize (100);
    text (" decayshiftFollowMov  ", decayshiftFollowMov, 200,200);

    keyCode=SHIFT; // to trig once keyPressedLFO
  }


  if (keyCode == RIGHT) { 

    println( " right INCREASE decay offseft shiftFollowMov")  ; 
     decayshiftFollowMov=decayshiftFollowMov-50;  
    println ("d= timeOffsetRatio: "); 
    println (d);
    keyCode=SHIFT; // to trig once keyPressedLFO
  }

  if (keyCode == UP) { 

    oscillatorBlocked++;
  
    if (oscillatorBlocked > (networkSize-1)) { 
      oscillatorBlocked=1;
    }
   println ( decayshiftFollowMov);
   textSize (100);
   text (" decayshiftFollowMov  ", decayshiftFollowMov, 300,300);
    
    keyCode=SHIFT; // to trig once keyPressedLFO
  }

  if (keyCode == DOWN) { 
/*
    oscillatorBlocked--;
    // keyCode = LEFT; 
    print ("  oscillatorBlocked ");     
    println (oscillatorBlocked); 
    if (oscillatorBlocked < 2) { 
      oscillatorBlocked=11;
    }
*/
    keyCode=SHIFT; // to trig once keyPressedLFO
  }
} 

 public void keyPressedLFO() {

  float PhaseDecay=d*QUARTER_PI/8;

  if (keyCode == LEFT) {  
    println( " LEFT INCREASE decay offseft in  keyPressedLFO ")  ; // Incremente together without changing phases   
    d+=50;
    d=d%1000;
    println ("d= timeOffsetRatio: "); 
    println (d);

    keyCode=SHIFT; // to trig once keyPressedLFO
  }


  if (keyCode == RIGHT) { 

    println( " right INCREASE timeOffset    from F0 (the behind one  the fastest) F1 very slow =0.021 ")  ; // Incremente together without changing phases   
    d+=50;
    d=d%1000;
    println ("d= timeOffsetRatio: "); 
    println (d);

    keyCode=SHIFT; // to trig once keyPressedLFO
  }

  if (keyCode == UP) { 

    oscillatorBlocked++;
    print (" oscillatorBlocked ");     
    println (oscillatorBlocked); 
    if (oscillatorBlocked > (networkSize-1)) { 
      oscillatorBlocked=1;
    }
    keyCode=SHIFT; // to trig once keyPressedLFO
  }

  if (keyCode == DOWN) { 

    oscillatorBlocked--;
    // keyCode = LEFT; 
    print ("  oscillatorBlocked ");     
    println (oscillatorBlocked); 
    if (oscillatorBlocked < 2) { 
      oscillatorBlocked=11;
    }

    keyCode=SHIFT; // to trig once keyPressedLFO
  }
} 
 public void followMadTrack1bis() {
  //    pendularPatternLFO();
  //    phasePattern();
  if (millis()>formerEvent[200+3]+d) {
    formerEvent[200+3]= millis();
    //***    if (key!='K' || key!='K'){  
    LFO[11]= (LFO[10]+k)%TWO_PI;
    LFO[10]= (LFO[9]+k)%TWO_PI;
    LFO[9]= (LFO[8]+k)%TWO_PI;
    LFO[8]= (LFO[7]+k)%TWO_PI;
    LFO[7]= (LFO[6]+k)%TWO_PI;
    LFO[6]= (LFO[5]+k)%TWO_PI;
    LFO[5]= (LFO[4]+k)%TWO_PI;
    LFO[4]= (LFO[3]+k)%TWO_PI;
    LFO[3]= (LFO[2]+k)%TWO_PI;


    for (int i =3; i < 12; i++) {
      if (millis()>formerEvent[200+0]+0) {        
        net.phase[i]=LFO[i];
      }
    }
  }
  for (int i =2; i < 3; i++) {
    if (millis()>formerEvent[200+0]+0) {

      LFO[i]= map (automation3, 0, 1, 0, TWO_PI); // gauche droite vers le hau.t CIRCULAR MODE usefull ?
      formerEvent[200+0]= millis(); 
      net.phase[i]=LFO[i];

      print ("automation3 " );  
      print (automation3);
    }
  }       

  pendularPatternLFO();
  if (key=='u' || key=='U') {   
    for (int i =2; i < 12; i++) {
      if (millis()>formerEvent[200+0]+0) {        
        //   net.phase[i]=net.phase[i];
      }
    }
  }
}


 public void oscSend(){
 
  for (int i = 1; i < networkSize-0; i++) { 
    //    print (" upVelocity "); print (i); print ("  "); print ( upVelocity[i]);
    //    print (" dataToLive[i] "); println (dataToLive[0]);
   // Pos[0]=0;   
    oldPos[i]=Pos[i];
   
    //MIDDLE POINT == between 61 & 65
    if ((oldPos[i]<= 65 && Pos[i] >=61) ||
        (oldPos[i]>= 61 && Pos[i] <=65)) {

          dataToLive[i]= (networkSize-1)*(i-0);  // because there i beac you can send data with the step you want to separate controller depending oscillator --> here it is 11.
          dataToLive[0]= (networkSize-1)*(i-0);  // you can send data with the step you want to one controler 
      
        upVelocity[i]= 1;   
    }
    
       if ( Pos[i] >65 ||
            Pos[i] <61) {
       dataToLive[i]=0;
      upVelocity[i]= -1;
 
    }    
}

    downVelocity[1]=  upVelocity[2]* upVelocity[3]* upVelocity[4]* upVelocity[5];//* upVelocity[6];
    
               //       upVelocity[7]* upVelocity[8] * upVelocity[9]* upVelocity[10]* upVelocity[11];
                    
     if ( downVelocity[1]>0){ // if one of oscillator is at middle point
    Velocity=1;  
    }
     else  Velocity=-1; 
     
  OscMessage myMessage = new OscMessage("/test");
  OscMessage myMessage1 = new OscMessage("/trigLfo");
  OscMessage myMessage2 = new OscMessage("/Velocity");
  OscMessage myMessage3 = new OscMessage("/cohesion");
  OscMessage myMessage4 = new OscMessage("/upVelocity11");
  OscMessage myMessage5 = new OscMessage("/upVelocity10");
  OscMessage myMessage6 = new OscMessage("/upVelocity9");
  OscMessage myMessage7 = new OscMessage("/upVelocity8");
  OscMessage myMessage8 = new OscMessage("/upVelocity7");
  OscMessage myMessage9 = new OscMessage("/upVelocity6");
  OscMessage myMessage10= new OscMessage("/upVelocity5");
  OscMessage myMessage11= new OscMessage("/upVelocity4");
  OscMessage myMessage12= new OscMessage("/upVelocity3");
  OscMessage myMessage13= new OscMessage("/upVelocity2");
  
  OscMessage myMessage14= new OscMessage("/averageDeltaPhase");
  OscMessage myMessage15= new OscMessage("/startStop");
  OscMessage myMessage16= new OscMessage("/addPhase");
  OscMessage myMessage17= new OscMessage("/addPhaseAllMode");
  OscMessage myMessage18= new OscMessage("/mouseX"); // oscillator 
  OscMessage myMessage19= new OscMessage("/mouseY"); // oscillator behind

 
    float j= LevelCohesionToSend*1.0f;
  myMessage.add((map ((j), 0, 1, 1, 127))); /* add an int to the osc message */
  myMessage1.add( trigLfo);
  float data10= DataToDueCircularVirtualPosition[networkSize-1]*1.0f;   
  myMessage2.add(Velocity);
  myMessage3.add(LevelCohesionToSend);
  /*
  myMessage4.add(upVelocity[11]);
  myMessage5.add(upVelocity[10]);
  myMessage6.add(upVelocity[9]);
  myMessage7.add(upVelocity[8]);
  myMessage8.add(upVelocity[7]);
  myMessage9.add(upVelocity[6]);
*/
  myMessage10.add(upVelocity[5]);
  myMessage11.add(upVelocity[4]);
  myMessage12.add(upVelocity[3]);
  myMessage13.add(upVelocity[2]);
  
  myMessage14.add(averageDeltaPhase);
  myMessage15.add(startStop);
  myMessage16.add((map (addPhase, -1, 1, 0, 127)));
  myMessage17.add((map (addPhaseAllMode, -1, 1, 0, 127)));  
  myMessage18.add((float) map (mouseX, 0, 800, 0, 127));
  myMessage19.add((float) map (mouseY, 0, 800, 0, 127));


  JoDebug  ="<" // BPM9   
   // + (DataToDueCircularVirtualPosition[11])+","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
   // + DataToDueCircularVirtualPosition[6]+","
    +( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","
    + ">";
    
 
  OscMessage myMessage20= new OscMessage("/position11"); // oscillator front
  OscMessage myMessage21= new OscMessage("/position10"); // oscillator 
  OscMessage myMessage22= new OscMessage("/position9"); // oscillator 
  OscMessage myMessage23= new OscMessage("/position8"); // oscillator 
  OscMessage myMessage24= new OscMessage("/position7"); // oscillator 
  OscMessage myMessage25= new OscMessage("/position6"); // oscillato
  OscMessage myMessage26= new OscMessage("/position5"); // oscillator 
  OscMessage myMessage27= new OscMessage("/position4"); // oscillator 
  OscMessage myMessage28= new OscMessage("/position3"); // oscillator 
  OscMessage myMessage29= new OscMessage("/position2"); // oscillator behind
   
  OscMessage myMessage30= new OscMessage("/decompte11"); // oscillator SEND TRIG NOTE IN MAX4LIVE
  OscMessage myMessage31= new OscMessage("/decompte10"); // oscillator 
  OscMessage myMessage32= new OscMessage("/decompte9"); // oscillator 
  OscMessage myMessage33= new OscMessage("/decompte8"); // oscillator 
  OscMessage myMessage34= new OscMessage("/decompte7"); // oscillator 
  OscMessage myMessage35= new OscMessage("/decompte6"); // oscillato
  OscMessage myMessage36= new OscMessage("/decompte5"); // oscillator 
  OscMessage myMessage37= new OscMessage("/decompte4"); // oscillator 
  OscMessage myMessage38= new OscMessage("/decompte3"); // oscillator 
  OscMessage myMessage39= new OscMessage("/decompte2"); // oscillator behind
  
  OscMessage myMessage40= new OscMessage("/dataToLive11"); // oscillator SEND TRIG NOTE IN MAX4LIVE
  OscMessage myMessage41= new OscMessage("/dataToLive10"); // oscillator 
  OscMessage myMessage42= new OscMessage("/dataToLive9"); // oscillator 
  OscMessage myMessage43= new OscMessage("/dataToLive8"); // oscillator 
  OscMessage myMessage44= new OscMessage("/dataToLive7"); // oscillator 
  OscMessage myMessage45= new OscMessage("/dataToLive6"); // oscillato
  OscMessage myMessage46= new OscMessage("/dataToLive5"); // oscillator 
  OscMessage myMessage47= new OscMessage("/dataToLive4"); // oscillator 
  OscMessage myMessage48= new OscMessage("/dataToLive3"); // oscillator 
  OscMessage myMessage49= new OscMessage("/dataToLive2"); // oscillator behind
 
  OscMessage myMessage50= new OscMessage("/acceleration11"); // oscillator SEND ACCELERATION
  OscMessage myMessage51= new OscMessage("/acceleration10"); // oscillator 
  OscMessage myMessage52= new OscMessage("/acceleration9"); // oscillator 
  OscMessage myMessage53= new OscMessage("/acceleration8"); // oscillator 
  OscMessage myMessage54= new OscMessage("/acceleration7"); // oscillator 
  OscMessage myMessage55= new OscMessage("/acceleration6"); // oscillato
  OscMessage myMessage56= new OscMessage("/acceleration5"); // oscillator 
  OscMessage myMessage57= new OscMessage("/acceleration4"); // oscillator 
  OscMessage myMessage58= new OscMessage("/acceleration3"); // oscillator 
  OscMessage myMessage59= new OscMessage("/acceleration2"); // oscillator behind
  OscMessage myMessage60= new OscMessage("/acceleration1"); // oscillator behind
 
 /*
  myMessage20.add(Pos[9]);
  myMessage21.add(Pos[8]);
  myMessage22.add(Pos[7]);
  myMessage23.add(Pos[6]);
  myMessage24.add(Pos[5]);
  myMessage25.add(Pos[4]);
  myMessage26.add(Pos[3]);
  myMessage27.add(Pos[2]);
  myMessage28.add(Pos[1]);
  myMessage29.add(Pos[0]);
*/  
//  print ("Pos11");   println (Pos[11]); println (Pos[11]); println (Pos[11]); println (Pos[11]); 
/*
  myMessage20.add(Pos[11]);
  myMessage21.add(Pos[10]);
  myMessage22.add(Pos[9]);
  myMessage23.add(Pos[8]);
  myMessage24.add(Pos[7]);
  myMessage25.add(Pos[6]);
*/
  myMessage26.add(Pos[5]);
  myMessage27.add(Pos[4]);
  myMessage28.add(Pos[3]);
  myMessage29.add(Pos[2]);
/*  
  myMessage30.add(Pos[9]);
  myMessage31.add(Pos[8]);
  myMessage32.add(Pos[7]);
  myMessage33.add(Pos[6]);
  myMessage34.add(Pos[5]);
  myMessage35.add(Pos[4]);
  myMessage36.add(Pos[3]);
  myMessage37.add(Pos[2]);
  myMessage38.add(Pos[1]);
  myMessage39.add(Pos[0]);
 */
 
 if (formerKeyMetro == '$'  ) { 
  /*
  myMessage30.add(revolution[11]);  //  Trig on the left bug when playing sample in negative way. problem with net_oldphase? or and countrevs
  myMessage31.add(revolution[10]);
  myMessage32.add(revolution[9]);
  myMessage33.add(revolution[8]);
  myMessage34.add(revolution[7]);
  myMessage35.add(revolution[6]);
  */
  myMessage36.add(revolution[5]);
  myMessage37.add(revolution[4]);
  myMessage38.add(revolution[3]);
  myMessage39.add(revolution[2]);
 } 
  
  
 /*
  myMessage30.add(decompte[11]);
  myMessage31.add(decompte[10]);
  myMessage32.add(decompte[9]);
  myMessage33.add(decompte[8]);
  myMessage34.add(decompte[7]);
  myMessage35.add(decompte[6]);
  myMessage36.add(decompte[5]);
  myMessage37.add(decompte[4]);
  myMessage38.add(decompte[3]);
  myMessage39.add(decompte[2]);
  */
  
//  osctrignote

  if (formerKeyMetro == '£'  || formerKeyMetro == '*' || formerKeyMetro == 'J' || formerKeyMetro == 's' || formerKeyMetro == '@' || formerKeyMetro == 'c' ) { // trig note if TrigmodPos[i]=0
  
    showArray(TrigmodPos);
//  TrigmodPos[]=
  // These tests used a copy of the original array so that we can perform multiple
  // test using the same working array
//  println("Convert multiple 0s to 1s (good)");
  result = multiMatchData(0, 1, TrigmodPos.clone());
  TrigmodPos=result;
  showArray(result);
  
//  if ( formerKeyMetro == 'c' ) { // keyMode == followSignalLfo
 if ( keyMode ==  " followSignalLfo "){
    print (" trigNoteOnlyOnceFollowSignalLfo "); 
    showArray(trigFollowSignalLfo);
     
  result = multiMatchData(0, 1, trigFollowSignalLfo.clone());
//  TrigmodPos=result;
  showArray(result);
  

   } 
  /*
  myMessage30.add(TrigmodPos[11]);  // Trig on the right but there are bugs in pendular way
  myMessage31.add(TrigmodPos[10]);
  myMessage32.add(TrigmodPos[9]);
  myMessage33.add(TrigmodPos[8]);
  myMessage34.add(TrigmodPos[7]);
  myMessage35.add(TrigmodPos[6]);
  */
  myMessage36.add(TrigmodPos[5]);
  myMessage37.add(TrigmodPos[4]);
  myMessage38.add(TrigmodPos[3]);
  myMessage39.add(TrigmodPos[2]);
  println (" NOTE TRIGGED FROM OSCSEND ");
  
       
  } 
  /*
  myMessage40.add(dataToLive[11]);  // Trig on the right but there are bugs in pendular way
  myMessage41.add(dataToLive[10]);
  myMessage42.add(dataToLive[9]);
  myMessage43.add(dataToLive[8]);
  myMessage44.add(dataToLive[7]);
  myMessage45.add(dataToLive[6]);
  */

  myMessage46.add(dataToLive[5]);
  myMessage47.add(dataToLive[4]);
  myMessage48.add(dataToLive[3]);
  myMessage49.add(dataToLive[2]);
//  myMessage50.add(dataToLive[0]);
/*
  myMessage50.add(mapAcceleration[11]);  // Trig on the right but there are bugs in pendular way
  myMessage51.add(mapAcceleration[10]);
  myMessage52.add(mapAcceleration[9]);
  myMessage53.add(mapAcceleration[8]);
  myMessage54.add(mapAcceleration[7]);
  myMessage55.add(mapAcceleration[6]);
  */
  myMessage56.add(mapAcceleration[5]);
  myMessage57.add(mapAcceleration[4]);
  myMessage58.add(mapAcceleration[3]);
  myMessage59.add(mapAcceleration[2]);
  myMessage60.add(mapAcceleration[1]);
    
  
  //  UNCOMMENT to BEGIN TO USE good useful OSC
  // /* myRemoteLocation to port 8000

  oscP5.send(myMessage,  myRemoteLocation); 
  oscP5.send(myMessage1, myRemoteLocation); 
  oscP5.send(myMessage2, myRemoteLocation); 
  oscP5.send(myMessage3, myRemoteLocation); 

  oscP5.send(myMessage4, myRemoteLocation); 
  oscP5.send(myMessage5, myRemoteLocation); 
  oscP5.send(myMessage6, myRemoteLocation); 
  oscP5.send(myMessage7, myRemoteLocation); 
  oscP5.send(myMessage8, myRemoteLocation); 
  oscP5.send(myMessage9, myRemoteLocation); 
  oscP5.send(myMessage10, myRemoteLocation); 
  oscP5.send(myMessage11, myRemoteLocation); 
  oscP5.send(myMessage12, myRemoteLocation); 
  oscP5.send(myMessage13, myRemoteLocation); 
  

  oscP5.send(myMessage14, myRemoteLocation);
  oscP5.send(myMessage15, myRemoteLocation); 
  oscP5.send(myMessage16, myRemoteLocation); 
  oscP5.send(myMessage17, myRemoteLocation); 

  // myRemoteLocationII port 8001
  
  oscP5.send(myMessage20, myRemoteLocationII);
  oscP5.send(myMessage21, myRemoteLocationII);
  oscP5.send(myMessage22, myRemoteLocationII);
  oscP5.send(myMessage23, myRemoteLocationII);
  oscP5.send(myMessage24, myRemoteLocationII);
  oscP5.send(myMessage25, myRemoteLocationII);
  oscP5.send(myMessage26, myRemoteLocationII);
  oscP5.send(myMessage27, myRemoteLocationII);
  oscP5.send(myMessage28, myRemoteLocationII);
  oscP5.send(myMessage29, myRemoteLocationII);
   //  END TO USE, NOT BELOW, END OF UNCOMMENT
  
  //*** /*
  oscP5.send(myMessage30, myRemoteLocation);
  oscP5.send(myMessage31, myRemoteLocation);
  oscP5.send(myMessage32, myRemoteLocation);
  oscP5.send(myMessage33, myRemoteLocation);
  oscP5.send(myMessage34, myRemoteLocation);
  oscP5.send(myMessage35, myRemoteLocation);
  oscP5.send(myMessage36, myRemoteLocation);
  oscP5.send(myMessage37, myRemoteLocation);
  oscP5.send(myMessage38, myRemoteLocation);
  oscP5.send(myMessage39, myRemoteLocation);
  //*** */
  
  // myRemoteLocation port 8000  data to live
  oscP5.send(myMessage40, myRemoteLocation);
  oscP5.send(myMessage41, myRemoteLocation);
  oscP5.send(myMessage42, myRemoteLocation);
  oscP5.send(myMessage43, myRemoteLocation);
  oscP5.send(myMessage44, myRemoteLocation);
  oscP5.send(myMessage45, myRemoteLocation);
  oscP5.send(myMessage46, myRemoteLocation);
  oscP5.send(myMessage47, myRemoteLocation);
  oscP5.send(myMessage48, myRemoteLocation);
  oscP5.send(myMessage49, myRemoteLocation);
  oscP5.send(myMessage50, myRemoteLocation);

   // myRemoteLocationII port 8002
  
  // acceleration
  /*
  oscP5.send(myMessage50, myRemoteLocation3);
  oscP5.send(myMessage51, myRemoteLocation3);
  oscP5.send(myMessage52, myRemoteLocation3);
  oscP5.send(myMessage53, myRemoteLocation3);
  oscP5.send(myMessage54, myRemoteLocation3);
  oscP5.send(myMessage55, myRemoteLocation3);
  oscP5.send(myMessage56, myRemoteLocation3);
  oscP5.send(myMessage57, myRemoteLocation3);
  oscP5.send(myMessage58, myRemoteLocation3);
  oscP5.send(myMessage59, myRemoteLocation3);
  
   // myRemoteLocation port 8000
   
    oscP5.send(myMessage50, myRemoteLocation);
  oscP5.send(myMessage51, myRemoteLocation);
  oscP5.send(myMessage52, myRemoteLocation);
  oscP5.send(myMessage53, myRemoteLocation);
  oscP5.send(myMessage54, myRemoteLocation);
  oscP5.send(myMessage55, myRemoteLocation);
  oscP5.send(myMessage56, myRemoteLocation);
  oscP5.send(myMessage57, myRemoteLocation);
  oscP5.send(myMessage58, myRemoteLocation);
  oscP5.send(myMessage59, myRemoteLocation);
*/
 
 
}



 public void drawBall(int n, float phase) {
//  println ( "*************************** drawBall " );
  pushMatrix();
  translate(-w2, -h2, -1000);
  noStroke();
  float side = height*0.15f*1/nbBall;
  float rayon = width/2;

  a = rayon*cos(phase); //-300 à 300
  b = rayon*sin(phase);
  
//   print (" phaseinDB" + phase);

  translate (a, b, 200+(50*5*n)); // on voit la vague comme j'aimerais si on fait ce qui est dit ligne 153
  translate (100, 100, 200+(50*5*n));
  colorMode(RGB, 255, 255, 255);
  fill( 0, 255, 0 );
  sphere(side*3);
  popMatrix();
}

 public float [] phaseReturnedBis(float[] netPhase) { 
  //if former
  for (int i = 2; i < networkSize; i++) {
    //   netPhase[i] = net.phase[i];
    netPhase[i] = netPhase[i];
  }
  return netPhase;  // Returns an array of 3 ints: 20, 40, 60
}

 public void follow( int target, int follower, int delais, float deltaphase) {
  int step = frameCount % nbMaxDelais;
  int followedStep = (step + nbMaxDelais - delais) % nbMaxDelais;
  phases[follower][step] = diffAngle(phases[target][followedStep] + deltaphase, 0);
}

 public float diffAngle(float angle1, float angle2) { // return the difference angle1 - angle2 between two angle between -PI PI
  float result = angle1 - angle2;
  while (result > PI) {
    result -= 2 * PI;
  }
  while (result < -PI) {
    result += 2 * PI;
  }
  return result;
}

 public void drawBallOppositeWay(int n, float phase) {
//  println ( "*************************** drawBallOPPOO " );
  pushMatrix();
  translate(-w2, -h2, -1000);
  noStroke();
  float side = height*0.15f*1/nbBall;
  float rayon = width/2;

  a = rayon*cos(phase+PI); //-300 à 300
  b = rayon*sin(phase+PI);

//  translate (a, b, 200+(75*5*n)); // on voit la vague comme j'aimerais si on fait ce qui est dit ligne 153
  translate (a, b, 200+(50*5*n));
  colorMode(RGB, 255, 255, 255);
  fill( 255, 0, 0 );
//  sphere(side*3);  // redsphere
  popMatrix();
}

 public void followOppositeWay( int target, int follower, int delais, float deltaphase) {
  int step = frameCountBis % nbMaxDelais;
  int followedStep = (step + nbMaxDelais - delais) % nbMaxDelais;
  phases[follower][step] = diffAngle(phases[target][followedStep] + deltaphase, 0);
}

 public float diffAngleOppositeWayOppositeWay(float angle1, float angle2) { // return the difference angle1 - angle2 between two angle between -PI PI
  float result = angle1 - angle2;
  while (result > PI) {
    result -= 2 * PI;
  }
  while (result < -PI) {
    result += 2 * PI;
  }
  return result;
}



 public void arduinoPosJO() { // envoyer les informations aux moteurs

  for (int i = 2; i < nbBall; i++) {

    //  phaseToMotor[i]= (int) map (phaseMapped[i], -PI, PI, 0, 6400);
    phaseToMotor[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, 6400);
  }

  teensyport.write(dataToControlMotor); // Send data to Teensy. only the movement
  println(frameCount + ": " +  " dataToControlMotor " + ( dataToControlMotor ));
}

 public void keyReleasedfollowSignal() {
   if (keyCode == RIGHT) {
  phaseShiftingFollowPhase11++;  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6
  phaseShiftingFollowPhase11=phaseShiftingFollowPhase11%20;
  key='#';}

    if (keyCode == LEFT) {
  delayTimeFollowPhase11++;  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6
  delayTimeFollowPhase11= delayTimeFollowPhase11%20;
  key='#';}
}

 public void keyReleasedfollowSignalPerfect() {
  if (keyCode == RIGHT) {
    print ("keyReleasedfollowSignalPerfect right INCREASE timeOffset ")  ; // Incremente together without changing phases
  //  d++;
    timeFrameOffsetFollowing++;
//    d=d%20;
    timeFrameOffsetFollowing=timeFrameOffsetFollowing%20;
    print (" keyReleasedfollowSignalPerfect d= timeOffsetRatio: ");
    println (timeFrameOffsetFollowing);
    keyCode = SHIFT;
  }

  if (keyCode == LEFT) {
    print ("keyReleasedfollowSignalPerfect  left INCREASE phase shifting"); //
    k= (k+QUARTER_PI/4);
    k= k%(8*QUARTER_PI/2);   

    if (k>=8*QUARTER_PI/2) { 
      k=-k;
    }   
    print ("k= shiftingPhaseRatio ");
    println (k);
    keyCode = SHIFT;
  }
}
 public void followSignal() {
  keyReleasedfollowSignalPerfect();

  println(frameCount + ": " + ( debug ));
 // background(0);

  //  rotate(- TWO_PI+ HALF_PI  ); //TO change the beginning of the 0 (cercle trigo) and the cohesion point to - HALF_PI
  //  translate(width/2-400, -height/2, -1000);// To set the center of the perspective

  if (!firstFollowingStarted) {
    float angle = diffAngle(PI + (frameCount / 4.0f) * cos (1000 / 500.0f), 0);

    print ("angle ");
    println ( angle );

    LFO[2]= map (automation3, 0, 1, 0, TWO_PI);

    if (angle > 0 )
      phases[0][frameCount % nbMaxDelais]= LFO[2];  // gauche droite vers le hau.t CIRCULAR MODE usefull ?// diffAngle(angle, HALF_PI);//% TWO_PI  // position du point de depart + vitesse * phi constant  ==> ici vitesse du point phases[0] est constante
    else
      phases[0][frameCount % nbMaxDelais]= LFO[2];
      drawBall(0, phases[0][frameCount % nbMaxDelais]); // affiche le point 0. NE PAS AFFICHER SINON IL APPARAIT EN DOUBLE
  }

  float deltaFollow = PI/180;

  for (int i = 1; i < nbBall; i++) {
    debug ="Normal follow ";
    //   follow( i-1, i, 20 * i, 0);  // Modifier les deux derniers paramètres : délais et phase
    follow( i-1, i, d, k);  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6

    //*****   drawBall(i, phaseMapped[i] );
    drawBall(i, phases[i][frameCount % nbMaxDelais] );
  }

  /*
     for(int i = 0; i < nbBall; i++) { //Animation brute sans suivi, juste avec une formule
   //drawBall(i, PI + (i * frameCount / 50.0) * cos (frameCount / 500.0) );
   }*/  // A COMPRENDRE

  if (frameCount > nbMaxDelais/10 && firstFollowingLast == true && abs(diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais])) < deltaFollow ) {
    colorMode(RGB, 255, 255, 255);
    fill( 0, 0, 255 );
    println("diffangle" + ": " + diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais]));
    //    firstFollowingStarted = true;
    debug ="First follow last";
    //   firstFollowingLast = false;
    println (debug);
  }

  if (firstFollowingStarted) {
    colorMode(RGB, 255, 255, 255);
    fill( 255, 0, 0 );
    debug ="firstFollowingStarted";
    follow(nbBall-1, 0, d, k);  // Modifier les deux derniers paramètres : délais et phase
    drawBall(0, phases[0][frameCount % nbMaxDelais]);
    //   println ("PHASE MAPPED firstFollowing ");
    //   println("diffangle" + ": " + diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais]));
  }

  arduinoPosJO();
}  

 public void serialEvent(Serial DueSerialNativeUSBport101) { // receive 2 datas splited with , and the last is send with println

  // read the serial buffer:
  String myString = DueSerialNativeUSBport101.readStringUntil('\n');

  // if you got any bytes other than the linefeed:
  myString = trim(myString);

  // split the string at the commas
  // and convert the sections into integers:
  int values[] = PApplet.parseInt(split(myString, ','));

  if (values.length > 0) {// v1 de 0 a 4000
int v1; int v2; int v3; int v4; int v5; int v6;

    v1 = (int) map (values[0], 0, 4000, 0, 400);
     v2 = (int) map (values[0], 0, 4000, 0, 400);
      v3 = (int) map (values[0], 0, 4000, 0, 400);
       v4 = (int) map (values[0], 0, 4000, 0, 400);
        v5 = (int) map (values[0], 0, 4000, 0, 400);
         v6 = (int) map (values[0], 0, 4000, 0, 400);
       
    println (" v1 " + v1 ); println (" v1 " + v1 ); println (" v1 " + v1 ); println (" v1 " + v1 ); print (mouseY);   print (" v1 ");   println (v1);  
}
}

 public void samplingMovement(float timeSec) {
  
    keyReleasedfollowSignal(); // useless here, but if you sample with a decay of 100ms, each oscillator will have the movement of 11 each new cycle of 11
    frameSampling=frameSampling+1;
    Timer= (millis()%1000*timeSec)*restartTimer;
    Timer2 = (millis()%2000*timeSec)*restartTimer;
     print ("             Timer  "); print (Timer);
     print ("             Timer2  "); print ( Timer2);
     print ("             frameSampling160  "); print ( frameSampling%(num*timeSec)); // each x frameSampling record new datas
    int i = PApplet.parseInt(frameSampling%(num*timeSec)); // datas record from 0 to 40*number of secondes
    
    if(frameSampling>=0 && frameSampling<=num*timeSec  ) // && lastSec==actualSec
    {
    if(frameSampling<=0) { 
     int timeElapsed= endTime-beginTime; 
     print (" timeElapsed"); println (timeElapsed);
     beginTime=millis();
     background(255);     
    } 
    if(frameSampling>=1 && frameSampling<=num*timeSec )  //&& Timer<=100 && Timer2<=100
    {
//    rx[i] = mouseX;
//    ry[i] = mouseY;
 //**   net.phase[networkSize-1]= (float) map (v1, 0, 400, 0, TWO_PI);
    net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
    rx[i] = z;
 //   ry[i] = v1;
     ry[i]=net.phase[networkSize-1]+phaseShiftingFollowPhase11;//almost useless
    mx[i] = rx[i];
    my[i] = ry[i];
    fill(255, 0, 0, 50); 
 //     net.phase[networkSize-1]= (float) map (v1, 0, mouseY, 0, TWO_PI);

 //**   net.phase[2]= (float) map (v1, 0, 400, 0, TWO_PI);
    circle(rx[i], ry[i], 10); 
    }    
   }  
   
    int middleTime = millis(); 
    int TimeMiddleElapsed = middleTime -beginTime;
    
    if ( (frameSampling >=num*timeSec+1 && frameSampling <=num*timeSec+1)) { //|| TimeMiddleElapsed >=1970 && TimeMiddleElapsed <=2030 || 
       LastTimeMiddleElapsed=TimeMiddleElapsed;
       print (frameSampling); print ("  TimeMiddleElapsed "); println ( TimeMiddleElapsed);
       } 
     
    if(frameSampling>=num*timeSec+1  ) // begin to replay for 2 sec
    {
      trigFollowSampling=true;
     
 //**   net.phase[networkSize-1]= (float) map (my[i], 0, 400, 0, TWO_PI);
       net.phase[networkSize-1]= my[i];
 //¨**    net.phase[networkSize-2]= (float) map (my[i], 0, 400, 0, TWO_PI)+k; // you have sampled oscillator2 and repeat it in oscillator 3 with decay
//  
       net.phase[networkSize-2]= my[i]+delayTimeFollowPhase11; // useless
       net.phase[networkSize-2]= net.phase[networkSize-2]%TWO_PI;
    circle(mx[i]+400, my[i], 10); 
  //  print (frameSampling); print (" ry' "); print (i); print ("  "); println (ry[i]);
    print (" frameSampling "); print (frameSampling); print (" ry "); print (i); print ("  "); print (ry[i]);   // frameSampling%160=1 is the first point and  frameSampling%160=0 is the last point recorded
    print (" my "); print (i); print ("  "); println (my[i]);
    } 
  
   // if(frameSampling>=2*20*4+1 && frameSampling<=2*20*4+1  ) //
    if(frameSampling%(2*num*timeSec)<=0  ) //
    {

    endTime=millis();
    int timeElapsed= endTime-beginTime; 
    LastTimeElapsed= timeElapsed;
     print (" LastTimeElapsed"); println (LastTimeElapsed);
 //   Timer=0;
 //   Timer2=0;
 //   frameSampling=80;
    restartTimer=0;//useless for the moment
    background(255);
    }
    if (mousePressed==true){
        mouseRecorded=true;} 
        
    if (mouseRecorded==true  && frameSampling%(2*num*timeSec+0)<=0 
     ) {
       print (" Restart Record ");  print (" Restart Record ");  println (" Restart Record ");
    mouseRecorded=false;
    frameSampling = 0; // Restart main loop
    restartTimer=1;  //useless for the moment
    trigFollowSampling=false;
     }      
}



 

 public void sendToTeensy() {
  int turnOnDriverNetPhase11=1; //it has to be more than 2 to turn on the driver in the Teensy

  String dataMarkedToTeensyJoGood  ="<" // BPM9   

   // +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
   // +   DataToDueCircularVirtualPosition[6]+","+( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

   // +  (speedDelta) + "," + turnOnDriverNetPhase11 + "," +3+","+decompte[8]+","+decompte[7]+","+decompte[6]+","+decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

    +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">"; //    cohesionCounterHigh // +orderCohesion+ ">";LevelCohesionToSend ","+ int (map ( LowLevelCohesionToSend, 0, 1, 0, 100))+ 


  if ( abs (speedi[networkSize-1]) > 950 || abs (speedi[0]) > 950) {
    //   key = 'h'; keyReleased();
    textSize (200);
    text("CAREFULL", width/2, height - 20);
  }

  println(frameCount + ": " +  " dataMarkedToTeensyJoGood" + ( dataMarkedToTeensyJoGood ));
  teensyport.write(dataMarkedToTeensyJoGood); // Send data to Teensy. only the movement
}

 public void sendToTeensyTurnOnDriver() {
  int turnOnDriverNetPhase11=3; //it has to be more than 2 to turn on the driver in the Teensy

  String dataMarkedToTeensyJoGood  ="<" // BPM9   

   // +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
   // +   DataToDueCircularVirtualPosition[6]+","
    
    +( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

    +  (speedDelta) + "," + turnOnDriverNetPhase11 + "," +3+","
    
    //+decompte[8]+","+decompte[7]+","+decompte[6]+","+decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

    +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">"; //    cohesionCounterHigh // +orderCohesion+ ">";LevelCohesionToSend ","+ int (map ( LowLevelCohesionToSend, 0, 1, 0, 100))+ 



  println(frameCount + ": " +  " dataMarkedToTeensyJoGood" + ( dataMarkedToTeensyJoGood ));
  teensyport.write(dataMarkedToTeensyJoGood); // Send data to Teensy. only the movement
}

 public void samplingMovementPro() {
   // currTime = millis() * 0.001;  // seconds since app started
   if( bRecording ) {
    circle( mouseX, mouseY, 10 );
    sampler.addSample( mouseX, mouseY );

  print (" 679 SEC  mouse Y REC " );  print (mouseY);  print (" v1 REC " );  print (v1);
  print (" 679 SEC  mouse Y REC " );  print (mouseY);  print (" v1 REC " );  println (v1);
 
  //**   samplers.get(samplers.size()-1).addSample( currTime, mouseX, v1InMainLoop );
 mouseY= constrain ( mouseY, 0, 400);
 net.phase[networkSize-1]=  map (mouseY, 0, height/2, 0, TWO_PI);
// net.phase[networkSize-1] = constrain (net.phase[networkSize-1], 0, TWO_PI);
  }
 else {
    if( sampler.fullTime() > 0 )
        sampler.draw();
  }
}

 public void activeSamplingSecond() { 
   if (actualSec<=0 && actualSec!=lastSec && mouseRecorded == true) {
  bRecording = true;
 //*** samplers.add( new Sampler( nextSamplePeriod, currTime, mouseX, mouseY ) );
  net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
  
  
}
}


 public void activeSamplingMeasure(int beginMeasure) {    
  if (measure<=beginMeasure && measure>=beginMeasure && beatTrigged == true && mouseRecorded == true){  
    println (" BEGINTRACK ");      println (" BEGINTRACK ");        println (" BEGINTRACK ");
     net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
  bRecording = true; 
  sampler.beginRecording();
   print (" 12689 MEA  mouse Y rec " );  println (mouseY); 
  }
}
 public void stopSamplingMeasure(int endMeasure) { 
    
   if (measure<=endMeasure && measure>=endMeasure  && beatTrigged == true) {
     println (" ENDTRACK ");     println (" ENDTRACK ");       println (" ENDTRACK ");
      net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
  mouseRecorded = false;
  bRecording = false;
  sampler.beginPlaying();
  }
}
 public void activeSamplingInternalClock(int beginMeasure) { 
   if (measure<=beginMeasure && measure>=beginMeasure && actualSec!=lastSec && mouseRecorded == true) {

        net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
  bRecording = true;
  sampler.beginRecording();
  }
}
 public void stopSamplingInternalClock(int endMeasure) { 
   if (measure<=endMeasure && measure>=endMeasure && actualSec!=lastSec) {

        net.phase[networkSize-1]= (float) map (mouseY, 0, 400, 0, TWO_PI);
  mouseRecorded = false;
  bRecording = false;

  sampler.beginPlaying();
  }
}

 

 public void followDistribueAddLfoPatternOriginal(){
   lfoPattern();
  
  
   for (int i = 0; i <  networkSize-0; i+=1) {// networkSize-0
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
    phaseMapped[i]= map (signal[2], 0, 1, 0, TWO_PI); // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy  lfoPhase[2]
//    phaseMapped[i]= lfoPhase[2];
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
  for (int i = 0; i < (networkSize-0); i+=1){
    print (" degrees "); print (i);  print (" "); println (degrees (net.phase[i]));
 }
 
 
 
 //**** AddABleton  
//  if (formerFormerKey == '#'  || formerKeyMetro == '$'  || formerKeyMetro == '*' ||  formerKeyMetro == '@') { // || formerKeyMetro == '*'
  /* 
      for (int i = 2; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
 */
 
 // add ableton to follow
  /*   
    for (int i = 2; i < 3; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[10], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
      print ("  ableton[10]  ");    println ( ableton[10]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
  
     for (int i = 3; i < 4; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[9], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
      print ("  ableton[9]  ");    println ( ableton[9]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 */
 
   for (int i = 0; i < networkSize; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
  //****   phaseMappedFollow[i]=   map (ableton[0], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i] + phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
      print ("  ableton[networkSize-1]  ");    println ( ableton[networkSize-1]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
 // phasePatternToFollow only when a key is pressed

     if (formerFormerKey != '#'  ) {
       
       phasePattern();
            
    for (int i = 0; i < networkSize; i+=1) { 
      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = net.phase[i];
    phaseMapped[i] =  phaseMapped[i] + phasePatternFollow[i]; // phaseMapped[i] +  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
 } 
//END phasePatternToFollow only when a key is pressed
 

  
  


  
  sendToTeensyTurnOnDriver();
// }  
} 

 public void followDistribueAddLfoPatternControl(){
  
  // ***lfoPattern();
   for (int i = 2; i <  networkSize-0; i+=1) {// networkSize-0
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
    phaseMapped[i]= map (signal[2], 0, 1, 0, TWO_PI); // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy  lfoPhase[2]
//    phaseMapped[i]= lfoPhase[2];
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
  for (int i = 2; i < (networkSize-0); i+=1){
    print (" degrees "); print (i);  print (" "); println (degrees (net.phase[i]));
 }
   
  if (formerFormerKey == '#'  || formerKeyMetro == '$'  || formerKeyMetro == '*' ||  formerKeyMetro == '@') { // || formerKeyMetro == '*'
    
      for (int i = 2; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
 
 
 
 
// add ableton to follow
/*     
    for (int i = 2; i < 3; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[10], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
      print ("  ableton[10]  ");    println ( ableton[10]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
  
     for (int i = 3; i < 4; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[9], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
      print ("  ableton[9]  ");    println ( ableton[9]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
   for (int i = 4; i < 12; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[0], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
      print ("  ableton[9]  ");    println ( ableton[9]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 */  
  // phasePatternToFollow only when a key is pressed

 //    if (formerFormerKey != '#'  ) {
   
    if (Key != '#'  ) {
       
       phasePattern();
            
    for (int i = 2; i < networkSize; i+=1) { 
      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = net.phase[i];
    phaseMapped[i] = phaseMapped[i] + phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }

 } 
//END AddphasePatternToFollow only when a key is pressed

// Begin take off phase after 1000 ms
  
/*
       if (millis()>=controlTrigLfoPattern+2000  ) { // controlTrigLfoPattern
    
       println ("  controlTrigLfoPatternIN  ", controlTrigLfoPattern);
    
    phasePattern();
            
    for (int i = 2; i < networkSize; i+=1) { 
//      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = phaseMapped[i];
    phaseMapped[i] = phaseMapped[i] - phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
//      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
}  
*/ 
  sendToTeensyTurnOnDriver();
 }  
} 


 public void followDistribueAddphasePattern(){
   for (int i = 2; i <  networkSize-0; i+=1) {// networkSize-0
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
    phaseMapped[i]= map (signal[2], 0, 1, 0, TWO_PI);; // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy
 
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
  for (int i = 2; i < (networkSize-0); i+=1){
    print (" degrees "); print (i);  print (" "); println (degrees (net.phase[i]));
 }
   
  if (formerFormerKey == '#'  || formerKeyMetro == '*'  || formerKeyMetro == '*' ) { // || formerKeyMetro == '*'
    
      for (int i = 2; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
   
 
    if (formerFormerKey != '#' ) {
 //   if (formerKeyMetro == '*' ) {
     phasePattern();
     
    for (int i = 2; i < networkSize-0; i+=1) { 
      print ("  BEF phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
    phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] =  phaseMapped[i]+phaseMappedFollow[i];  // add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
       net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);


//   }
  }
 }
 
 
  sendToTeensyTurnOnDriver();
  }  
    } 

     
 public void followDirectLfo(){    
  println (" PatternFollowLfo() ");
     
    lfoPattern();
  //  LFO[0]= lfoPhase[2];
 
    splitTimeLfo();
   //  splitWithTime();
                
   if (key=='q' || key=='a') {
     letter = key;
    
     }
  switch(letter) {
    case 'a': 
    doA=true;
    doQ=false;
    println("Alpha");  // Does not execute
    break;
    case 'q': 
    doA=false;
    doQ=true;
    println("qqqqq");  // Does not execute
    break;
     
    }
    
  if (formerFormerKey == '#') { //  && doA==true
     lfoPattern();
      for (int i = 2; i < networkSize-0; i+=1) { 
      print ( " LFO  == '#' "); println (LFO[i]);   
      LFO[i]= lfoPhase[1];
    //  LFO[i]= 0;
   }
   }
   
   if (formerFormerKey == '#') {
     
   if (LFO[oscillatorChange]<0){   // movement drawn by myself      
    LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]-LFO[oscillatorChange]; 
    
    dataToChange[oscillatorChange]= PApplet.parseInt (map (LFO[oscillatorChange], 0, -TWO_PI, numberOfStep, 0)); 
    //**    net.oldPhase[i]=net.phase[i];
   // oldPosF[oscillatorChange]=newPosF[oscillatorChange];
   
    //**    net.phase[i]= map (dataToChange[i], numberOfStep, 0, 0, -TWO_PI);
    newPosF[oscillatorChange]= LFO[oscillatorChange]; //map (dataToChange[oscillatorChange], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else
    LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]+LFO[oscillatorChange];
    LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;
     
    dataToChange[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI, 0, numberOfStep);
    //   net.oldPhase[i]=net.phase[i];
  //  oldPosF[oscillatorChange]=newPosF[oscillatorChange];
   //  net.phase[i]= map (dataToChange[i], 0, numberOfStep, 0, TWO_PI);
    newPosF[oscillatorChange]= LFO[oscillatorChange]; // map (dataToChange[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
  
 }
   
   
   if (formerKey != '#' ) { //  play this command once when you tap on keyboard expect #
    if (doA==true ){ // offset with pendularPattern  || doQ==true
     phasePattern(); // change offset between ball with pendularPattern
     lfoPattern();
   for (int i = 2; i < networkSize-0; i+=1) { 
   
  //  newPosF[i]= net.phase[i];
 //**   newPosF[i]= lfoPhase[1];
  //****  phaseFollowLFO[i]= newPosF[i];

     LFO[i]= lfoPhase[1];
      } 
      
     phaseFollowLFO[oscillatorChange]= lfoPhase[2];
     print ("  case a phaseFollowLFO  ");  print ( oscillatorChange  ); print ( " ");  print ( phaseFollowLFO[oscillatorChange]  ) ; println (   ); 
 //   LFO[i]=0;

//    LFO[oscillatorChange] =  LFO[oscillatorChange]+phaseFollowLFO[oscillatorChange];  // add offset given by pendularPattern
//    LFO[oscillatorChange] =  LFO[oscillatorChange]%TWO_PI; 

    for (int i = 2; i < networkSize-0; i+=1) { 
      
   if (LFO[i]<0){
   
    dataToChange[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 
  //  oldPosF[i]=newPosF[i];
    newPosF[i]=LFO[i];//dataToChange[i];
 //   DataToDueCircularVirtualPosition[i]= (int) newPosF[i];
       }
       
   else
    
    dataToChange[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep); 
 //   oldPosF[i]=newPosF[i];
    newPosF[i]=LFO[i];//dataToChange[i];
 //   DataToDueCircularVirtualPosition[i]= (int) newPosF[i];
       } // 
       
      
       
        key='#';// key='a'; // formerFormerKey = '#';
   //    doA=false;
   //    doQ=true;
   }
   
   }
   /*
  for (int i = 2; i < networkSize; i++) { 
    oldDataToChange[i]= dataToChange[i];
    deltaDataToChange[i]= dataToChange[i]-oldDataToChange[i];
    DataToDueCircularVirtualPosition[i]= (int) dataToChange[i];// newPosF[i];
   }  
 */
  
      countRevsContinue();
      
    for (int i = 2; i < networkSize; i++) {
     
     oldPosF[i]=newPosF[i];

      //*******************************  ASSIGN MOTOR WITH POSITION

      if (rev[i]!=0  && (newPosF[i] >  0) ) { // number of revolution is even and rotation is clock wise   
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep))+ (rev[i]*numberOfStep);
      }

      if (rev[i]!=0  && (newPosF[i] <  0)) { // number of revolution is even and rotation is Counter clock wise          // pos[i]= int (map (net.phase[i], 0, -TWO_PI, 0,  numberOfStep))+ (rev[i]*numberOfStep);
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0)) +(rev[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (rev[i]==0 && (newPosF[i] < 0) ) { //  number of revolution is 0 and rotation is counter clock wise 
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0));        
      }         
      if (rev[i]==0 && (newPosF[i] > 0) ) {  //  number of revolution is 0 and rotation is clock wise     
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW rev=0 ");println (pos[i]);
      }
      DataToDueCircularVirtualPosition[i]= (int) pos[i];
            
    }
    
 
  

    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

    //  +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
    //  +   DataToDueCircularVirtualPosition[6]+","+( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

   //   +  (speedDelta) +","+ driverOnOff +","+decompte[9]+","+decompte[8]+","+decompte[7]+","+decompte[6]+","+decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

      +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">";    

    println(frameCount + ": " +  " dataMarkedToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
   //  DueSerialNativeUSBport101.write(dataMarkedToTeensyNoJo );// Send data to Arduino.
    teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
 
 } 

 
  public void countRevsContinue() { // =========================================== AJOUTE un case dans tableau networkSize+1

  for (int i = 0; i < networkSize; i++) { 
//**    print (net.oldPhase[i]); print ("count rev ");   println (net.phase[i]); 
    // decrement caused by negative angular velocity
    // both positive angles || both negative angles || positive-to-negative angle
    //   if (//(net.oldPhase[i] < 0.25 * PI && net.phase[i] > 1.75 * PI) ||//
    if (
      ((oldPosF[i] < 0.25f *PI && oldPosF[i]>0)  && (newPosF[i] > -0.25f* PI && newPosF[i] <0))  || 
       (oldPosF[i] < -1.75f * PI && newPosF[i] > -0.25f * PI)// ||
    
      ) {
    
      //    TrigmodPos[i]=0;
      rev[i]--;
      //      print (" revultion negative  "); println (revolution[i]=i+1);
      //   revolution[i]=i+1;
     revolution[i]=0; // trig 0 to sent 0 in Max4Live
      memoryi=i;


   //   decompte[i] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
    } else { // if you do twice there is a funny bug
      //    decompte[i]  ++; 
      //   revolution[i]=0;
    }


    // increment caused by positive angular velocity
    // both positive angles || both negative angles || negative-to-positive angle

    if (
      ((oldPosF[i] > -0.25f *PI && oldPosF[i]<0)  && (newPosF[i] < 0.25f* PI && newPosF[i] >0))  || 
       (oldPosF[i] > 1.75f * PI && newPosF[i] < 0.25f*PI)
      ) {
      onOFF = 1;
      //   TrigmodPos[i]=0;
      rev[i]++;
      //   revolution[i]=i+1;
      revolution[i]=0;   // trig 0 to sent 0 in Max4Live
      memoryi=i;
      decompte[i] = 0;  // RESET COUNTER AT 0
    } else {

      decompte[i]  ++; //START COUNTER when a REVOLUTION START OR FINISH

      revolution[i]=1;
    }
     if (  revolution[i]<1) {
   print (" revolution[i] "); print ( memoryi); print ("  "); print (revolution[memoryi]);
    }
  
  //  print (" rev< "); print ( i); print ("  "); println (rev[i]);
  }
  if (

   
    (newPosF[memoryi] < -1.75f * PI && newPosF[memoryi] >= -0.25f*TWO_PI) || ( newPosF[memoryi]<=-TWO_PI+0.23f  && newPosF[memoryi] >= -0.25f*TWO_PI ) 
    ) {
    onOFF = 1;
    //   background (27,59,78);
    //    TrigmodPos[i]=0;
    rev[memoryi]--;
    //      print (" revultion negative  "); println (revolution[i]=i+1);
    //   revolution[i]=i+1;
//**** revolution[memoryi]=0; // trig 0 to sent 0 in Max4Live   brecause it count twice in negative way!!!
    // memoryi=i;


    decompte[memoryi] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
  }
 
} 

 public void addSignal(){
  
    println (" pattern lfoPhase[1] ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3] ", lfoPhase[3]); 
   
   if (key=='q' || key=='b') {
     letter = key;   
     }
  switch(letter) {
    case 'q': 
    doQ=true;
    break;
    case 'b': 
    doQ=false;
    break;     
    }
  
   if (formerFormerKey == '#') { //  && doA==true
     print ("  normal " + frameCount + " lfoPhase[1] " + lfoPhase[1] + " lfoPhase[2] " + lfoPhase[2]);    println (   ); 
      for (int i = 2; i <  networkSize+1; i+=1) { 
       LFO[i] = lfoPhase[1]; 
   if (LFO[i]<0){        
       LFO[i] = phaseFollowLFO[i] -  LFO[i];
       dataMappedForMotor[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 

       newPosX[i]= map (dataMappedForMotor[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else
       LFO[i] = phaseFollowLFO[i] +  LFO[i];
       dataMappedForMotor[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep);

       newPosX[i]= map (dataMappedForMotor[i], 0, numberOfStep, 0, TWO_PI);
 
   }
  
   if (LFO[oscillatorChange]<0){        
       LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]-LFO[oscillatorChange]; 
       dataMappedForMotor[oscillatorChange]= PApplet.parseInt (map (LFO[oscillatorChange], 0, -TWO_PI, numberOfStep, 0)); 

       newPosX[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else
       LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]+LFO[oscillatorChange];
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI, 0, numberOfStep);

       newPosX[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
  }
 
   if (doQ==true ){
  //   phasePattern(); // offset with lfo oscillator by osillator
    print ("  case q phaseFollowLFO " + oscillatorChange + " "  + phaseFollowLFO[oscillatorChange] + " "); print ("  LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  print (LFO[oscillatorChange]  ); 
    print (" newPosX[oscillatorChange] " + newPosX[oscillatorChange]);
    for (int i = 2; i <  networkSize-0; i+=1) { 
   
   //int i = oscillatorChange;
   //  phaseFollowLFO[oscillatorChange]= PI/10*-oscillatorChange; // to understand
     phaseFollowLFO[oscillatorChange]= lfoPhase[2];
     LFO[oscillatorChange]=  LFO[i]+phaseFollowLFO[i];  // add offset given by pendularPattern
     LFO[oscillatorChange]=  LFO[i]; 
  
   
    if (LFO[i]<0){
   
     dataMappedForMotor[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 

       newPosX[oscillatorChange]= map (dataMappedForMotor[i], numberOfStep, 0, 0, -TWO_PI);
  //   newPosX[i]= LFO[i];
       }
       
   else
    
    dataMappedForMotor[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep);  
    
    newPosX[oscillatorChange]= map (dataMappedForMotor[i], 0, numberOfStep, 0, TWO_PI);
    
     } //
 
   }
    print ("  LFO+LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  println (LFO[oscillatorChange]  ); 
   
  key='#';// 

     for (int i = 2; i <  networkSize+0; i+=1) { // la premiere celle du fond i=2,  la derniere celle du devant i=11
    drawBall(i, newPosX[i] );

   
    print( " oldPositionToMotor[i]" ); print ( oldPositionToMotor[i]);
    positionToMotor[i]= ((int) map (newPosX[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //
    
    
    newPosF[i]=positionToMotor[i]%6400;
 //   if (oldPositionToMotor[i]>positionToMotor[i]){
    if ( oldPosF[i]>newPosF[i]){
      revLfo[i]++;
     
    } 
     oldPositionToMotor[i]=  positionToMotor[i];
     oldPosF[i]=newPosF[i];

     print( " newPosF[i] " ); print ( newPosF[i]);
     print( " positionToMotor[i] " ); print ( positionToMotor[i]);
     print (" revolutionLFO "); print ( i); print ("  "); println (revLfo[i]); 
  }
  
   if (formerKeyMetro=='B') {
         for (int i = 0; i < networkSize; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (revLfo[i]!=0  && (newPosF[i] >  0) ) { // number of revLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (newPosF[i], 0, numberOfStep, 0, numberOfStep))+ (revLfo[i]*numberOfStep);
      }

      if (revLfo[i]!=0  && (newPosF[i] <  0)) { // number of revLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (newPosF[i], 0, -numberOfStep, 0,  numberOfStep))+ (revLfo[i]*numberOfStep);

        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (newPosF[i], 0, -numberOfStep, numberOfStep, 0)) +(revLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (revLfo[i]==0 && (newPosF[i] < 0) ) { //  number of revLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (newPosF[i], 0, -numberOfStep, numberOfStep, 0));        
      }         
      if  (revLfo[i]==0 && (newPosF[i] > 0) ) {  //  number of revLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (newPosF[i], 0, numberOfStep, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW revLfo=0 ");println (pos[i]);
      }
    }
  } 
     
    int speedLocalDelta=4; 
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

      +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+(DataToDueCircularVirtualPosition[9])+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
      +   DataToDueCircularVirtualPosition[6]+","+( DataToDueCircularVirtualPosition[5])+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

    //  +  (speedDelta) +
     +  speedLocalDelta +
      
      ","+ driverOnOff +","+dataToTeensyNoJo+","+decompte[8]+","+decompte[7]+","+decompte[6]+","+decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

      +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">";    

    println(frameCount + ": " +  " dataMarkedToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
    //   DueSerialNativeUSBport101.write(dataMarkedToDue36data);// Send data to Arduino.
    teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
  }
  
 public void countRevsLfoPattern11() { // =========================================== Ter NE PAS TOUCHER LE COMPTEUR ou Reduire l'espace avant et apres 0 pour eviter bug à grande vitesse

  for (int i = 1; i < 2; i++) { 
     print (" oldLfoCount[i] "); print (i); print (" ");  println (oldPhaseLfo[i]); print (" newPhaseLfoCount[i] ");; print (i); print (" ");    println (newPhaseLfo[i]); 
//**    print (net.oldPhase[i]); print ("count rev ");   println (net.phase[i]); 
    // decrement caused by negative angular velocity
    // both positive angles || both negative angles || positive-to-negative angle
    //   if (//(net.oldPhase[i] < 0.25 * PI && net.phase[i] > 1.75 * PI) ||//
    if (
      ((oldPhaseLfo[i] < 0.25f *PI && oldPhaseLfo[i]>0)  && (newPhaseLfo[i] > -0.25f* PI && newPhaseLfo[i] <0))  || 
       (oldPhaseLfo[i] < -1.75f * PI && newPhaseLfo[i] > -0.25f * PI)// ||
       
    
      ) {
    
      //    TrigmodPos[i]=0;
      revLfo[i]--;
      //      print (" revultion negative  "); println (revolution[i]=i+1); 
      //   revolution[i]=i+1;
     revolution[i]=0; // trig 0 to sent 0 in Max4Live
      memoryi=i;


   //   decompte[i] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
    } else { // if you do twice there is a funny bug
      //    decompte[i]  ++; 
      //   revolution[i]=0;
    }


    // increment caused by positive angular velocity
    // both positive angles || both negative angles || negative-to-positive angle

    if (
      ((oldPhaseLfo[i] > -0.25f *PI && oldPhaseLfo[i]<0)  && (newPhaseLfo[i] < 0.25f* PI && newPhaseLfo[i] >0))  || 
       (oldPhaseLfo[i] > 1.75f * PI && newPhaseLfo[i] < 0.25f*PI)
      ) {
      onOFF = 1;
      //   TrigmodPos[i]=0;
      revLfo[i]++;
      //   revolution[i]=i+1;
      revolution[i]=0;   // trig 0 to sent 0 in Max4Live
      memoryi=i;
      decompte[i] = 0;  // RESET COUNTER AT 0
    } else {

      decompte[i]  ++; //START COUNTER when a REVOLUTION START OR FINISH

      revolution[i]=1;
    }
     if (  revolution[i]<1) {
   print (" revolutionPattern[i] "); print ( memoryi); print ("  "); print (revolution[memoryi]);
    }
  
    print (" revPattern "); print ( i); print ("  "); println (revLfo[i]);
  }
  if (

   
    (newPhaseLfo[memoryi] < -1.75f * PI && newPhaseLfo[memoryi] >= -0.25f*TWO_PI) || ( newPhaseLfo[memoryi]<=-TWO_PI+0.23f  && newPhaseLfo[memoryi] >= -0.25f*TWO_PI ) 
    ) {
    onOFF = 1;
    //   background (27,59,78);
    //    TrigmodPos[i]=0;
    rev[memoryi]--;
    //      print (" revultion negative  "); println (revolution[i]=i+1);
    //   revolution[i]=i+1;
//**** revolution[memoryi]=0; // trig 0 to sent 0 in Max4Live   brecause it count twice in negative way!!!
    // memoryi=i;


    decompte[memoryi] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
  }
 
}

 public void countRevsLfoPattern22() { // =========================================== Ter NE PAS TOUCHER LE COMPTEUR ou Reduire l'espace avant et apres 0 pour eviter bug à grande vitesse

  for (int i = 2; i < 3; i++) { 
     print (" oldLfoCount[i] "); print (i); print (" ");  println (oldPhaseLfo[i]); print (" newPhaseLfoCount[i] ");; print (i); print (" ");    println (newPhaseLfo[i]); 
//**    print (net.oldPhase[i]); print ("count rev ");   println (net.phase[i]); 
    // decrement caused by negative angular velocity
    // both positive angles || both negative angles || positive-to-negative angle
    //   if (//(net.oldPhase[i] < 0.25 * PI && net.phase[i] > 1.75 * PI) ||//
    if (
      ((oldPhaseLfo[i] < 0.25f *PI && oldPhaseLfo[i]>0)  && (newPhaseLfo[i] > -0.25f* PI && newPhaseLfo[i] <0))  || 
       (oldPhaseLfo[i] < -1.75f * PI && newPhaseLfo[i] > -0.25f * PI)// ||
       
    
      ) {
    
      //    TrigmodPos[i]=0;
      revLfo[i]--;
      //      print (" revultion negative  "); println (revolution[i]=i+1);
      //   revolution[i]=i+1;
     revolution[i]=0; // trig 0 to sent 0 in Max4Live
      memoryi=i;


   //   decompte[i] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
    } else { // if you do twice there is a funny bug
      //    decompte[i]  ++; 
      //   revolution[i]=0;
    }


    // increment caused by positive angular velocity
    // both positive angles || both negative angles || negative-to-positive angle

    if (
      ((oldPhaseLfo[i] > -0.25f *PI && oldPhaseLfo[i]<0)  && (newPhaseLfo[i] < 0.25f* PI && newPhaseLfo[i] >0))  || 
       (oldPhaseLfo[i] > 1.75f * PI && newPhaseLfo[i] < 0.25f*PI)
      ) {
      onOFF = 1;
      //   TrigmodPos[i]=0;
      revLfo[i]++;
      //   revolution[i]=i+1;
      revolution[i]=0;   // trig 0 to sent 0 in Max4Live
      memoryi=i;
      decompte[i] = 0;  // RESET COUNTER AT 0
    } else {

      decompte[i]  ++; //START COUNTER when a REVOLUTION START OR FINISH

      revolution[i]=1;
    }
     if (  revolution[i]<1) {
   print (" revolutionPattern[i] "); print ( memoryi); print ("  "); print (revolution[memoryi]);
    }
  
    print (" revPattern "); print ( i); print ("  "); println (revLfo[i]);
  }
  if (

   
    (newPhaseLfo[memoryi] < -1.75f * PI && newPhaseLfo[memoryi] >= -0.25f*TWO_PI) || ( newPhaseLfo[memoryi]<=-TWO_PI+0.23f  && newPhaseLfo[memoryi] >= -0.25f*TWO_PI ) 
    ) {
    onOFF = 1;
    //   background (27,59,78);
    //    TrigmodPos[i]=0;
    rev[memoryi]--;
    //      print (" revultion negative  "); println (revolution[i]=i+1);
    //   revolution[i]=i+1;
//**** revolution[memoryi]=0; // trig 0 to sent 0 in Max4Live   brecause it count twice in negative way!!!
    // memoryi=i;


    decompte[memoryi] = -1; // // RESET COUNTER AT 0 (i know it's strange, otherwise with 0 it begin at 1, not 0)
  }
 
}
 public void addSignalOneAndTwoBis(){
 //   print (formerKeyMetro);
 //   signal2 continue
 //   signal to split sinus
  // lfoPattern(); // if ive is not open  //lfoPattern(); // if Live is not open
    // if you dob't use this, uncomment signal2 in addSignalLfoPattern()
  signal[2] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;

     text ("Change mode q, z, or b ", -width-200, -height- 600 );
     text ("signal2 " + signal[2] +  "signal3 " + signal[3], -width-200, -height- 500 );
     text (" signalToSplit " +     signalToSplit + " timeLFO " + timeLfo,  -width-200, -height- 400 );
     text ( " propagationSpeed " + propagationSpeed + " oscillatorChange " + oscillatorChange, -width-200, -height- 300 );
     text (" oscillatorChange " + oscillatorChange + " oscillatorChanging " + phaseKeptAtChange[oscillatorChanging], -width-200, -height- 200 );


    
   if (key=='q' || key=='b' || key=='z' ) { // q == addsignal
     letter = key;   
     }
     
  switch(letter) {
    case 'q': 
    doQ=true;
    doZ=false;
    break;
    case 'b': 
    doQ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    doQ=true;
    break;
    }
 

  splitTimeLfoBis(); 
 
// splitTimeLfoWithAbletonBis(); 
// splitTimeWithAbletonNoteBis(); 
    
  addSignalLfoPatternBis(); 
 
 formerFormerKey= formerKey;   
 formerKey=key;
 }
 
  public void addSignalLfoPatternBis()  {
    if (doQ==true ){ // useless in this mode, instead modulate space between phase kept and new phase
  //   pendularPattern(); // offset with lfo oscillator by osillator
  //  phaseFollowLFO[oscillatorChange]= map (signal[2], 0, 1, 0, TWO_PI);    
   }

   if (formerFormerKey  != '#' ) { //  != '#'
     print ("  normal " + frameCount + " lfoPhase[1] " + lfoPhase[1] + " lfoPhase[2] " + lfoPhase[2]);    println (   ); 
       
  int i;
  i= oscillatorChange;
    
  oscillatorChanging= (oscillatorChange-1);
  if (oscillatorChanging<= 0){
  oscillatorChanging= networkSize-1;
  }
 
 //********POURQUOI DIFFERENT AU DEMARRAGE DE lA FONCTION
    signal[2] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;
     
  //   signal[2] = 0.02;
    
   
      LFO[i] =  map (signal[2], 0, 1, 0, TWO_PI);  
      
      
   //    LFO[i] =  map (0.01, 0, 1, 0, TWO_PI);  // CONSTANT

  
    if ( phaseKeptAtChange[oscillatorChanging]<0){   
       LFO[i] =    LFO[i]- phaseKeptAtChange[oscillatorChanging];
       dataMappedForMotor[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 

       newPosXaddSignal[i]= map (dataMappedForMotor[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else { 
       LFO[i] = LFO[i]+ phaseKeptAtChange[oscillatorChanging];

       LFO[i] = LFO[i]%TWO_PI;
       dataMappedForMotor[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep);

       newPosXaddSignal[i]= map (dataMappedForMotor[i], 0, numberOfStep, 0, TWO_PI);
   
    }
  }

    println (" newPosXaddSignal[oscillatorChange] ",  oscillatorChange, " ",  newPosXaddSignal[oscillatorChange] );
  
//     int j;  
//  j= (networkSize-1);
///  if (j<= 0){
//  j= networkSize;
//  }
       
  if (oscillatorChanged==true )  { 

     phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oscillatorChange];    //  RECORD on oscillatorChange-1 the postion of oscillatorChange where it has just changed
  
   }

   //**    LFO[j] = phaseKeptAtChange[j]+PI/(15-j);
       LFO[oscillatorChanging] = phaseKeptAtChange[oscillatorChanging]+QUARTER_PI ;  //les redressent de temps en temps
       LFO[oscillatorChanging] = LFO[oscillatorChanging]%TWO_PI;
       dataMappedForMotor[oscillatorChanging]= (int) map (LFO[oscillatorChanging], 0, TWO_PI, 0, numberOfStep);
       println (" phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oscillatorChange]);
 
       newPosXaddSignal[oscillatorChanging]= map (dataMappedForMotor[oscillatorChanging], 0, numberOfStep, 0, TWO_PI);
       
///////////////////// 
mapDataToMotor();

}
  
 public void  splitTimeLfoBis() {  // signalToSplit = lfoPhase3
 
  lfoPattern();   // signalTosplit come from lfoPattern(). Signal of rotation come from Lfopattern too. Function is at the top 
 
  if (oldSignalToSplit> signalToSplit ) {
  //  key = 'q' ; // when signal goes down --> propagation FRONT SIDE
  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {
//   key = 'z';  //  when signal goes down --> propagation BEHIND SIDE 
//   key = 'q' ;  // propagation in on the same way
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
      
   oldSignalToSplit=signalToSplit;

   
  int splitTimeLfo= PApplet.parseInt  (timeLfo%100);   // 100 is the size of the gate trigging the change of the ball  
   
      println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );

      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );


 if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){
 //     oldMemoryi=memoryi;
 //      memoryi=(memoryi+1);
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
      } 
   //   memoryi=memoryi%12;
      oscillatorChange=oscillatorChange%networkSize;

  }
  
    if (doZ==true){ // case z
//  if (formerDecayTimeLfo>decayTimeLfo){
   if (  oldSplitTimeLfo>splitTimeLfo){
 //   oldMemoryi=memoryi;
 //   memoryi=(memoryi-1);
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {
//        memoryi=11;
//        oldMemoryi=2;
        oscillatorChange=networkSize-1;
   }
  }  
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
   oscillatorChanged=true;
  } 
//   formerDecayTimeLfo = decayTimeLfo;
   oldSplitTimeLfo = splitTimeLfo;
             
}

 public void mapDataToMotor() {

     for (int i = 0; i <  networkSize-0; i+=1) { // la premiere celle du fond i=2,  la derniere celle du devant i=11
 //   drawBall(i, newPosXaddSignal[i] );
  print (" newPosXaddSignalAFTERDB " + newPosXaddSignal[i]);
   
 //    print( " oldPositionToMotor[i]" ); print ( oldPositionToMotor[i]);
  //  positionToMotor[i]= ((int) map (newPosXaddSignal[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //
    positionToMotor[i]= ((int) map (net.phase[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //
    
    newPosF[i]=positionToMotor[i]%6400;
    
    
    net.phase[i]=newPosXaddSignal[i]; // to display to screen
    positionToMotor[i]= positionToMotor[i]%6400;
     TrigmodPos[i]=1;
    
    if ( oldPosF[i]>newPosF[i]){
         revLfo[i]++;
         TrigmodPos[i]=0;
     
    }
  /*  
     if ( oldPosF[i]<newPosF[i]){
         revLfo[i]--;
         TrigmodPos[i]=0;
     
    }
*/
     print (" TrigmodPos[i" , TrigmodPos[i] , " newPosF " + newPosF[i]);
     oldPositionToMotor[i]=  positionToMotor[i];
     oldPosF[i]=newPosF[i];
     oldPosX[i]=newPosF[X];

     print (" revolutionLFO "); print ( i); print ("  "); println (revLfo[i]); 
     
     
     text ("count", -1600, height-500 - 75*i);
     text ( revLfo[i], -1400, height-500 - 75*i);
   
    
     }
     text (" restart ALT Z , cf signal2Bis )", -1600, height-300 );  
     text ( signal[2], -400, height-300);
     oscSend();
     assignMotorWithPosition();
     
    for (int i = 0; i < networkSize; i++) {
   //  DataToDueCircularVirtualPosition[i] = DataToDueCircularVirtualPosition[i]+ recordLastDataOfMotorPosition[i];
   }

   send24DatasToTeensy6motors( 10, 3, -3, -1);
  
}
 public void addSignalOneAndTwoTer() { // inspireé de quater . splitTimeQuater A reconfigurer
//   signal2 continue
 //   signal to split sinus
  // lfoPattern(); // if ive is not open  //lfoPattern(); // if Live is not open
    // if you dob't use this, uncomment signal2 in addSignalLfoPattern()
     textSize (100);
     text ("Change mode q, z, or stop progation with b ", -width-200, -height- 600 );
     text ("signal2 " + signal[2], -width-200, -height- 500 );
 //    text ("signal3 " + signal[3], -width-200, -height- 400 );
     text (" oldSignalToSplit " + oldSplitTime + " splitTime " +  splitTime + " timeLFO " + timeLfo,  -width-200, -height- 400 );
     text (" oldSignalToSplit " + oldSignalToSplit + " signalToSplit " +     signalToSplit + " timeLFO " + timeLfo,  -width-200, -height- 300 );
     text (" oscillatorChange " + oscillatorChange + " oscillatorChanging " + phaseKeptAtChange[oscillatorChanging], -width-200, -height- 200 );
     text (" propagationSpeed " + propagationSpeed + " key " + key + " startZ " + startZ, -width-200, -height- 100 );
      
   if (key=='q' || key=='b' || key=='z' ) { // q == addsignal
     letter = key;   
     }
     
  switch(letter) {
    case 'q': 
    doQ=true;
    doZ=false;
    startZ=false;
    break;
    case 'b': 
    doQ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    doQ=true;
    break;
    }
//*** splitTimeOriginal(10.0); //USELESS with propagation Mode
// splitTimeQuater(30.0); // fonctionne pas

//  splitTimeLfoQuater(); //USELESS with propagation Mode
  splitTimeWithAbletonNoteBis(); // oscillator Change with note from Ableton
 // addSignalLfoPatternQuater(); // devenu fonction ci dessous
  propagationMode();
 
 formerFormerKey= formerKey;   
 formerKey=key;
 }

 public void addSignalOneAndTwoTerOriginal(){
    print (formerKeyMetro);
    
   // lfoPattern();

   if (key=='q' || key=='b' || key=='z' ) { // q == addsignal
     letter = key;   
     }
     
  switch(letter) {
    case 'q': 
    doQ=true;
    doZ=false;
    break;
    case 'b': 
    doQ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    doQ=true;
    break;
    }
    
    
 // splitTimeTer(); 
 splitTimeLfoTer(); 
 // splitTimeLfoWithAbleton(); 
    
 addSignalLfoPatternTer(); 
 
 println(" formerFormerKey " + PApplet.parseChar (formerFormerKey) + " formerKey " + PApplet.parseChar (formerKey) + " key " + key)  ;
 formerFormerKey= formerKey;
 formerKey=key;
 }
 
  public void addSignalLfoPatternTer()  {
   
    if (doQ==true ){
  //   pendularPattern(); // offset with lfo oscillator by osillator
     print ("  case q phaseFollowLFO " + oscillatorChange + " "  + phaseFollowLFO[oscillatorChange] + " ");
     print ("  LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  print (LFO[oscillatorChange]  ); 
     print (" newPosXaddSignal[oscillatorChange] " + newPosXaddSignal[oscillatorChange]);
     
 //    phaseFollowLFO[oscillatorChange]= lfoPhase[2];    
//   phaseFollowLFO[oscillatorChange]= map (signal[2], 0, 1, 0, TWO_PI); 
// phaseFollowLFO[oscillatorChange]= map (0.01, 0, 1, 0, TWO_PI); //   ..DON4T WORK


   }

  
    print ("  LFO+LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  println (LFO[oscillatorChange]  ); 

 if (formerFormerKey  != '#' ) { //  != '#'
     print ("  normal " + frameCount + " lfoPhase[1] " + lfoPhase[1] + " lfoPhase[2] " + lfoPhase[2]);    println (   ); 
       
  int i;
  i= oscillatorChange;
    
  oscillatorChanging= (oscillatorChange-1);
  if (oscillatorChanging<= 0){
  oscillatorChanging= networkSize-1;
  }
 
 //********POURQUOI DIFFERENT AU DEMARRAGE DE lA FONCTION
  //  signal[2] = (0*PI + (frameCount / 30.0) * cos (1000 / 500.0)*-1)%1;  // toujours UP
   // signal[2]=0.09;
   
      LFO[i] =  map (signal[2], 0, 1, 0, TWO_PI);  
      
      
   //    LFO[i] =  map (0.01, 0, 1, 0, TWO_PI);  // CONSTANT

if ( phaseKeptAtChange[oscillatorChanging]<0){   
       LFO[i] =    LFO[i]- phaseKeptAtChange[oscillatorChanging];
       dataMappedForMotor[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 

       newPosXaddSignal[i]= map (dataMappedForMotor[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else { 
       LFO[i] = LFO[i]+ phaseKeptAtChange[oscillatorChanging];

       LFO[i] = LFO[i]%TWO_PI;
       dataMappedForMotor[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep);

       newPosXaddSignal[i]= map (dataMappedForMotor[i], 0, numberOfStep, 0, TWO_PI);
   
    }
 // ABOVE LFO on oscillatorChange
 
    
   if (LFO[oscillatorChange]<0 && phaseFollowLFO[oscillatorChange]<0 ) {        
       LFO[oscillatorChange] =   phaseFollowLFO[oscillatorChange]-LFO[oscillatorChange]; 
       dataMappedForMotor[oscillatorChange]= PApplet.parseInt (map (LFO[oscillatorChange], 0, -TWO_PI, numberOfStep, 0)); 

       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else if (LFO[oscillatorChange]>0 && phaseFollowLFO[oscillatorChange]>0 ) {      
       LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]; // +LFO[oscillatorChange];
       LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI, 0, numberOfStep);

       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
    
    }
    
    
  }

    println (" newPosXaddSignal[oscillatorChange] ",  oscillatorChange, " ",  newPosXaddSignal[oscillatorChange] );
  
     int j;  
  j= (oscillatorChange-1);
  if (j<= 1){
  j= 11;
  }
       
  if (oscillatorChanged==true )  { 

     phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oscillatorChange];    //  RECORD on oscillatorChange-1 the postion of oscillatorChange where it has just changed
  
  
   }

      print (" phaseKeptAtChange[o] ",  oscillatorChange, " ",  phaseKeptAtChange[oscillatorChange] );
      println (" phaseKeptAtChange[j] " , j, " ",  phaseKeptAtChange[j] );
      
 
       LFO[j] = phaseKeptAtChange[j]+0*PI/24 ;  //les redressent de temps en temps
       LFO[j] = LFO[j]%TWO_PI;
       dataMappedForMotor[j]= (int) map (LFO[j], 0, TWO_PI, 0, numberOfStep);
       println (" phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oscillatorChange]);
 
       newPosXaddSignal[j]= map (dataMappedForMotor[j], 0, numberOfStep, 0, TWO_PI);
       

///////////////////// 


}
 
 
  public void assignMotorWithPositionTer() {
  
           for (int i = 0; i < 12; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (revLfo[i]!=0  && (positionToMotor[i] >  0) ) { // number of revLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep))+ (revLfo[i]*numberOfStep);
      }

      if (revLfo[i]!=0  && (positionToMotor[i] <  0)) { // number of revLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (positionToMotor[i], 0, -numberOfStep, 0,  numberOfStep))+ (revLfo[i]*numberOfStep);
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep, numberOfStep, 0)) +(revLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (revLfo[i]==0 && (positionToMotor[i] < 0) ) { //  number of revLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep, numberOfStep, 0));        
      }         
      if  (revLfo[i]==0 && (positionToMotor[i] > 0) ) {  //  number of revLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW revLfo=0 ");println (pos[i]);
      }
      
      recordLastDataOfMotorPosition[i]=  DataToDueCircularVirtualPosition[i];
    }
  
  }
  
  
   public void assignMotorWithDataMappedTer() {
  
           for (int i = 0; i < 12; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (countFollowSignalLfo[i]!=0  && (dataMappedForMotor[i] >  0) ) { // number of countFollowSignalLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, numberOfStep, 0, numberOfStep))+ (countFollowSignalLfo[i]*numberOfStep);
      }

      if (countFollowSignalLfo[i]!=0  && (dataMappedForMotor[i] <  0)) { // number of countFollowSignalLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (dataMappedForMotor[i], 0, -numberOfStep, 0,  numberOfStep))+ (countFollowSignalLfo[i]*numberOfStep);
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, -numberOfStep, numberOfStep, 0)) +(countFollowSignalLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (countFollowSignalLfo[i]==0 && (dataMappedForMotor[i] < 0) ) { //  number of countFollowSignalLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, -numberOfStep, numberOfStep, 0));        
      }         
      if  (countFollowSignalLfo[i]==0 && (dataMappedForMotor[i] > 0) ) {  //  number of countFollowSignalLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW countFollowSignalLfo=0 ");println (pos[i]);
      }
      
      recordLastDataOfMotorPosition[i]=  DataToDueCircularVirtualPosition[i];
    }
  
  }
 
  public void  splitTimeTer() { 
 
  if (doZ==false){ 
  if (formerDecayTimeLfo>decayTimeLfo){
      oldMemoryi=memoryi;
       memoryi=(memoryi+1);
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
      } 
      memoryi=memoryi%12;
      oscillatorChange=oscillatorChange%12;
     if (oscillatorChange<=0) {
         memoryi=2;
         oscillatorChange=2; 
   } 
     if (memoryi<=0) {
         memoryi=2;
         oscillatorChange=2; 
   } 
  }

  if (doZ==true){
  if (formerDecayTimeLfo>decayTimeLfo){
    oldMemoryi=memoryi;
    memoryi=(memoryi-1);
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=2) {
     //   memoryi=11;
     //   oldMemoryi=2;
        oscillatorChange=11;
   }
      if (memoryi<=2) {
       memoryi=11;
      oldMemoryi=2;    
   }
  } 


  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
       formerDecayTimeLfo = decayTimeLfo; 
       oldSignalToSplit=signalToSplit;

   signalToSplit = (int ) map (signal[3], 0, 1, 0, 1000); 

    if (oldSignalToSplit> signalToSplit ) {  // signal goes down
 timeLfo= 0;  //do not consider this signal 
    }
  else if (oldSignalToSplit< signalToSplit ) {  
//  signalToSplit= map (signalToSplit, 0, 1, 1000, 0);  // 0 to
 timeLfo= map (signalToSplit, 0, 1000, 0, 1000);  // 0 to  
 }
 
   

 int   splitTime= PApplet.parseInt  (timeLfo%200);  // it you increase the ratio of the modulu u increase latency betwwen propagation.

text (" oldsig " + oldSignalToSplit  , -2000, height+400 ); 
text ("    sig " + signalToSplit + " timeLfo " + timeLfo , -2000, height+600 ); 
text (" splitTime " + splitTime + " timeLfo%200 " + timeLfo%200 + " doZ " + doZ, -1600, height+800 ); 

         decayTimeLfo = splitTime;
          
}
 
 
 public void  splitTimeLfoTer() {  // signalToSplit = lfoPhase3

 lfoPhase[3] = map ((((cos  (frameCount / 20.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  

  signalToSplit= map (signal[3], 0, 1, -TWO_PI, TWO_PI);


  //lfoPattern();   // signalTosplit come from lfoPattern(). Signal of rotation come from Lfopattern too. Function is at the top 
 
  if (oldSignalToSplit> signalToSplit ) {
  //  key = 'q' ; // when signal goes down --> propagation FRONT SIDE
  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {
//   key = 'z';  //  when signal goes down --> propagation BEHIND SIDE 
//   key = 'q' ;  // propagation in on the same way
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
      
   oldSignalToSplit=signalToSplit;

   
  int splitTimeLfo= PApplet.parseInt  (timeLfo%100);   // 100 is the size of the gate trigging the change of the ball  
   
      println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );

      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );


 if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){
 //     oldMemoryi=memoryi;
 //      memoryi=(memoryi+1);
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
      } 
   //   memoryi=memoryi%12;
      oscillatorChange=oscillatorChange%networkSize;

  }
  
    if (doZ==true){ // case z
//  if (formerDecayTimeLfo>decayTimeLfo){
   if (  oldSplitTimeLfo>splitTimeLfo){
 //   oldMemoryi=memoryi;
 //   memoryi=(memoryi-1);
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {
//        memoryi=11;
//        oldMemoryi=2;
        oscillatorChange=networkSize-1;
   }
  }  
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
   oscillatorChanged=true;
  } 
//   formerDecayTimeLfo = decayTimeLfo;
   oldSplitTimeLfo = splitTimeLfo;
    
 
   
}
 
  public void  splitTimeLfoWithAbletonTer() { 
 
    
  if (formerDecayTimeLfo>decayTimeLfo+10){
 // frameCountBis=frameCountBis+1;
    oscillatorChange=oscillatorChange+1;

        
 // key='a';
  } 
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
  
  formerDecayTimeLfo = decayTimeLfo;
 // decayTime = millis()%500;// incremente frameCountBis+1 each 100 millisecondes  
 /*
  if (oldSignalToSplit> signalToSplit ) {
//  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    timeLfo= map (signalToSplit, 0, 100, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
//  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
  timeLfo= map (signalToSplit, 100, 0, 0, 1000);  // 0 to  
  
   }
 */  
   
  //  println ( " oldlfoPhase[3] " + oldLfoPhase[3] + " lfoPhase[2] " + lfoPhase[3] );
//  print ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );

  
  
  
   oldSignalToSplit=signalToSplit;

//_____   signalToSplit= map (automationAbleton[8], 0, 1, 0, 127);
   
//   if ( formerKeyMetro == '>' )  {
     
       if (oldSignalToSplit> signalToSplit ) { println (" SIGNAL DESCEND " );
   timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
 //_____   timeLfo= map (signalToSplit, 0, 127, 1000, 0);  // 0 to  
    }
    
    else   println (" SIGNAL MONTE " ); timeLfo= map (signalToSplit, 127, 0, 0, 1000);   
   
   
//  timeLfo= map (signalToSplit, 0, 100, 0, 1000); 

  //  timeLfo=   timeLfo;
  
  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  
//  int splitTimeLfo= (int) timeLfo; //  (timeLfo%100
 if (signalToSplit>15){
   // timeLfo= map (signalToSplit, 0, 100, 0, 1000);  // 0 to 
    
  print (" TIMELfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

 }
// int splitTimeLfo= int (timeLfo);
  
  
 //** float timeLfo= millis();  // 0 to
 //**  int splitTimeLfo= frameCountBis;
 
   //    print (" oldLfoPhase[2] "); print ( oldLfoPhase[2] ); print (" lfoPhase[2] "); print ( lfoPhase[2] );

       
         oscillatorChange=oscillatorChange%12;
     if (oscillatorChange<=0) {
         oscillatorChange=2;
         }
      //   decayTimeLfo = splitTimeLfo;
       decayTimeLfo = (int) timeLfo;
         print (" oscillatorChange "); println ( oscillatorChange ); 
        
         
}
 

 public void splitTimeWithAbletonNoteBis() { 

     
  //   TRY RANDOM OSCILLATOR BLOCKED
     
       text (memoryi, 350, 100); // with key d it's better when memoryi as oscillator blocked doesn't change. 
     //  measure<361 && measure<278 &&
      if ((  millis()>formerEvent[74]+500) &&  // wiat 200 ms before consideration of the next event 74. Here is note 74
      ((note1>73 && note1<75 && velocity1>=1 && velocity1<=64)|| (note2>73 && note2<75 && velocity2>=1 && velocity2<=64)|| (note3>73 && note3<75 && velocity3>=1 && velocity3<=64) ||
      (note4>73 && note4<75 && velocity4>=1 && velocity4<=64)|| (note5>73 && note5<75 && velocity5>=1 && velocity5<=64)|| (note6>73 && note6<75 && velocity6>=1 && velocity6<=64)
      )) {
        
      formerEvent[74]=millis(); // repeat above if formerEvent[74]+1000
   
   //   oscillatorBlocked=6;  // used to phase shifiting from the oscillatorBlocked. Here 6 doesn't move and 7, 8 ... to 5 are shifted as k* 7, K* 8. See 'g' in phasePattern
      key='d';  keyReleased();//i= 105
      
      
      
      // SIGNAL TO SPLIT?
      
      
   if (doZ==false){  
         oscillatorChange=oscillatorChange+1;
         oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
         oscillatorChange=0;
         }
       }
       
       
     if (doZ==true) {   
       oscillatorChange=oscillatorChange-1;
     if (oscillatorChange<0) {
        oscillatorChange=networkSize-1;
        memoryi=networkSize-1;
        oldMemoryi=0;
        
         }
       } 
       
       
     if (doZ==false){  
         oscillatorBlocked=oscillatorBlocked+1;
         oscillatorBlocked=oscillatorBlocked%networkSize;
     if (oscillatorBlocked<=0) {
         oscillatorBlocked=0;
         }
       }
       
       
     if (doZ==true) {   
      oscillatorBlocked=oscillatorBlocked-1;
     if (oscillatorBlocked<0) {
        oscillatorBlocked=networkSize-1;
        memoryi=networkSize-1;
        oldMemoryi=0;
        
         }
       } 
       
          text (oscillatorChange, 300, 100);
  
    }
  }
 
 
  public void  splitTimeLfoWithAbletonBis() { 
 
   if (doZ==false){ 
  if (formerDecayTimeLfo>decayTimeLfo){
 // frameCountBis=frameCountBis+1;
  
    oscillatorChange=oscillatorChange+1;

     }    
 // key='a';
  } 
   if (doZ==true){
  if (formerDecayTimeLfo>decayTimeLfo){
    oldMemoryi=memoryi;
    memoryi=(memoryi-1);
    oscillatorChange=oscillatorChange-1;
    } 
   } 
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
  
  formerDecayTimeLfo = decayTimeLfo;
  
 print ( " oldSignalToSplitABLETON " + oldSignalToSplit + " signalToSplit " + signalToSplit );
// oldSignalToSplit=signalToSplit;
 float oldautomation9;
 oldautomation9=automation9;
 
 
 
 signalToSplit= map (automation9, 0, 1, -TWO_PI, TWO_PI);  // called LPF in ableton
 
   if (oldSignalToSplit> signalToSplit ) {
    timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
   
   
    
 oldSignalToSplit=signalToSplit;
   

   int splitTimeLfo= PApplet.parseInt  (timeLfo%100);
   
   
  print( " automation9 " + automation9 );
  print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );  

      if (doZ==false){   
         oscillatorChange=oscillatorChange%12;
     if (oscillatorChange<=0) {
         oscillatorChange=2;
         }
       }
       
       
     if (doZ==true) {   
     if (oscillatorChange<=2) {
        memoryi=11;
        oldMemoryi=2;
        oscillatorChange=11;
         }
       } 
         
     
         decayTimeLfo = splitTimeLfo;
         print (" oscillatorChange "); println ( oscillatorChange ); 
        
         
}



  public void  splitTimeBis() { 
  //   key='b';
  if (formerDecayTimeLfo>decayTimeLfo){
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   //  key='q';
  } 
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
       formerDecayTimeLfo = decayTimeLfo; 

//   int splitTimeLfo = millis()%150; // linear time  to change " oscillator " each 200 ms

     signal[2] = (0*PI + (frameCount / 75.0f) * cos (1000 / 500.0f)*-1)%1;
    
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] );

      timeLfo = (int ) map (signal[2], 0, 1, 0, 1000); // linear time  to change " oscillator " each 200 ms

 int   splitTime= PApplet.parseInt  (timeLfo%100);   
 
         oscillatorChange=oscillatorChange%12;
     if (oscillatorChange<=0) {
         oscillatorChange=2;
         }
         decayTimeLfo = splitTime;
    //     print (" oscillatorChange "); println ( oscillatorChange ); 
      
}

 public void  splitTimeLfoQuater() {  // signalToSplit = lfoPhase3
 
//  lfoPattern();   // signalTosplit come from lfoPattern(). Signal of rotation come from Lfopattern too. Function is at the top 
    lfoPhase[1] = (0*PI + (frameCount / 5.0f) * cos (1000 / 500.0f)*-1)%TWO_PI;  // continue 0 to TWO_PI;
    lfoPhase[3] = map ((((cos  (frameCount / 30.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoidale lente
    lfoPhase[2] = map ((((cos  (frameCount / 100.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI); // sinusoidale rapide
    
    println (" forme d'onde lfoPhase[1] ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3]= signalTosplit ", lfoPhase[3]); 

    oldSignalToSplit=signalToSplit;
    signalToSplit= lfoPhase[1];
 
  if (oldSignalToSplit> signalToSplit ) {
  //  key = 'q' ; // when signal goes down --> propagation FRONT SIDE
  // timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) { // on est dans cette configuration avec  signalToSplit= lfoPhase[1]
//   key = 'z';  //  when signal goes down --> propagation BEHIND SIDE 
//   key = 'q' ;  // propagation in on the same way
//  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
    timeLfo= map (signalToSplit, 0, TWO_PI, 0, 1000);  // 0 to  // with lfoPhase[1]
 
  }

  int splitTimeLfo= PApplet.parseInt  (timeLfo%100);   // 100 is the size of the gate trigging the change of the ball  
   
      println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );


 if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){
 //     oldMemoryi=memoryi;
 //      memoryi=(memoryi+1);
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
      } 
   //   memoryi=memoryi%networkSize;
      oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
     //    memoryi=0;
         oscillatorChange=0;
   } 
  }
  
    if (doZ==true){ // case z
   if (  oldSplitTimeLfo>splitTimeLfo){
 //   oldMemoryi=memoryi;
 //   memoryi=(memoryi-1);
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {
//        memoryi=11;
//        oldMemoryi=2;
        oscillatorChange=networkSize-1;
   }
  }  

  if ( oldOscillatorChange!=oscillatorChange )
  {
   oscillatorChanged=true;
  } 
   oldSplitTimeLfo = splitTimeLfo;
             
}

  public void  splitTimeQuater(float propagationSpeed) { 
   
  //  oldSignalToSplit=signalToSplit;
  
         signal[2] = (0*PI + (frameCount / propagationSpeed) * cos (1000 / 500.0f)*-1)%1;

//  splitTime=signal[2];
   
  if (oldSplitTime>splitTime){
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   //  key='q';
  } 
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
   //    formerDecayTimeLfo = decayTimeLfo; 
  //  oldSplitTime = splitTime;
    

//   int splitTimeLfo = millis()%150; // linear time  to change " oscillator " each 200 ms

    
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] + " oldSplitTime " + oldSplitTime + " splitTime " + splitTime );

   timeLfo = (int ) map (signal[2], 0, 1, 0, 1000); // linear time  to change " oscillator " each 200 ms
 
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " timeLfo   " + timeLfo );

/*  
  if ( mappingMode == " circular " ) {
      
    if (oldSignalToSplit> signalToSplit ) {
  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
   oldSignalToSplit=signalToSplit;
  }
*/ 
   oldSplitTime=splitTime;
    splitTime= PApplet.parseInt  (timeLfo%100);   
   //    println ( " ***************************************************    SPLIT TIME  decayTimeLfo     " + decayTimeLfo + " signalToSplit " + splitTime );
   //    println ( " ***************************************************    SPLIT TIME  oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
  
         oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
         oscillatorChange=0;
         }
     // 
    //     print (" oscillatorChange "); println ( oscillatorChange ); 
      
}

 public void  splitTimeOriginal(float propagationSpeed) { 
   oldSplitTime = splitTime;  
     signal[2] = (0*PI + (frameCount / propagationSpeed) * cos (1000 / 500.0f)*-1)%1;
  //   key='b';
//  if (formerDecayTimeLfo>decayTimeLfo){
   if (oldSplitTime>splitTime){
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   //  key='q';
  } 
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
  //     formerDecayTimeLfo = decayTimeLfo; 
//
//   int splitTimeLfo = millis()%150; // linear time  to change " oscillator " each 200 ms

 //      signal[2] = (0*PI + (frameCount / propagationSpeed) * cos (1000 / 500.0)*-1)%1;
    
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] );

 int  timeLfo = (int ) map (signal[2], 0, 1, 0, 1000); // linear time  to change " oscillator " each 200 ms
 
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " timeLfo   " + timeLfo );

/*  
  if ( mappingMode == " circular " ) {
      
    if (oldSignalToSplit> signalToSplit ) {
  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
   oldSignalToSplit=signalToSplit;
  }
*/ 
  //   oldSplitTime = splitTime;  
    splitTime= PApplet.parseInt  (timeLfo%100);   
   //    println ( " ***************************************************    SPLIT TIME  decayTimeLfo     " + decayTimeLfo + " signalToSplit " + splitTime );
   //    println ( " ***************************************************    SPLIT TIME  oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
  
         oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
         oscillatorChange=0;
         }
     //    decayTimeLfo = splitTime;
    
    //     print (" oscillatorChange "); println ( oscillatorChange ); 
      
}
 


    
 
 public void propagationMode(){ // as addSignalOneAndTwoQuater() in NAOP 


     textSize (100);
     text ("Change mode q, z, or stop progation with b ", -width-200, -height- 600 );
     text ("signal2 " +nf(signal[2], 0, 2), -width-200, -height- 500 );
 //    text ("signal3 " + signal[3], -width-200, -height- 400 );
 //    text (" oldSignalToSplit " + oldSplitTime + " splitTime " +  splitTime + " timeLFO " + timeLfo,  -width-200, -height- 400 );
 //    text (" oldSignalToSplit " + nf (oldSignalToSplit, 0, 2) + " signalToSplit " +     nf (signalToSplit, 0, 2) + " timeLFO " + timeLfo,  -width-200, -height- 300 );
   text (" oldOscillatorChange " + oldOscillatorChange + " oscillatorChange " + oscillatorChange + " j " + nf (phaseKeptAtChange[oscillatorChange]/TWO_PI*360%360, 0, 2), -width-200, -height- 300 );
   text (" oldOscillatorChange " + (oldOscillatorChange+1)%6 + " oscillatorChange " + (oscillatorChange+1)%6 + " j " + nf (phaseKeptAtChange[(oscillatorChange+1)%6]/TWO_PI*360%360, 0, 2), -width-200, -height- 200 );
     text (" propagationSpeed " + propagationSpeed + " key " + key, -width-200, -height- 100 );
     
  
   if (key=='q' || key=='b' || key=='z' ) { // q == addsignal
     letter = key;   
     }
     
  switch(letter) {
    case 'q': 
    doQ=true;
    doZ=false;
    break;
    case 'b': 
    doQ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    doQ=true;
    break;
    }
 
 splitTimeScale(30.0f); //  10.0= vitesse de propagation. On change de sens de ROTATION avec q et z.
 //splitTimeLfoScale();  // change de sens de PROPAGATION
  propagation2way();

  mapDataToMotor();

 for (int k = 0; k < this.nbBalls; k++) 
    {    
    //    drawBallGeneral(k, newPosXaddSignal[k] ); 
   // newPosXaddSignal[k]= LFO[k];
    }  
 
 formerFormerKey= formerKey;   
 formerKey=key;
 }

  public void propagation2way() {   // le boule d'apres prends la position de la boue d'vant + PI/8


     phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oldOscillatorChange]%TWO_PI;
    //  phaseKeptAtChange[oscillatorChange]=phaseKeptAtChange[oldOscillatorChange];
   //   phaseKeptAtChange[oldOscillatorChange]=               LFO[oscillatorChange];
    //**   phaseKeptAtChange[oldOscillatorChange]=newPosXaddSignal[oscillatorChange]; 
   // phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oldOscillatorChange];
    //  phaseKeptAtChange[oscillatorChange]=phaseKeptAtChange[oldOscillatorChange];
   //   phaseKeptAtChange[oldOscillatorChange]=               LFO[oscillatorChange];
    //**   phaseKeptAtChange[oldOscillatorChange]=newPosXaddSignal[oscillatorChange]; 
   
   
   /*
    if (doZ==true){ // A essayer

       LFO[oldOscillatorChange] = phaseKeptAtChange[oldOscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
       dataMappedForMotor[oldOscillatorChange]= (int) map (LFO[oldOscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oldOscillatorChange]= map (dataMappedForMotor[oldOscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
     
    if (doZ==false){ 

       LFO[oldOscillatorChange] = phaseKeptAtChange[oldOscillatorChange]-QUARTER_PI*1/2 ;  //
       dataMappedForMotor[oldOscillatorChange]= (int) map (LFO[oldOscillatorChange], 0, TWO_PI, 0, numberOfStep);
       println (" false phaseKeptAtChange[oscillatorChange] ", oldOscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oldOscillatorChange]= map (dataMappedForMotor[oldOscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }

*/
    if (doZ==true){ 

       LFO[oscillatorChange] =LFO[oldOscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
   //    LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
     
    if (doZ==false){ 

       LFO[oscillatorChange] =LFO[oldOscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
    //  LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;

       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
      
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
       // newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oldOscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
   
 }
 
  public void propagation2wayXP() { 


   //  phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oldOscillatorChange];
    //  phaseKeptAtChange[oscillatorChange]=phaseKeptAtChange[oldOscillatorChange];
  phaseKeptAtChange[oldOscillatorChange]=               LFO[oscillatorChange];
        
   /*
    if (doZ==true){ 

       LFO[oldOscillatorChange] = phaseKeptAtChange[oldOscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
       dataMappedForMotor[oldOscillatorChange]= (int) map (LFO[oldOscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oldOscillatorChange]= map (dataMappedForMotor[oldOscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
     
    if (doZ==false){ 

       LFO[oldOscillatorChange] = phaseKeptAtChange[oldOscillatorChange]-QUARTER_PI*1/2 ;  //
       dataMappedForMotor[oldOscillatorChange]= (int) map (LFO[oldOscillatorChange], 0, TWO_PI, 0, numberOfStep);
       println (" false phaseKeptAtChange[oscillatorChange] ", oldOscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oldOscillatorChange]= map (dataMappedForMotor[oldOscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
*/

    if (doZ==true){ 

       LFO[oscillatorChange] =phaseKeptAtChange[oscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
     
    if (doZ==false){ 

       LFO[oscillatorChange] =phaseKeptAtChange[oscillatorChange]+QUARTER_PI*1/2 ;  // on ajoute 
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
 }
 
///////////////////// 

 


 public void  splitTimeLfoScale() {  // change de sens de propagagtion.   ATTENTION dans ce reglage le signalToSplit de propgation est UP continue de 0 à TWO_PI

    lfoPhase[1] = (frameCount / 10.0f * cos (1000 / 500.0f)*-1)%TWO_PI;  // continue 0 to TWO_PI;
    lfoPhase[3] = map ((((cos  (frameCount / 30.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoidale lente
    lfoPhase[2] = map ((((cos  (frameCount / 100.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI); // sinusoidale rapide
    
    println (" forme d'onde lfoPhase[1] ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3]= signalTosplit ", lfoPhase[3]); 

    oldSignalToSplit=signalToSplit;
    signalToSplit= lfoPhase[3];
 
  if (oldSignalToSplit> signalToSplit ) {
  //  key = 'q' ; // when signal goes down --> propagation FRONT SIDE
   timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  //  if we have an oscillation as  lfoPhase[3]
    }
  else if (oldSignalToSplit< signalToSplit ) { // on est dans cette configuration avec  signalToSplit= lfoPhase[1]
//   key = 'z';  //  when signal goes down --> propagation BEHIND SIDE 
//   key = 'q' ;  // propagation in on the same way
   timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // if we have an oscillation  lfoPhase[3]
 //**   timeLfo= map (signalToSplit, 0, TWO_PI, 0, 1000);  // if we have a continuois from 0 to TWO_PI 
 //   timeLfo= map (signalToSplit, 0, 1, 0, 1000); //  if we have a continuois from 0 to TWO_PI from an other software
 
   }

  int splitTimeLfo= PApplet.parseInt  (timeLfo%100);   // 100 is the size of the gate trigging the change of the ball  
   
      println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );


 if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){

      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   } 
      oscillatorChange=oscillatorChange%networkSize;
      
  if (oscillatorChange<=0) {
  //    oscillatorChange=0;
      oldOscillatorChange=networkSize-1;
   } 
  }
  
 if (doZ==true){ // case z
  if (  oldSplitTimeLfo>splitTimeLfo){

      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {

      oldOscillatorChange=0;
      oscillatorChange=networkSize-1;
   }
  }  

  if ( oldOscillatorChange!=oscillatorChange )
  {
   oscillatorChanged=true;
  } 
   oldSplitTimeLfo = splitTimeLfo;
             
}

  public void  splitTimeScale(float propagationSpeed) { 
   

         signal[2] = (0*PI + (frameCount / propagationSpeed) * cos (1000 / 500.0f)*-1)%1;
         
    if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){
 
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   } 

      oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
    
         oscillatorChange=0;
         oldOscillatorChange=networkSize-1;
   } 
  }
  
    if (doZ==true){ // case z
   if (  oldSplitTimeLfo>splitTimeLfo){

       oldOscillatorChange=oscillatorChange;

      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {

        oldOscillatorChange=0;

        oscillatorChange=networkSize-1;
   }
  }       
  
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] + " oldSplitTime " + oldSplitTime + " splitTime " + splitTime );

   timeLfo = (int ) map (signal[2], 0, 1, 0, 1000); // linear time  to change " oscillator " each 200 ms
 
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " timeLfo   " + timeLfo );

   oldSplitTimeLfo=splitTimeLfo;
   splitTimeLfo= PApplet.parseInt  (timeLfo%100);   
   
}
 public void addSignalOneAndTwo(){
    print (formerKeyMetro);
    text ( " One And Two Original oscillatorChange" + oscillatorChange , 400, 800);
    lfoPattern();

   if (key=='q' || key=='b' || key=='z' ) { // q == addsignal
     letter = key;   
     }
     
  switch(letter) {
    case 'q': 
    doQ=true;
    doZ=false;
    break;
    case 'b': 
    doQ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    doQ=true;
    break;
    }
    
    
 splitTime(); 
//  splitTimeLfo(); 
 // splitTimeLfoWithAbleton(); 
    
  addSignalLfoPattern(); 
 
 println(" formerFormerKey " + PApplet.parseChar (formerFormerKey) + " formerKey " + PApplet.parseChar (formerKey) + " key " + key)  ;
 formerFormerKey= formerKey;
 formerKey=key;
 }
 
  public void addSignalLfoPattern()  {
   
    if (doQ==true ){
  //   pendularPattern(); // offset with lfo oscillator by osillator
     print ("  case q phaseFollowLFO " + oscillatorChange + " "  + phaseFollowLFO[oscillatorChange] + " "); print ("  LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  print (LFO[oscillatorChange]  ); 
     print (" newPosXaddSignal[oscillatorChange] " + newPosXaddSignal[oscillatorChange]);
     
   //   phaseFollowLFO[oscillatorChange]= lfoPhase[2];  
     signal[4] = (0*PI + (frameCount / 20.0f) * cos (1000 / 500.0f)*-1)%1;
    phaseFollowLFO[oscillatorChange]= map (signal[4], 0, 1, 0, TWO_PI);    // speed of rotation
  // phaseFollowLFO[oscillatorChange]= map (0.01, 0, 1, 0, TWO_PI); //   ..DON4T WORK

   }

  
    print ("  LFO+LFOoscillatorChange  "); print (oscillatorChange); print ("   ") ;  println (LFO[oscillatorChange]  ); 

   if (formerFormerKey  == '#' ) { //  != '#'
     print ("  normal " + frameCount + " lfoPhase[1] " + lfoPhase[1] + " lfoPhase[2] " + lfoPhase[2]);    println (   ); 
       
  //    for (int i = 2; i <  networkSize-0; i+=1) { 
    int i;
    i= oscillatorChange;
    
  int j;  
  j= (oscillatorChange-1);
  if (j<= 1){
  j= networkSize-1;
  }
 
 //********POURQUOI DIFFERENT AU DEMARRAGE DE lA FONCTION
  //  signal[2] = (0*PI + (frameCount / 20.0) * cos (1000 / 500.0)*-1)%1; //NO vitesse roat
    signal[2] = 0.08f;
   
      LFO[i] =  map (signal[2], 0, 1, 0, TWO_PI);  
      
      
   //    LFO[i] =  map (0.01, 0, 1, 0, TWO_PI);  // CONSTANT

  
    if ( phaseKeptAtChange[j]<0){   
       LFO[i] =    LFO[i]- phaseKeptAtChange[j];
       dataMappedForMotor[i]= PApplet.parseInt (map (LFO[i], 0, -TWO_PI, numberOfStep, 0)); 

       newPosXaddSignal[i]= map (dataMappedForMotor[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else
       LFO[i] = LFO[i]+ phaseKeptAtChange[j];

       LFO[i] = LFO[i]%TWO_PI;
       dataMappedForMotor[i]= (int) map (LFO[i], 0, TWO_PI, 0, numberOfStep);

       newPosXaddSignal[i]= map (dataMappedForMotor[i], 0, numberOfStep, 0, TWO_PI);
   
 // ABOVE LFO on oscillatorChange
 
    
   if (LFO[oscillatorChange]<0 && phaseFollowLFO[oscillatorChange]<0 ) {        
       LFO[oscillatorChange] =   phaseFollowLFO[oscillatorChange]-LFO[oscillatorChange]; 
       dataMappedForMotor[oscillatorChange]= PApplet.parseInt (map (LFO[oscillatorChange], 0, -TWO_PI, numberOfStep, 0)); 

       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else if (LFO[oscillatorChange]>0 && phaseFollowLFO[oscillatorChange]>0 ) {      
       LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]; // +LFO[oscillatorChange];
       LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI, 0, numberOfStep);

       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
    
    }
    
    
  }

    println (" newPosXaddSignal[oscillatorChange] ",  oscillatorChange, " ",  newPosXaddSignal[oscillatorChange] );
  
     int j;  
  j= (oscillatorChange-1);
  if (j<= 1){
  j= networkSize-1;
  }
       
  if (oscillatorChanged==true )  { 
//  phaseKeptAtChange[k]=newPosXaddSignal[j];
  //  phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[j];
     phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oscillatorChange];    //  RECORD on oscillatorChange-1 the postion of oscillatorChange where it has just changed
//  phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[j];    //  RECORD on oscillatorChange-1 the postion of oscillatorChange where it has just changed
  
  
   }
   
 //  else key='&';
   
      print (" phaseKeptAtChange[o] ",  oscillatorChange, " ",  phaseKeptAtChange[oscillatorChange] );
      println (" phaseKeptAtChange[j] " , j, " ",  phaseKeptAtChange[j] );
      
   //**    LFO[j] = phaseKeptAtChange[j]+PI/(15-j);
       LFO[j] = phaseKeptAtChange[j]+0 ; //*PI/24 
       LFO[j] = LFO[j]%TWO_PI;
       dataMappedForMotor[j]= (int) map (LFO[j], 0, TWO_PI, 0, numberOfStep);
       println (" phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oscillatorChange]);
 
       newPosXaddSignal[j]= map (dataMappedForMotor[j], 0, numberOfStep, 0, TWO_PI);
       

///////////////////// 


     for (int i = 0; i <  networkSize-0; i+=1) { // la premiere celle du fond i=2,  la derniere celle du devant i=11
 //   drawBall(i, newPosXaddSignal[i] );
  print (" newPosXaddSignalAFTERDB " + newPosXaddSignal[i]);
   
    positionToMotor[i]= ((int) map (newPosXaddSignal[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //
    
    newPosF[i]=positionToMotor[i]%6400;
    //net.phase[i]=newPosF[i];
    net.phase[i]=newPosXaddSignal[i]; // to display to screen
    positionToMotor[i]= positionToMotor[i]%6400;
    
     TrigmodPos[i]=1;
    
    if ( oldPosF[i]>newPosF[i]){
         revLfo[i]++;
         TrigmodPos[i]=0;
     
    }
  /*  
     if ( oldPosF[i]<newPosF[i]){
         revLfo[i]--;
         TrigmodPos[i]=0;
     
    }
*/
     print (" TrigmodPos[i" , TrigmodPos[i] , " newPosF " + newPosF[i]);
     oldPositionToMotor[i]=  positionToMotor[i];
     oldPosF[i]=newPosF[i];
     oldPosX[i]=newPosF[X];

     print (" revoLFO "); print ( i); print ("  "); println (revLfo[i]); 
     
     
     text ("count", -1600, height-500 - 75*i);
     text ( revLfo[i], -1400, height-500 - 75*i);
   
    
     }
     text (" restart ALT Z , cf signal[2] )", -1600, height-300 );  
     text ( signal[2], -400, height-300);
     oscSend();
     assignMotorWithPosition();
     
    for (int i = 0; i < networkSize; i++) {
//DataToDueCircularVirtualPosition[i] = DataToDueCircularVirtualPosition[networkSize-i]+ recordLastDataOfMotorPosition[i];
  //   DataToDueCircularVirtualPosition[i] = DataToDueCircularVirtualPosition[i]+ 10;
  // DataToDueCircularVirtualPosition[i]+=10;
   }
      
    int speedDelta=10;
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

      //  DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+DataToDueCircularVirtualPosition[9]+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
      //+   DataToDueCircularVirtualPosition[6]+  ","+DataToDueCircularVirtualPosition[5]+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","
      + DataToDueCircularVirtualPosition[5]+"," +   DataToDueCircularVirtualPosition[4]+ ","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","+DataToDueCircularVirtualPosition[1]+","+DataToDueCircularVirtualPosition[0]+","
    //  + DataToDueCircularVirtualPosition[4]+  ","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","+DataToDueCircularVirtualPosition[1]+","+DataToDueCircularVirtualPosition[0]+","

       +0+","+0+","+0+","+0+","
      +  (speedDelta) +","+ driverOnOff +","+dataToTeensyNoJo+","
        
   //   + TrigmodPos[11]+","+TrigmodPos[10]+","+TrigmodPos[9]+","+TrigmodPos[8]+","+TrigmodPos[7]+","+TrigmodPos[6]+","
    +TrigmodPos[5]+","+TrigmodPos[4]+","+TrigmodPos[3]+","+TrigmodPos[2]+","+TrigmodPos[1]+","+TrigmodPos[0]+ ">";  // to manage 12 note

 //     +0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+">";    

    println(frameCount + ": " +  " addSignalDataMarkedToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
  //  DueSerialNativeUSBport101.write(dataMarkedToTeensyNoJo);// Send data to Arduino.
    teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
   
}
 
 
  public void assignMotorWithPosition() {
  text (" assignMotorWithPositionTo " + keyMode , 500, 1000);
           for (int i = 0; i < networkSize; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (revLfo[i]!=0  && (positionToMotor[i] >  0) ) { // number of revLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep))+ (revLfo[i]*numberOfStep);
      }

      if (revLfo[i]!=0  && (positionToMotor[i] <  0)) { // number of revLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (positionToMotor[i], 0, -numberOfStep, 0,  numberOfStep))+ (revLfo[i]*numberOfStep);
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep, numberOfStep, 0)) +(revLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (revLfo[i]==0 && (positionToMotor[i] < 0) ) { //  number of revLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep, numberOfStep, 0));        
      }         
      if  (revLfo[i]==0 && (positionToMotor[i] > 0) ) {  //  number of revLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW revLfo=0 ");println (pos[i]);
      }
      
      recordLastDataOfMotorPosition[i]=  DataToDueCircularVirtualPosition[i];
    }
  
  }
  
  
   public void assignMotorWithDataMapped() {
  
           for (int i = 0; i < networkSize; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (countFollowSignalLfo[i]!=0  && (dataMappedForMotor[i] >  0) ) { // number of countFollowSignalLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, numberOfStep, 0, numberOfStep))+ (countFollowSignalLfo[i]*numberOfStep);
      }

      if (countFollowSignalLfo[i]!=0  && (dataMappedForMotor[i] <  0)) { // number of countFollowSignalLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (dataMappedForMotor[i], 0, -numberOfStep, 0,  numberOfStep))+ (countFollowSignalLfo[i]*numberOfStep);
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, -numberOfStep, numberOfStep, 0)) +(countFollowSignalLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (countFollowSignalLfo[i]==0 && (dataMappedForMotor[i] < 0) ) { //  number of countFollowSignalLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (dataMappedForMotor[i], 0, -numberOfStep, numberOfStep, 0));        
      }         
      if  (countFollowSignalLfo[i]==0 && (dataMappedForMotor[i] > 0) ) {  //  number of countFollowSignalLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, numberOfStep, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW countFollowSignalLfo=0 ");println (pos[i]);
      }
      
      recordLastDataOfMotorPosition[i]=  DataToDueCircularVirtualPosition[i];
    }
  
  }
 
  public void  splitTime() { 
  //   key='b';
  if (formerDecayTimeLfo>decayTimeLfo){
      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   //  key='q';
  } 
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
       formerDecayTimeLfo = decayTimeLfo; 

//   int splitTimeLfo = millis()%150; // linear time  to change " oscillator " each 200 ms

       signal[2] = (0*PI + (frameCount / 18.0f) * cos (1000 / 500.0f)*-1)%1;  // speed of split
    
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] );

 int  timeLfo = (int ) map (signal[2], 0, 1, 0, 1000); // linear time  to change " oscillator " each 200 ms
 
       println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " timeLfo   " + timeLfo );


 int   splitTime= PApplet.parseInt  (timeLfo%100);   
       println ( " ***************************************************    SPLIT TIME  decayTimeLfo     " + decayTimeLfo + " signalToSplit " + splitTime );
       println ( " ***************************************************    SPLIT TIME  oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
  
         oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
         oscillatorChange=0;
         }
         decayTimeLfo = splitTime;
    //     print (" oscillatorChange "); println ( oscillatorChange ); 
      
}
 
 
 public void  splitTimeLfo() {  // signalToSplit = lfoPhase3
 
   if (doZ==false){ 
  if (formerDecayTimeLfo>decayTimeLfo){
 // frameCountBis=frameCountBis+1;
  
    oscillatorChange=oscillatorChange+1;

     }    
 // key='a';
  } 
   if (doZ==true){
  if (formerDecayTimeLfo>decayTimeLfo){
    oldMemoryi=memoryi;
    memoryi=(memoryi-1);
      oscillatorChange=oscillatorChange-1;
    } 
   } 
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
  
  formerDecayTimeLfo = decayTimeLfo;
  
    lfoPhase[3] = map ((((cos  (frameCount / 300.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoida
 
    signalToSplit= lfoPhase[3];
  
 // decayTime = millis()%500;// incremente frameCountBis+1 each 100 millisecondes  
  if (oldSignalToSplit> signalToSplit ) {
  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
   }
   
   
    
   oldSignalToSplit=signalToSplit;
   
//   timeLfo= map (signal[11], 0, 1, 0, 1000);
   
   int splitTimeLfo= PApplet.parseInt  (timeLfo%100);
   
   
   //  println ( " oldlfoPhase[3] " + oldLfoPhase[3] + " lfoPhase[2] " + lfoPhase[3] );
  println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
  
  

      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );  

      if (doZ==false){   
         oscillatorChange=oscillatorChange%networkSize;
     if (oscillatorChange<=0) {
         oscillatorChange=0;
         }
       }
       
       
     if (doZ==true) {   
     if (oscillatorChange<=0) {
        memoryi=networkSize-1;
        oldMemoryi=0;
        oscillatorChange=networkSize-1;
         }
       } 
         
     
         decayTimeLfo = splitTimeLfo;
         print (" oscillatorChange "); println ( oscillatorChange ); 
        
         
}
 
  public void  splitTimeLfoWithAbleton() { 
 
    
  if (formerDecayTimeLfo>decayTimeLfo+10){
 // frameCountBis=frameCountBis+1;
    oscillatorChange=oscillatorChange+1;

        
 // key='a';
  } 
  
  if ( oldOscillatorChange!=oscillatorChange )
  {
       oscillatorChanged=true;
  } 
  
  formerDecayTimeLfo = decayTimeLfo;
 // decayTime = millis()%500;// incremente frameCountBis+1 each 100 millisecondes  
 /*
  if (oldSignalToSplit> signalToSplit ) {
//  timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
    timeLfo= map (signalToSplit, 0, 100, 0, 1000);  // 0 to  
    }
  else if (oldSignalToSplit< signalToSplit ) {  
//  timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // 0 to
  timeLfo= map (signalToSplit, 100, 0, 0, 1000);  // 0 to  
  
   }
 */  
   
  //  println ( " oldlfoPhase[3] " + oldLfoPhase[3] + " lfoPhase[2] " + lfoPhase[3] );
//  print ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );

  
  
  
   oldSignalToSplit=signalToSplit;

//_____   signalToSplit= map (automationAbleton[8], 0, 1, 0, 127);
   
//   if ( formerKeyMetro == '>' )  {
     
       if (oldSignalToSplit> signalToSplit ) { println (" SIGNAL DESCEND " );
   timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  // 0 to  
 //_____   timeLfo= map (signalToSplit, 0, 127, 1000, 0);  // 0 to  
    }
    
    else   println (" SIGNAL MONTE " ); timeLfo= map (signalToSplit, 127, 0, 0, 1000);   
   
   
//  timeLfo= map (signalToSplit, 0, 100, 0, 1000); 

  //  timeLfo=   timeLfo;
  
  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  print (" timeLfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

  
//  int splitTimeLfo= (int) timeLfo; //  (timeLfo%100
 if (signalToSplit>15){
   // timeLfo= map (signalToSplit, 0, 100, 0, 1000);  // 0 to 
    
  print (" TIMELfo "); print ( timeLfo );   println (" splittimeLfo ");// println ( splitTimeLfo );  

 }
// int splitTimeLfo= int (timeLfo);
  
  
 //** float timeLfo= millis();  // 0 to
 //**  int splitTimeLfo= frameCountBis;
 
   //    print (" oldLfoPhase[2] "); print ( oldLfoPhase[2] ); print (" lfoPhase[2] "); print ( lfoPhase[2] );

       
         oscillatorChange=oscillatorChange%12;
     if (oscillatorChange<=0) {
         oscillatorChange=2;
         }
      //   decayTimeLfo = splitTimeLfo;
       decayTimeLfo = (int) timeLfo;
         print (" oscillatorChange "); println ( oscillatorChange ); 
        
         
}
 
 public void formerKeyoJo() { 

  print ("circularMov "); 
  println (circularMov);
  //print("inspired from u$ and v$.  funny  "); 

  if (circularMov==false) {
    memoryi=0;
    if (d>=0) {
      timeOffset=d/10;
    }

    if (k>=0) { // k goes from -8 to 8.   you can paramater it to increase phase shifting
      phiShift=k*-PI/32;
      mapShiftPendular= map (phiShift, 0, 16*-PI/32, 0, 1600); //
    }
    print (" mapShiftPendular "); 
    println (mapShiftPendular); 

    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= PendularLeftVirtualPosition[i];// -800 à gauche 800 à droite
      PendularOldLeftVirtualPosition[i]=  PendularOldLeftVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= PendularLeftVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]=  PendularOldLeftVirtualPosition[i+1];
    }
    //    mapShiftPendular=600;
    // for (int i = 2; i < (net.size()-1); i++) {//
    for (int i = 2; i < (11); i++) {//test only point 2 and 3

      if (   millis()>TimeEllapsedBall[i]+timeOffset && 
        (((PendularOldLeftVirtualPosition[i] <= PendularLeftVirtualPosition[i+1]+mapShiftPendular) && (PendularLeftVirtualPosition[i]+mapShiftPendular > PendularLeftVirtualPosition[i+1]) && (PendularOldLeftVirtualPosition[i]< PendularLeftVirtualPosition[i])) || // balls go to the right
        ((PendularOldLeftVirtualPosition[i]+mapShiftPendular >= PendularLeftVirtualPosition[i+1]) && (PendularLeftVirtualPosition[i]< PendularLeftVirtualPosition[i+1]+mapShiftPendular)&& (PendularOldLeftVirtualPosition[i] > PendularLeftVirtualPosition[i]))) // balls go to the left
        ) { 
        memoryi=i;
        TimeEllapsedBall[i]=millis();  
        net.phase[i+1]= net.oldPhase[i];//  
        //    mapShiftPendular=200;
      } else if (millis()<=TimeEllapsedBall[i]+timeOffset) {
        memoryi=100*i;
      }
    }
    //   mapShiftPendular=200;
    print ("BeforeTimeEllapsedBall "); 
    print (11);  
    print (" "); 
    println (TimeEllapsedBall[11]) ;
    if  (millis()>TimeEllapsedBall[11]+timeOffset && //ici + 200 sert à voir  memoryi=12; mapShiftPendular
      ((PendularOldLeftVirtualPosition[11] <= PendularLeftVirtualPosition[2]+mapShiftPendular) && (PendularLeftVirtualPosition[11]+mapShiftPendular > PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[11]< PendularLeftVirtualPosition[11]) ||
      ((PendularOldLeftVirtualPosition[11]+mapShiftPendular >= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[11]< PendularLeftVirtualPosition[2]+mapShiftPendular)&& (PendularOldLeftVirtualPosition[11] > PendularLeftVirtualPosition[11]))
      )) {
      memoryi=11;
      TimeEllapsedBall[11]=millis();
      net.phase[2]= net.oldPhase[net.size()-1];
      print ("AfterTimeEllapsedBall "); 
      print (11);  
      print (" "); 
      println (TimeEllapsedBall[11]) ;
      print ("mapShiftPendular "); 
      print (11);  
      print (" "); 
      println (mapShiftPendular) ;
    } else if (millis()<=TimeEllapsedBall[11]+timeOffset) { //+timeOffset*11
      memoryi=12;
    }
  } 
  //*/
  ///*******end of pendular shifting




  if (circularMov==true ) { 
    print ("Beginning circularMov "); 
    println (circularMov);
    if (d>=0) {
      timeOffset=d; // timeOffset in millis (50,.. 1000 ms),  before changing phase i+1 with the phase from i
    }   
    if (k>=0) {
      phiShift=k*-PI/64; // here the position to add or substrat to the next point (i+1)
      mapShiftCircular= map (phiShift, 0, 16*-PI/16, 0, 6400);   // one revolution is 6400 step 
      //  mapShiftCircular is the space to reach in order to follow the previous point
    }
    formerEvent[0]=millis();   // time from the beginning of the launch of the program.
    print (" timeOffset "); 
    print ( timeOffset ); 
    print ( "mapShiftCircular ");   
    print ( mapShiftCircular ); 

    for (int j = 2; j < (4); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("2**********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();

        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("2**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }


      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];
      }
    }     




    // end 2 3 

    for (int j = 3; j < (5); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("3**********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();


        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("3**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }

      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];

        //   CircularOldVirtualPosition[j]= CircularOldVirtualPosition[j];
      }

      // end 3 4
    }

    for (int j = 4; j < (5); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("4 *********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();


        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("4**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }
      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];
      }

      // end 4 5
    } 

    // OSCILLATOR 11 gives its position to 2
    /*
      for (int j = 11; j < (12); j++) {
     
     if ( circularMov==true  && //( // circularMov==true
     
     ((CircularOldVirtualPosition[j] <= CircularVirtualPosition[2]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[2]+mapShiftCircular) &&
     (CircularOldVirtualPosition[j]+800*0.1 < CircularVirtualPosition[j]+800*0.1))
     
     ||
     
     ((CircularOldVirtualPosition[j]+mapShiftCircular >= CircularVirtualPosition[2]) && (CircularVirtualPosition[j]<= CircularVirtualPosition[2]+mapShiftCircular) &&
     (CircularOldVirtualPosition[j]+800*0.1 > CircularVirtualPosition[j]+800*0.1))
     
     )
     
     { 
     followNumber[j]= true;
     formerEvent[12]=formerEvent[0];
     }
     else followNumber[j]= false;
     
     if  (
     formerEvent[0]>formerEvent[12]+timeOffset && followNumber[j]== false
     ){
     //  background (127, 50,50);
     print ("formerEvent[0] ") ;  print (2); print (" ") ; print (formerEvent[0]) ; //  println();
     print ("formerEvent[2] ") ;  print (2); print (" ") ; println (formerEvent[2]) ; //  println();
     //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
     net.phase[2]=(net.phase[j]);// 
     net.phase[2]= net.phase[2]%TWO_PI;//  keep phase between 0 and TWO_PI
     
     memoryi=j;  
     formerEvent[2]=formerEvent[0];
     
     print (" memoryiCircular= ");  print (memoryi);
     print (" followNumber ");  print (followNumber[j]);
     
     }
     
     }
     */
  }
  for (int j = 2; j < (11); j++) {
    //     CircularOldVirtualPosition[j]= CircularOldVirtualPosition[j]; // useless
    //     CircularOldVirtualPosition[j+1]= CircularOldVirtualPosition[j+1]; // useless
  }
}
 public void deblockPendularOriginial() { 
  float PhaseDecay;
  PhaseDecay=d*QUARTER_PI/2;
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==false && ( (TrigmodPos[memoryi]>=0 && TrigmodPos[memoryi]<=0 && PendularLeftVirtualPosition[oldMemoryi]>=700 ) ||
    (revolution[memoryi]>=0 && revolution[memoryi]<=0 && PendularLeftVirtualPosition[oldMemoryi]<=-700) )
    ) { 
    //  background (75, 25, 75);
    if ( memoryi>=net.size()-1) {

      net.phase[1]=net.phase[0];
      print ("memoryi upstairx = 11? ");

      print (memoryi);
      net.phase[memoryi-1]= net.phase[memoryi];
      //**      net.phase[memoryi-1]= net.phase[memoryi]+PhaseDecay;
      //***      net.phase[memoryi-1]= net.phase[memoryi-1]%TWO_PI;
      net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
      net.phase[memoryi]= net.phase[2]+PhaseDecay*1; // what it has been changed with formerkeyc
      net.phase[memoryi]= net.phase[memoryi]%TWO_PI; // what it has been changed with formerkeyc
      net.naturalFrequency[memoryi]=net.naturalFrequency[2];
      oldMemoryi=memoryi;
      OldoscillatorMoving=oldMemoryi;     
      oscillatorMoving=memoryi-1 ;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving   
      print ("Next frame oscillator Moving will be ");      
      println (oscillatorMoving); 
      print (" "); 
      println (memoryi);         
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;
      key='&';
      // end of memory=11
    }  

    if ( memoryi<net.size()-1) { 
      if (memoryi>2 ) {
        net.phase[1]=net.phase[0];
        print ("you were here: ");
        oldMemoryi=memoryi;  
        print (oldMemoryi); 
        net.phase[memoryi-1]= net.phase[memoryi];
        //**   net.phase[memoryi-1]= net.phase[memoryi]+PhaseDecay;
        //**   net.phase[memoryi-1]= net.phase[memoryi-1]%TWO_PI;
        net.phase[memoryi]= net.phase[memoryi+1]+PhaseDecay*1;//      
        net.phase[memoryi]= net.phase[memoryi]%TWO_PI;
        net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
        net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi+1];

        OldoscillatorMoving=oldMemoryi;
        oldMemoryi=OldoscillatorMoving;
        print ("you were still here "); 
        println (oldMemoryi);
        oscillatorMoving=memoryi-1;

        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame are different memory here? ");
        println (oscillatorMoving);
      }

      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;

      key='+';  
      //end case memory 3 to 10
    }



    if (memoryi>1 && memoryi<3 ) {
      net.phase[1]=net.phase[0];
      print ("memoryi upstairx = 2? ");
      print (memoryi);
      //***     net.phase[memoryi-1]= net.phase[memoryi];
      //**    net.phase[net.size()-1]= net.phase[2]+PhaseDecay;
      //***   net.phase[net.size()-1]= net.phase[11]%TWO_PI;
      //    net.phase[2]= net.phase[11]+PhaseDecay*1;
      //      net.phase[2]= net.phase[2]%TWO_PI;

      net.phase[11]= net.phase[2];
      net.naturalFrequency[11]= net.naturalFrequency[2];
      //***      net.phase[2]= net.phase[1];

      //    net.phase[2]= net.phase[1]+PhaseDecay;
      //    net.phase[2]= net.phase[2]%TWO_PI;

      net.phase[2]= net.phase[3]+PhaseDecay;
      net.phase[2]= net.phase[2]%TWO_PI;

      net.naturalFrequency[2]=net.naturalFrequency[1];
      oldMemoryi=2;     
      OldoscillatorMoving=2;
      oldMemoryi=OldoscillatorMoving;      
      oscillatorMoving=net.size()-1 ;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
      print (" oscillator moving gonna be  = 11 ? ");
      println (oscillatorMoving); 
      print (" "); 
      println (memoryi);          
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;      
      key='&';
    }     //end case memory 2
  } //end of special debug in CIRCULAR = false. To deblock oscillator when they are blocked to the LEFT or to THE RIGHT
} 

// deblockPendularPendular()u
 public void deblockPendularu() {

  float PhaseDecay;
  PhaseDecay=d*QUARTER_PI/2;
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==false && ( (TrigmodPos[memoryi]>=0 && TrigmodPos[memoryi]<=0  ) ||
    (revolution[memoryi]>=0 && revolution[memoryi]<=0 )
    )) { 
    //  background (75, 25, 75);
    if ( memoryi<=net.size()-0) {
      print (" DEBLO deblockPendularu BEF  CHRO ");            
      print (upstairTime); 
      upstairTime = millis()+10;
      print (" DEBLO deblockPendularu AFT  CHRO ");            
      println (upstairTime); 
      ; 

      oldMemoryi=(memoryi+1)%12;
      if ( oldMemoryi<=0) {
        oldMemoryi=2;
      }

      //    net.phase[1]=net.phase[0];
      print ("memoryi DEBLOCK ");

      println (memoryi);

      metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];

      net.phase[oldMemoryi]=  net.phase [memoryi];

      interPhase[memoryi]=  net.phase[oldMemoryi]; 

      //   key='#'; // do not use interphase[memoryi] from beginning  
      key='e'; //restart test condition
      net.naturalFrequency[memoryi]= 0;
      if ( millis()>=  TimeTrigged ) {
        TimeTrigged = millis() +10;
        key='#'; // do not use interphase[memoryi] from beginning       
        net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
      }

      interFrequency[oldMemoryi]= interFrequency[memoryi];

      print (" FIRST CHRO ");
      println (upstairTime); 

      println (  upstairTime );
      //   upstairTime = millis() + 500;
      OldoscillatorMoving=memoryi;
      oldMemoryi=OldoscillatorMoving;
      //   oldMemoryi=memoryi;

      memoryi=(memoryi+1)%12;
      print (" memoryi deblock pendularu ");
      println (memoryi);
      if ( memoryi<=0) {
        memoryi=2;
      }
      // memoryi=memoryi+1;
      oscillatorMoving=memoryi;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
      print ("Next frame  DEBLOCK and clock way = true you'll moving to  ");
      println (oscillatorMoving); 
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;
      key='e';
    }
  }
}


 public void deblockPendulari() {

  float PhaseDecay;
  PhaseDecay=d*QUARTER_PI/2;
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==false && ( (TrigmodPos[memoryi]>=0 && TrigmodPos[memoryi]<=0  ) ||
    (revolution[memoryi]>=0 && revolution[memoryi]<=0 )
    )) { 

    print (" DEBLO deblockPendulari BEF  CHRO ");            
    print (upstairTime); 
    upstairTime = millis()+10;
    print (" DEBLO deblockPendulari AFT  CHRO ");            
    println (upstairTime); 
    /*       A TESTER
     if ( millis()>= upstairTime-10 && //net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) {
     ((TWO_PI-interPhase[memoryi]+net.phase[memoryi]
     >= interPhase[memoryi]-interPhase[oldMemoryi]))) { 
     */
    oldMemoryi=memoryi-1;
    if ( oldMemoryi<=1) {
      oldMemoryi=11;
    }   

    metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];       
    net.phase[oldMemoryi]=  net.phase [memoryi];
    interPhase[memoryi]=  net.phase[oldMemoryi]; 

    //   key='#'; // do not use interphase[memoryi] from beginning  
    key='e'; //restart test condition
    net.naturalFrequency[memoryi]= 0;
    //***         }
    if ( millis()>=  TimeTrigged ) {
      TimeTrigged = millis() +d/10;
      key='#'; // do not use interphase[memoryi] from beginning       
      net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
    }

    interFrequency[oldMemoryi]= interFrequency[memoryi];

    print (" FIRST CHRO ");          
    println (upstairTime); 

    //   upstairTime = millis() + 500;

    OldoscillatorMoving=memoryi;
    oldMemoryi=OldoscillatorMoving;
    memoryi=(memoryi-1)%12;
    print (" memoryi ");
    println (memoryi);
    if ( memoryi<=1) {
      memoryi=11;
    }

    oscillatorMoving=memoryi;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
    print ("DEBLOCK Next frame  and clock way = true you'll moving to  ");
    println (oscillatorMoving); 
    oldOscillatorMoving[oldMemoryi]= false;
    OscillatorMoving[memoryi]= true;
    key='e';
  }
}

 public void deblockCircularu() {  // 11; 10; 9

  float PhaseDecay;
  PhaseDecay=d*QUARTER_PI/2;
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==true &&  (  (revolution[memoryi]>=0 && revolution[memoryi]<=0 ) // (TrigmodPos[memoryi]>=0 && TrigmodPos[memoryi]<=0  ) 
    // || ((6400-DataToDueCircularVirtualPosition[oldMemoryi]+DataToDueCircularVirtualPosition[memoryi])>= DataToDueCircularVirtualPosition[oldMemoryi]-DataToDueCircularVirtualPosition[oldMemoryi-1] )
    ||  1<0 //   (revolution[memoryi]>=0 && revolution[memoryi]<=0 )
    )) { 

    print (" DEBLO deblockCircularu BEF  CHRO ");            
    print (upstairTime); 
    upstairTime = millis()+10;
    print (" DEBLO deblockCircularu AFT  CHRO ");            
    println (upstairTime); 

    //    print (" DataToDueCircularVirtualPosition[oldMemoryi-1] " ) ;  println (DataToDueCircularVirtualPosition[oldMemoryi-1]); // bug based on us
    print (" DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
    println (DataToDueCircularVirtualPosition[oldMemoryi]);
    print (" 6400-DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
    println (6400 - DataToDueCircularVirtualPosition[oldMemoryi]);


    //     if ((6400-DataToDueCircularVirtualPosition[oldMemoryi]+DataToDueCircularVirtualPosition[memoryi])
    //            >= DataToDueCircularVirtualPosition[oldMemoryi]-DataToDueCircularVirtualPosition[oldMemoryi-1] ){ 
    if ( millis()>= upstairTime-10 && //net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) {
      ((TWO_PI-interPhase[memoryi]+net.phase[memoryi]
      >= interPhase[memoryi]-interPhase[oldMemoryi]))) { 

      print (" AFTER  CHRO ");            
      println (upstairTime); 
      upstairTime = millis()+10;

      oldMemoryi=(memoryi+1)%12;
      if ( oldMemoryi<=0) {
        oldMemoryi=2;
      }

      metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];       
      net.phase[oldMemoryi]=  net.phase [memoryi];
      interPhase[memoryi]=  net.phase[oldMemoryi]; 


      //    key='#'; // do not use interphase[memoryi] from beginning  
      key='e'; //restart test condition
      net.naturalFrequency[memoryi]= 0;
    }
    if ( millis()>=  TimeTrigged ) {
      TimeTrigged = millis() +d/10;
      key='#'; // do not use interphase[memoryi] from beginning       
      net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
    }

    interFrequency[oldMemoryi]= interFrequency[memoryi];

    print (" FIRST CHRO ");          
    println (upstairTime); 

    //   upstairTime = millis() + 500;

    OldoscillatorMoving=memoryi;
    oldMemoryi=OldoscillatorMoving;

    memoryi=(memoryi+1)%12;
    print (" memoryi deblock pendularu ");
    println (memoryi);
    if ( memoryi<=0) {
      memoryi=2;
    }

    oscillatorMoving=memoryi;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
    print ("DEBLOCK Next frame  and clock way = true you'll moving to  ");
    println (oscillatorMoving); 
    oldOscillatorMoving[oldMemoryi]= false;
    OscillatorMoving[memoryi]= true;
    key='e';
  }
}    

 public void deblockCirculari() {  // 11; 10; 9

  float PhaseDecay;
  PhaseDecay=d*QUARTER_PI/2;
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==true &&(           (revolution[memoryi]>=0 && revolution[memoryi]<=0 ) //
    // || ((6400-DataToDueCircularVirtualPosition[oldMemoryi]+DataToDueCircularVirtualPosition[memoryi])>= DataToDueCircularVirtualPosition[oldMemoryi]-DataToDueCircularVirtualPosition[oldMemoryi-1] )
    ||  1<0 //   (revolution[memoryi]>=0 && revolution[memoryi]<=0 )
    )) { 
    //   background (127, 50, 50 );
    print (" DEBLO deblockCirculari BEF  CHRO ");            
    print (upstairTime); 
    upstairTime = millis()+10;
    print (" DEBLO deblockCirculari AFT  CHRO ");            
    println (upstairTime); 

    print (" DataToDueCircularVirtualPosition[oldMemoryi-1] " ) ;  
    println (DataToDueCircularVirtualPosition[oldMemoryi-1]);
    print (" DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
    println (DataToDueCircularVirtualPosition[oldMemoryi]);
    print (" 6400-DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
    println (6400 - DataToDueCircularVirtualPosition[oldMemoryi]);


    //     if ((6400-DataToDueCircularVirtualPosition[oldMemoryi]+DataToDueCircularVirtualPosition[memoryi])
    //            >= DataToDueCircularVirtualPosition[oldMemoryi]-DataToDueCircularVirtualPosition[oldMemoryi-1] ){ 
    if ( millis()>= upstairTime-10 && //net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) {
      ((TWO_PI-interPhase[memoryi]+net.phase[memoryi]
      >= interPhase[memoryi]-interPhase[oldMemoryi]))) { 
      //***     ((TWO_PI-net.oldPhase[memoryi]+net.phase[memoryi]>=net.phase[memoryi]+PhaseDecay[5])) // good to find


      print (" AFTER  CHRO ");            
      println (upstairTime); 
      upstairTime = millis()+10;


      oldMemoryi=memoryi-1;
      if ( oldMemoryi<=1) {
        oldMemoryi=11;
      } 
      metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];       
      net.phase[oldMemoryi]=  net.phase [memoryi];
      interPhase[memoryi]=  net.phase[oldMemoryi]; 


      //    key='#'; // do not use interphase[memoryi] from beginning  
      key='e'; //restart test condition
      net.naturalFrequency[memoryi]= 0;
    }
    if ( millis()>=  TimeTrigged ) {
      TimeTrigged = millis() +d/10;
      key='#'; // do not use interphase[memoryi] from beginning       
      net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
    }

    interFrequency[oldMemoryi]= interFrequency[memoryi];

    print (" FIRST CHRO ");          
    println (upstairTime); 

    //   upstairTime = millis() + 500;

    OldoscillatorMoving=memoryi;
    oldMemoryi=OldoscillatorMoving;

    memoryi=(memoryi-1)%12;
    print (" memoryi ");
    println (memoryi);
    if ( memoryi<=1) {
      memoryi=11;
    }

    oscillatorMoving=memoryi;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
    print ("DEBLOCK Next frame  and clock way = true you'll moving to  ");
    println (oscillatorMoving); 
    oldOscillatorMoving[oldMemoryi]= false;
    OscillatorMoving[memoryi]= true;
    key='e';
  }
}

 public void deblockCircularwi() {  // 11; 10; 9
//  PhaseDecay[5]=QUARTER_PI/8 in starterw
  float PhaseDecay;
  PhaseDecay=k*QUARTER_PI/16;
 //  PhaseDecay=QUARTER_PI/8;


  print (" PhaseDecaydeblockCircularwi ");  
  println (PhaseDecay); 
  if // debug if oscillator are blocked to the left or the right in pendular mode
    (circularMov==true &&(   (revolution[memoryi]>=0 && revolution[memoryi]<=0 )  // (pseudoRevolutionTodeblock[memoryi]>=0 && pseudoRevolutionTodeblock[memoryi]<=0 )
    // || ((6400-DataToDueCircularVirtualPosition[oldMemoryi]+DataToDueCircularVirtualPosition[memoryi])>= DataToDueCircularVirtualPosition[oldMemoryi]-DataToDueCircularVirtualPosition[oldMemoryi-1] )
    ||  1<0 //   (revolution[memoryi]>=0 && revolution[memoryi]<=0 )

    )) { 

//    background (127, 50, 50 );
    print (" DEBLO deblockCircularWI BEF  CHRO ");            
    print (upstairTime); 
    upstairTime = millis()+10;
    print (" DEBLO deblockCirculari AFT  CHRO ");            
    println (upstairTime); 
    if  (net.phase[memoryi]<=0 && TWO_PI+net.phase[memoryi]<=interPhase[oldMemoryi]+PhaseDecay) { 

      print (" DataToDueCircularVirtualPosition[oldMemoryi-1] " ) ;  
      println (DataToDueCircularVirtualPosition[oldMemoryi-1]);
      print (" DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
      println (DataToDueCircularVirtualPosition[oldMemoryi]);
      print (" 6400-DataToDueCircularVirtualPosition[oldMemoryi] " ) ;  
      println (6400 - DataToDueCircularVirtualPosition[oldMemoryi]);
      key='O'; 
      keyReleased();
    } 

    if ( millis()>= upstairTime-10 // &&  net.phase[memoryi]<=0 && TWO_PI+net.phase[memoryi]<=interPhase[oldMemoryi]+PhaseDecay//net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) {
      //   &&  ((TWO_PI-interPhase[memoryi]+net.phase[memoryi]
      //         >= interPhase[memoryi]-interPhase[oldMemoryi]))
      //***     ((TWO_PI-net.oldPhase[memoryi]+net.phase[memoryi]>=net.phase[memoryi]+PhaseDecay[5])) // good to find

      ) { 


      print (" AFTER  CHRO ");            
      println (upstairTime); 
      upstairTime = millis()+10;


      oldMemoryi=memoryi-1;
      if ( oldMemoryi<=1) {
        oldMemoryi=11;
      } 

      metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];       
      net.phase[oldMemoryi]=  net.phase [memoryi];
      interPhase[memoryi]=  net.phase[oldMemoryi]; 


      //    key='#'; // do not use interphase[memoryi] from beginning  
      key='e'; //restart test condition
      net.naturalFrequency[memoryi]= 0;
    }
    if ( millis()>=  TimeTrigged ) {
      TimeTrigged = millis() +d/10;
      key='#'; // do not use interphase[memoryi] from beginning       
      net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
    }

    interFrequency[oldMemoryi]= interFrequency[memoryi];

    print (" FIRST CHRO ");          
    println (upstairTime); 

    //   upstairTime = millis() + 500;

    OldoscillatorMoving=memoryi;
    oldMemoryi=OldoscillatorMoving;

    memoryi=(memoryi-1)%12;
    print (" memoryi ");
    println (memoryi);
    if ( memoryi<=1) {
      memoryi=11;
    }

    oscillatorMoving=memoryi;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
    print ("DEBLOCK WI Next frame  and clock way = true you'll moving to  ");
    println (oscillatorMoving); 
    oldOscillatorMoving[oldMemoryi]= false;
    OscillatorMoving[memoryi]= true;
    key='e';
  }
}
 public void followDistribueAddLfoPatternLPF(){
  /*
   lfoPattern();
  // automation9 = LPF in Ableton Live
   for (int i = 2; i <  networkSize-0; i+=1) {// networkSize-0

    phaseMapped[i]= map (automation9, 0, 1, 0, TWO_PI); // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy  lfoPhase[2]
//    phaseMapped[i]= lfoPhase[2];
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
  for (int i = 2; i < (networkSize-0); i+=1){
    print (" degrees "); print (i);  print (" "); println (degrees (net.phase[i]));
 }
 
 //**** AddABleton  
 
   for (int i = 2; i < networkSize; i+=1) { 

    phaseMapped[i] = phaseMapped[i] + phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
 
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];

    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
 // phasePatternToFollow only when a key is pressed

     if (key != '#'  ) {
       
       phasePattern();
            
    for (int i = 2; i < networkSize; i+=1) { 
      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = net.phase[i];
    phaseMapped[i] =  phaseMapped[i] + phasePatternFollow[i]; // phaseMapped[i] +  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);

       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];

    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
 } 

  sendToTeensyTurnOnDriver();
  
} 

//  if (formerFormerKey == '#'  || formerKeyMetro == '$'  || formerKeyMetro == '*' ||  formerKeyMetro == '@') { // || formerKeyMetro == '*'
  /* 
      for (int i = 2; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
*/
 }
 
 
 // add ableton to follow
  /*   
    for (int i = 2; i < 3; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[10], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
      print ("  ableton[10]  ");    println ( ableton[10]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
  
     for (int i = 3; i < 4; i+=1) { 
      print ("  BEFlfoPhase[2] phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
 //   phaseMappedFollow[i]= map (signal[2], 0, 1, 0, TWO_PI)+(i+1)*PI/10;
     phaseMappedFollow[i]=   map (ableton[9], 0, 1, 0, TWO_PI); // +(i+1)*PI/10  + map (ableton[4], 0, 1, 0, TWO_PI)*PI/10
   //   phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] = phaseMapped[i]+ phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
      print ("  ableton[9]  ");    println ( ableton[9]  ); 
   
    print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 */
 public void followDistribueAddLfoPattern(){ 
 
  // lfoPattern();  // add key o= opposite signl 2
        signal[2] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;

   text ( " signnal2 " +nf(signal[2], 0, 2) , 400, 800 ); // from Processing is -1, 1

//signal[2]= map ( signal[2], 0, 1, 0, TWO_PI);  //from Processing signal2  is -1, 1

signal[2]= map ( signal[2], 0 , 1, 0, 1);  //from Processing signal2  is -1, 1

//**signal[2]= 0.05;
//**signal[2]= map ( signal[2], 0 , -1, 0, 1);  //from Processing signal2  is -1, 1

   text ( " followDistribueAddLfoPattern signal2 " + nf(signal[2], 0, 2),  400, 900 ); // from Processing is -1, 1

   for (int i = 0; i <  networkSize-0; i+=1) {

    phaseMappedFollow[i]=map (signal[2], 0, 1, 0, TWO_PI);

    /*
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else {
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
    }
   */ 
  }

   for (int i = 0; i < networkSize; i+=1) { 
 
   // phaseMappedFollow[i]=map (signal[2], 0, 1, 0, TWO_PI);
    phaseMapped[i] = phaseMappedFollow[i]+phasePatternFollow[i];
   // phaseMapped[i] = phaseMapped[i] + phaseMappedFollow[i]+phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
      
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
 
 //   net.oldPhase[i]= net.phase[i];
 //   net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
      phaseMapped[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
      newPosF[i]= phaseMapped[i];
    //  net.phase[i]= phaseMapped[i];

       }
       
   else {
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
 //   net.oldPhase[i]=net.phase[i];

//    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
      phaseMapped[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
      newPosF[i]= phaseMapped[i];
   //     net.phase[i]= phaseMapped[i];
    }
  }
 
   
 
 // phasePatternToFollow only when a key is pressed

     if (key != '#'  ) {
       text ( " doItOnce ", 400, 700);
       phasePattern();
            
    for (int i = 0; i < networkSize; i+=1) { 

  //  phasePatternFollow[i] = net.phase[i]+phaseMapped[i];
    phasePatternFollow[i] = net.phase[i]; //
 //   phaseMapped[i] =  phaseMapped[i] + phasePatternFollow[i]; // phaseMapped[i] +  //phaseMapped[i]+ add offset given by pendularPattern
    phasePatternFollow[i] =  phasePatternFollow[i]%TWO_PI; 
/*
     if ( phaseMapped[i]<0){
     DataToDueCircularVirtualPosition[i]= int (map ( phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else {
    
    DataToDueCircularVirtualPosition[i]= (int) map ( phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
    }
  */
   
   /*
    if (phasePatternFollow[i]<0){
     DataToDueCircularVirtualPosition[i]= int (map (phasePatternFollow[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]= net.phase[i];
  //  net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else {
    
    DataToDueCircularVirtualPosition[i]= (int) map (phasePatternFollow[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
  //  net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
    }
   */

   }

  }
 


  key='#';
  send24DatasToTeensy6motors(10, 3, -3, -1);

} 
 public void followDistribueAddLfoPatternControlLPF(){
  
  lfoPattern();
   for (int i = 2; i <  net.size()-0; i+=1) {// net.size()-0
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
 //   phaseMapped[i]= map (signal[2], 0, 1, 0, TWO_PI); // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy  lfoPhase[2]
  phaseMapped[i]= map (automation9, 0, 1, 0, TWO_PI);
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
  for (int i = 2; i < (net.size()-0); i+=1){
    print (" degrees "); print (i);  print (" "); println (degrees (net.phase[i]));
 }
   
  if (formerFormerKey == '#'  || formerKeyMetro == '$'  || formerKeyMetro == '*' ||  formerKeyMetro == '@') { // || formerKeyMetro == '*'
    
      for (int i = 2; i < net.size()-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
 
 
  // phasePatternToFollow only when a key is pressed

 //    if (formerFormerKey != '#'  ) {
   
    if (Key != '#'  ) {
       
       phasePattern();
            
    for (int i = 2; i < net.size(); i+=1) { 
      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = net.phase[i];
  //  phaseMapped[i] = phaseMapped[i] + phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }

 } 
//END AddphasePatternToFollow only when a key is pressed

// Begin take off phase after 1000 ms
  
/*
       if (millis()>=controlTrigLfoPattern+2000  ) { // controlTrigLfoPattern
    
       println ("  controlTrigLfoPatternIN  ", controlTrigLfoPattern);
    
    phasePattern();
            
    for (int i = 2; i < net.size(); i+=1) { 
//      print ("  BEFphasePattern phasePattern[i]  ");    print ( phaseMapped[i]  ); 

    phasePatternFollow[i] = phaseMapped[i];
    phaseMapped[i] = phaseMapped[i] - phasePatternFollow[i];  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
//      print ("  phasePatternFollow  ");    println ( phasePatternFollow[i] ); 
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= int (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
 //**    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
 //**   net.phase[i]= phaseMapped[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
}  
 */
  sendToTeensyTurnOnDriver();
 }  
} 
 public void followSignalLfo(int ratioTimeFrame, float signal0to1){  // original   followSignal (decay time with millis)
 // splitTimeLfo();
  splitTime();
  lfoPattern();
//  lfoPhase[2];q
  
if (formerDecayTime>decayTime){
  frameCountBis=frameCountBis+1;
  } 
  formerDecayTime = decayTime;
  decayTime = millis()%100;// incremente frameCountBis+1 each 100 millisecondes
 
  int delayRatio=ratioTimeFrame;
  float signalToFollow=signal0to1;

      keyReleasedfollowSignal();
      float deltaFollow = TWO_PI; // not used
     //here in a previous function we could change the ball followed if the space of phase between phases[0] and phase 9 is more than 360° for example

  //    phases[0][frameCountBis % nbMaxDelais]= net.phase[net.size()-1]-0;

  //    phases[0][frameCountBis % nbMaxDelais]= map (signal[10], 0, 1, 0, TWO_PI);
 //    phases[0][frameCountBis % nbMaxDelais]= map (automation9, 0, 1, 0, TWO_PI);  // receive LPF
     phases[0][frameCountBis % nbMaxDelais]= map (signal0to1, 0, 1, 0, TWO_PI);  // receive LPF
        
        println ( "++++++++++++++++++++++ signal 10 ", phases[0][frameCountBis % nbMaxDelais]);
  //    drawBallOppositeWay(0, phases[0][frameCountBis % nbMaxDelais]); //net.size()-5 affiche le point 0. NE PAS AFFICHER SINON IL APPARAIT EN DOUBLE


    for (int i = 1; i < networkSize; i+=1) { // 1 follow phase 0
//    debug ="Normal follow opp2Way "; print (" iopp2Way 0 "); print (i-1);  print ("  "); println (phases[i-1][frameCountBis % nbMaxDelais]);
 //   print (i);  print ("  "); print (phases[i][frameCountBis % nbMaxDelais]); print (" 0 ");  print ("  "); print (phases[i][frameCountBis % nbMaxDelais]);
//    print (" net.phase 11 ");  print (" =0?  "); println (net.phase[net.size()-1]-0);
    
    //   follow( i-1, i, 20 * i, 0);  // Modifier les deux derniers paramètres : délais et phase
    followOppositeWay( i-1, i+0, delayTimeFollowPhase11*1*frameRatio/ratioTimeFrame, (phaseShiftingFollowPhase11));  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6

    //*****   drawBall(i, phaseMapped[i] );
    drawBallOppositeWay( i, phases[i+0][frameCountBis % nbMaxDelais] );

  }
  
//***  println(frameCount + ": " + ( debug ), " map (signal[10], 0, 1, 0, TWO_PI) ", map (signal[10], 0, 1, 0, TWO_PI), " map (signal[11], 0, 1, 0, TWO_PI) ", map (signal[11], 0, 1, 0, TWO_PI));


 
   for (int i = 2; i < networkSize; i+=1) {// display ball   (nbBall/2)-0; i < nbBall; i++   for (int i = 3; i < net.size()-0; i+=1) {
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
    phaseMapped[i]=phases[i-2][frameCountBis % nbMaxDelais]; // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy
  //  phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
  }
 

  if (formerFormerKey == '#' ) {
  
      for (int i = 2; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0){
      
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
   else
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
   
   
    if (formerFormerKey != '#' ) {
    
    if (formerKeyMetro == '*' || formerKeyMetro == '$'  ) {
    //    if (oscillatorChanged==true )  { 
       
       phasePattern();
       lfoPattern();
     
  // for (int i = 2; i < net.size()-0; i+=1) { 
 //     print ("  BEF phaseMapped[i]  ");    println ( phaseMapped[oscillatorChange]  ); 
 //   phaseMappedFollow[oscillatorChange]= map (signal[11], 0, 1, 0, TWO_PI);
 //    phaseMappedFollow[oscillatorChange]= -1*map (0.01, 0, 1, 0, TWO_PI); //CONSTANT  // ADD NOTE
    phaseMappedFollow[oscillatorChange]= map (0.01f, 0, 1, 0, TWO_PI); //CONSTANT  // ADD NOTE
    phaseMapped[oscillatorChange] =  phaseMapped[oscillatorChange]+phaseMappedFollow[oscillatorChange];  // add offset given by pendularPattern
    phaseMapped[oscillatorChange] =  phaseMapped[oscillatorChange]%TWO_PI; 
  //**  print ("  signal 11  ");    println ( phaseMapped[oscillatorChange]  ); 
  //***  println ("  phaseMapped[i]  ");    println ( phaseMapped[oscillatorChange]  ); 
    
     for (int i = 2; i < networkSize; i+=1) { 
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
     net.oldPhase[i]=phaseMapped[i];
     net.phase[i]= phaseMapped[i];
       }
       
   else
    
     DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
     net.oldPhase[i]=phaseMapped[i];
     net.phase[i]= phaseMapped[i];
 }
   }
  }
 //  }
  
  //******** Lock last oscillator to the lastPhase
  
   if (formerFormerKey  != '#' ) { //  works always
 //   if (formerFormerKey  != 'c' ) { // do not work
 //**    print ("  normalformerFormerKey not equal # " + frameCount + " lfoPhase[1] " + lfoPhase[1] + " lfoPhase[2] " + lfoPhase[2]);    println (   ); 
       
  int i;
  i= oscillatorChange;
    
 
 
   //   LFO[i] = lfoPhase[1]; 
   //   LFO[i] =  map (signal[11], 0, 1, 0, PI/4);
    
 //  LFO[i] = 1* map (0.025, 0, 1, 0, TWO_PI);  // CONSTANT SHIFT BETWEEN OSCILLATOR
 //        
 
    //           LFO[i] =  map (0.025, 0, 1, 0, TWO_PI);  // CONSTANT SHIFT BETWEEN OSCILLATOR

      //     LFO[i] =  map (0.003, 0, 1, 0, TWO_PI);  // CONSTANT SHIFT BETWEEN OSCILLATOR
  
  // to CONTROL OMOTOR
  
 
 // ABOVE LFO on oscillatorChange
 // BELOW MOVE by ODD ?
 /*
   if (LFO[oscillatorChange]<0 && phaseFollowLFO[oscillatorChange]<0 ) {        
       LFO[oscillatorChange] =   phaseFollowLFO[oscillatorChange]-LFO[oscillatorChange]; 
       dataMappedForMotor[oscillatorChange]= int (map (LFO[oscillatorChange], 0, -TWO_PI, numberOfStep, 0)); 

       net.phase[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], numberOfStep, 0, 0, -TWO_PI);
  }
 
       
   else if (LFO[oscillatorChange]>0 && phaseFollowLFO[oscillatorChange]>0 ) {      
       LFO[oscillatorChange] = phaseFollowLFO[oscillatorChange]; // +LFO[oscillatorChange];
       LFO[oscillatorChange] = LFO[oscillatorChange]%TWO_PI;
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI, 0, numberOfStep);

       net.phase[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
    
    }
 */  
    
  }

//***    println (" newPosXaddoscillatorChange] ",  oscillatorChange, " ",  newPosXaddSignal[oscillatorChange] );


  
  int j;  
  j= (oscillatorChange-1);
  if (j<= -1){
  j= networkSize-1;
  }
  
  int k;  
  k= (j-1);
  if (k<= -1){
  k= networkSize-1;
  }
  
  int l;  
  l= (k-1);
  if (l<= -1){
  l= networkSize-1;
  }
  
  int m;  
  m= (l-1);
  if (m<= -1){
  m= networkSize-1;
  }
      
  if (oscillatorChanged==true )  { 
    int i;
    i= oscillatorChange;
    if ( phaseKeptAtChange[j]<0){   
   //  LFO[i] = LFO[i] - phaseKeptAtChange[j];
    LFO[j] = phaseKeptAtChange[j];
       dataMappedForMotor[j]= PApplet.parseInt (map (LFO[j], 0, -TWO_PI, numberOfStep, 0)); 

       net.phase[j]= map (dataMappedForMotor[j], numberOfStep, 0, 0, -TWO_PI);
    //   phaseKeptAtChange[j]
  }
       
   else
 
  // LFO[i] = LFO[i]+ phaseKeptAtChange[j];
    LFO[j] = phaseKeptAtChange[j];

       LFO[j] = LFO[j]%TWO_PI;
       dataMappedForMotor[j]= (int) map (LFO[j], 0, TWO_PI, 0, numberOfStep);

       net.phase[j]= map (dataMappedForMotor[j], 0, numberOfStep, 0, TWO_PI);
   
    phaseKeptAtChange[oscillatorChange]=net.phase[oscillatorChange];    //  RECORD on oscillatorChange-1 the postion of oscillatorChange where it has just changed
     
 //    phaseMappedFollow[oscillatorChange]=net.phase[oscillatorChange]; 

  
  
   }
  
   
 //  else key='&';
   
  //**    print (" phaseKeptAtChange[o] ",  oscillatorChange, " ",  phaseKeptAtChange[oscillatorChange] );
      
  //***    println (  " phaseKeptAtChange[k] " , k, " ",  phaseKeptAtChange[k] , " phaseKeptAtChange[j] " , j, " ",  phaseKeptAtChange[j] );
      
  //     LFO[m] = (LFO[m]+map (signal[2], 0, 1, 0, PI/4))%TWO_PI;
  //**     dataMappedForMotor[m]= (int) map (LFO[m], 0, TWO_PI, 0, numberOfStep);
       
   //**    net.phase[m]= map (dataMappedForMotor[m], 0, numberOfStep, 0, TWO_PI);
      
    //   LFO[l] = phaseKeptAtChange[l];
       LFO[l] = LFO[l]%TWO_PI;
       dataMappedForMotor[l]= (int) map (LFO[l], 0, TWO_PI, 0, numberOfStep);
            
       net.phase[l]= map (dataMappedForMotor[l], 0, numberOfStep, 0, TWO_PI);
 
      
//***        LFO[k] = LFO[j]+PI/(15-j)+map (signal[3], 0, 1, 0, TWO_PI);
  //    LFO[k] = phaseKeptAtChange[k]+PI/8;  les redressent de temps en temps
  //***     LFO[k] = LFO[k]%TWO_PI;
  //***     dataMappedForMotor[k]= (int) map (LFO[k], 0, TWO_PI, 0, numberOfStep);
  
  //****        LFO[k] = LFO[j]+PI/(15-k)+map (signal[3], 0, 1, 0, TWO_PI);
  //     LFO[k] = phaseKeptAtChange[k]-PI/8; // ADD SOME SPACE WITH GENERAL ROTATION
 //   LFO[k] = phaseKeptAtChange[k]; //DO NO THING

       LFO[k] = LFO[k]%TWO_PI;
       dataMappedForMotor[k]= (int) map (LFO[k], 0, TWO_PI, 0, numberOfStep);
 
      
       net.phase[k]= map (dataMappedForMotor[k], 0, numberOfStep, 0, TWO_PI);
      
  ///*****     LFO[j] = phaseKeptAtChange[j]+PI/(15-j)+map (signal[3], 0, 1, 0, TWO_PI);
    //**   LFO[j] = phaseKeptAtChange[j]-PI/8;  //ADD SOME SPACE WITH GENERAL ROTATION
  //*** LFO[j] = phaseKeptAtChange[j];  //DO NO THING
       LFO[j] = LFO[j]%TWO_PI;
       dataMappedForMotor[j]= (int) map (LFO[j], 0, TWO_PI, 0, numberOfStep);
  //     println (" phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oscillatorChange]);
       net.phase[j]= map (dataMappedForMotor[j], 0, numberOfStep, 0, TWO_PI);
       
      
  //******** END  Black last oscillator to the lastPhase
 // key ='#'; 
 
   if (keyCode == BACKSPACE ) {
    
      for (int i = 0; i < networkSize-0; i+=1) { 
        println (" ALIGN MTF " );
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
  //  phaseMappedFollow[i]=0;
  //  net.phase[i]=0;
    phaseMapped[i] = phases[i-0][frameCountBis % nbMaxDelais]+0; // to aligin ball with the followed one
   
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=phaseMapped[i];
    net.phase[i]= phaseMapped[i];
       }
        
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=phaseMapped[i];
    net.phase[i]= phaseMapped[i];
  }
 }
 
     for (int i = 0; i < net.size()-0; i+=1) {  // preset trigger to 1 , to not trig

        trigFollowSignalLfo[i]=1;
        TrigmodPos[i]=trigFollowSignalLfo[i];
  // }
   
             // TEST TRIG AND COUNT
     println (" oldOldPositionToMotor[i] ", oldOldPositionToMotor[i], " oldPositionToMotor[i] ", oldPositionToMotor[i], " dataMappedForMotor[i] ", dataMappedForMotor[i], " trigFollowSignalLfo[i] ", trigFollowSignalLfo[i]);

   
         
     if ( oldPositionToMotor[i]< dataMappedForMotor[i] && oldOldPositionToMotor[i]>oldPositionToMotor[i] && oldOldPositionToMotor[i]> (6400-6400/4) ){ //&& dataMappedForMotor[i]< 6400/8 && oldOldPositionToMotor[i]<6400 && oldPositionToMotor[i]>=0 && oldOldPositionToMotor[i]!= oldPositionToMotor[i]
      if (oldOldPositionToMotor[i]> oldPositionToMotor[i]){
     
     //    revLfo[i]++;
     println (" motor " + i + " pass ");
         trigFollowSignalLfo[i]=0;
       
         countFollowSignalLfo[i]++;
      
         TrigmodPos[i]=trigFollowSignalLfo[i];
      }
      }
   
     }
     
   
   
   
   
   
 
    for (int i = 0; i < net.size()-0; i+=1) {

  //**   oldPositionToMotor[i]= positionToMotor[i];
         oldOldPositionToMotor[i]=oldPositionToMotor[i];
         oldPositionToMotor[i]=  dataMappedForMotor[i];
  //**   positionToMotor[i]= ((int) map (net.phase[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //   
     if (net.phase[i]>0){
             dataMappedForMotor[i]= ((int) map (net.phase[i], 0, TWO_PI, 0, numberOfStep)%numberOfStep); //   
     }
   
     else   dataMappedForMotor[i]= ((int) map (net.phase[i], 0, -TWO_PI, numberOfStep, 0)%numberOfStep); //   
   
     }

     for (int i = 0; i <networkSize-0; i+=1) {
        
  //   println ( " " + i +   " net.phase " + net.phase[i] + " dataMappedForMoto " + dataMappedForMotor[i] + " DataToDuePosition[i] " + DataToDueCircularVirtualPosition[i]);
     
    }    
    for (int i = 0; i < networkSize; i++) {
      
        text ("count", -1600, height-500 - 75*i);
        text ( countFollowSignalLfo[i], -1400, height-500 - 75*i);
    
    }   
     oscSend(); 
     
     
//**     print ("  trigFollowSignalLfo ");     showArray(trigFollowSignalLfo);
    print (" countFollowSignalLfo ");     showArray(countFollowSignalLfo);
//    countRevs();
//      printArray(rev);
 
  //   assignMotorWithPosition();
     assignMotorWithDataMapped();
     
    for (int i = 0; i < networkSize; i++) {
     DataToDueCircularVirtualPosition[i] = DataToDueCircularVirtualPosition[i]+ recordLastDataOfMotorPosition[i];
     }
      
    int speedDelta=10;
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    
    
  //    SEND 25 DATAS TO TEENSY
    
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

    //  +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+DataToDueCircularVirtualPosition[9]+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
    //  +   DataToDueCircularVirtualPosition[6]
    +  ","+DataToDueCircularVirtualPosition[5]+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","
    +  ","+DataToDueCircularVirtualPosition[2]+","+DataToDueCircularVirtualPosition[1]+","+DataToDueCircularVirtualPosition[0]+","
    + 0+","+0+","+0+","+0+","

      +  (speedDelta) +","+ driverOnOff +","+dataToTeensyNoJo+","
      
 //     + TrigmodPos[11]+","+TrigmodPos[10]+","+TrigmodPos[9]+","+TrigmodPos[8]+","+TrigmodPos[7]+","+TrigmodPos[6]+","+TrigmodPos[5]+","+TrigmodPos[4]+","+TrigmodPos[3]+","+TrigmodPos[2]+","+TrigmodPos[1]+","+TrigmodPos[0]+ ">";  // to manage 12 note

      +0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+">";    

    println(frameCount + ": " +  " FOLLOWSIGNALToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
  //  DueSerialNativeUSBport101.write(dataMarkedToTeensyNoJo);// Send data to Arduino.
   teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
//  sendToTeensyTurnOnDriver();
  
}
 public void followSignalSampled(int ratioTimeFrame){
  rotate (-PI/2-PI);
  text ( " followSignalSampled ", 400, 400 );
  rotate (PI/2+PI);
 
  int delayRatio=ratioTimeFrame;

//samplingMovement(2);
  samplingMovementPro();
  keyReleasedfollowSignal();
  
  println(frameCount + ": " + ( debug ));

  if (!firstFollowingStarted) {
    float angle = diffAngle(PI + (frameCount / 4.0f) * cos (1000 / 500.0f), 0);
    LFO[2]= map (automation3, 0, 1, 0 , TWO_PI); // signal not used here
  }
  float deltaFollow = PI/180;


 
//**   drawBall(0, phases[0][frameCount % nbMaxDelais]); // affiche le point 0. NE PAS AFFICHER SINON IL APPARAIT EN DOUBLE


  


// ***** MAP movementInterpolated IN good WAY**********
/*
       if (movementInterpolated<0) {
 
    DataToDueCircularVirtualPosition[0]= int (map (movementInterpolated, 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[0]=net.phase[0];
   //*** net.phase[0]= map (DataToDueCircularVirtualPosition[0], numberOfStep, 0, 0, -TWO_PI);
   movementInterpolated = map (DataToDueCircularVirtualPosition[0], numberOfStep, 0, 0, -TWO_PI);
  
  //  net.phase[0]= net.phase[0]%TWO_PI;
     print (" movInter <0 "); print (2);  print ("  "); print ( net.phase[0]);
//   phaseMapped[i] = net.phase[i];
   //  movementInterpolated = net.phase[0];

//    phaseMapped[i]= TWO_PI- (phases[i-2][frameCountBis % nbMaxDelais]); // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy
  //  phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
   // drawBallOppositeWay(  i, phases[i+0][frameCountBis % nbMaxDelais] );
    print ("  movInter<0  "); print (2); print ( " ");   println (  movementInterpolated  ); 
}
   
 
  else  {
  
    DataToDueCircularVirtualPosition[0]= (int) map (movementInterpolated, 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[0]=net.phase[0];
   // net.phase[0]= map (DataToDueCircularVirtualPosition[0], 0, numberOfStep, 0, TWO_PI);
    movementInterpolated= map (DataToDueCircularVirtualPosition[0], 0, numberOfStep, 0, TWO_PI);

  //  net.phase[0]= net.phase[0]%TWO_PI;
   // movementInterpolated = net.phase[0];
    print (" movInter>0 "); print (2);  print ("  "); println ( movementInterpolated);
} 

   //  phases[0][frameCount % nbMaxDelais]=  net.phase[0]; //movementInterpolated;
  phases[0][frameCount % nbMaxDelais]=  movementInterpolated;

  drawBall(0, phases[0][frameCount % nbMaxDelais] );
*/
 // ***** MAP movementInterpolated IN good WAY**********
   phases[0][frameCount % nbMaxDelais]=  movementInterpolated;



   for (int i = 1; i <11 ; i+=1) {  //
    debug ="Normal follow sampled frameMode";
   //    follow( i-1, i, 20 * 0, 0);  // Modifier les deux derniers paramètres : délais et phase
    follow( i-1, i, delayTimeFollowPhase11*frameRatio/ratioTimeFrame, phaseShiftingFollowPhase11);  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6

    //*****   drawBall(i, phaseMapped[i] );
   //drawBall(i, phases[i][frameCount % nbMaxDelais] );

  }

 
  for (int i = 0; i <  networkSize-0; i+=1) {// networkSize-0

    phaseMapped[i]=phases[i-0][frameCount % nbMaxDelais]; // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy
 
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }

 

 
  if (formerFormerKey == '#' || formerKeyMetro == 'J') {
    
      for (int i = 0; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0 ){ //&& phaseMappedFollow[i]<0
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
  }
       
    if (phaseMapped[i]>0 ){ // && phaseMappedFollow[i]>0
    phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }
 }
 
 
    if (formerFormerKey != '#' ) {
    if (formerKeyMetro == 'J' ) {
     phasePattern();
     
    for (int i = 0; i < networkSize-0; i+=1) { 
   //   print ("  BEF phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
    phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] =  phaseMapped[i]+phaseMappedFollow[i];  // add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
   // print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= phaseMapped[i];
       net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);


   }
  }


 }
 
 
  sendToTeensyTurnOnDriver();
  }  

} 
//followSignalSampledOppositeWay.pde

 public void followSignalSampledOppositeWay(int ratioTimeFrame){
  
if (formerDecayTime>decayTime){
  frameCountBis=frameCountBis+1;
  } 
  formerDecayTime = decayTime;
  decayTime = millis()%100;// incremente frameCountBis+1 each 100 millisecondes
 
  int delayRatio=ratioTimeFrame;

     //samplingMovement(2);
      samplingMovementPro();
  //    keyReleasedfollowSignal(); useless  phseShifting is controlled in keyRelesead
      float deltaFollow = TWO_PI; // not used
     //here in a previous function we could change the ball followed if the space of phase between phases[0] and phase 9 is more than 360° for example

 //     phases[0][frameCountBis % nbMaxDelais]= net.phase[networkSize-1]-0;

 
  println ( "  movementInterpolated ", movementInterpolated,
             " oldmovementInterpolated ", oldMovementInterpolated );
    
   
     phases[0][frameCountBis % nbMaxDelais]=movementInterpolated;
     println ( " net.phase[networkSize-1] ",  net.phase[networkSize-1] , " movementInterpolated " , movementInterpolated );
  //    drawBallOppositeWay(0, phases[0][frameCountBis % nbMaxDelais]); //networkSize-5 affiche le point 0. NE PAS AFFICHER SINON IL APPARAIT EN DOUBLE

   
    for (int i = 1; i < networkSize; i+=1) { // 1 follow phase 0
   
    
    //   follow( i-1, i, 20 * i, 0);  // Modifier les deux derniers paramètres : délais et phase
    followOppositeWay( i-1, i+0, delayTimeFollowPhase11*1*frameRatio/ratioTimeFrame, (phaseShiftingFollowPhase11));  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6

 //     drawBall(i, phaseMapped[i] );
    drawBallOppositeWay( i, phases[i+0][frameCountBis % nbMaxDelais] );
    


    phaseMapped[i]=phases[i-0][frameCountBis % nbMaxDelais]; // use varaible phaseMapped (to play movement with time delay or phase delay) to well send it in Teensy
  //  phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
   // drawBallOppositeWay(  i, phases[i+0][frameCountBis % nbMaxDelais] );  
 }
 
 
  if (formerFormerKey == '#' || formerKeyMetro == 'J') {
    

      for (int i = 0; i < networkSize-0; i+=1) { 
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
 //   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
   
    if (phaseMapped[i]<0){
      
    phaseMapped[i] = phaseMappedFollow[i]-phaseMapped[i];
 //   phaseMapped[i] = phaseMapped[i]%TWO_PI;
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
    net.phase[i]= net.phase[i]%TWO_PI;
  }
       
   else
   phaseMapped[i] = phaseMappedFollow[i]+phaseMapped[i];
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
    net.phase[i]= net.phase[i]%TWO_PI;
  }
  
 
  
 }
  
   
    if (formerFormerKey != '#' ) {
    if (formerKeyMetro == 'J' ) {
     phasePattern();
     
    for (int i = 0; i < networkSize-0; i+=1) { 
   //   print ("  BEF phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
    phaseMappedFollow[i]= net.phase[i];
    phaseMapped[i] =  phaseMapped[i]+phaseMappedFollow[i];  // add offset given by pendularPattern
    phaseMapped[i] =  phaseMapped[i]%TWO_PI; 
   // print ("  phaseMapped[i]  ");    println ( phaseMapped[i]  ); 
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   //  net.oldPhase[i]=phaseMapped[i];
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
    net.phase[i]= phaseMapped[i];
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= phaseMapped[i];
       net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);


    }
   }
  }
 
 
 
   if (keyCode == BACKSPACE ) {
    
      for (int i = 0; i < networkSize-0; i+=1) { 
        println (" ALIGN MTF " );
        
  ////*****  phaseMappedFollow[i] = phaseMapped[i];
  //  phaseMappedFollow[i]=0;
  //  net.phase[i]=0;
    phaseMapped[i] = phases[i-0][frameCountBis % nbMaxDelais]+0; // to aligin ball with the followed one
   
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
      net.oldPhase[i]=phaseMapped[i];
     net.phase[i]= phaseMapped[i];
       }
        
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
   net.oldPhase[i]=phaseMapped[i];
    net.phase[i]= phaseMapped[i];
  }
 }
 
 
  //sendToTeensyTurnOnDriver();
  mapDataToMotor();
}
 public void followSignalSampledLPF(int ratioTimeFrame){ // from followSignalLfo
  
  int delayRatio=ratioTimeFrame;

//samplingMovement(2);
  samplingMovementPro();
//  keyReleasedfollowSignal();
  
  println(frameCount + ": " + ( debug ));
//  background(0); 
  
//  rotate(- TWO_PI+ HALF_PI  ); //TO change the beginning of the 0 (cercle trigo) and the cohesion point to - HALF_PI
//  translate(width/2-400, -height/2, -1000);// To set the center of the perspective

  if (!firstFollowingStarted) {
    float angle = diffAngle(PI + (frameCount / 4.0f) * cos (1000 / 500.0f), 0);

//    print ("angle ");
//    println ( angle );
    
    LFO[2]= map (automation3, 0, 1, 0 , TWO_PI); // signal not used here

//**   phases[0][frameCount % nbMaxDelais]= net.phase[networkSize-1];
//**   phases[0][frameCount % nbMaxDelais]= movementInterpolated;
    float LPF= map (automation9, 0, 1, 0 , TWO_PI); // from Ableton
    phases[0][frameCount % nbMaxDelais]=LPF;
//**   drawBall(0, phases[0][frameCount % nbMaxDelais]); // affiche le point 0. NE PAS AFFICHER SINON IL APPARAIT EN DOUBLE
  }

  float deltaFollow = PI/180;

  for (int i = 1; i <networkSize-1 ; i+=1) {  //
    debug ="Normal follow sampled ";
    //   follow( i-1, i, 20 * i, 0);  // Modifier les deux derniers paramètres : délais et phase
   follow( i-1, i, delayTimeFollowPhase11*frameRatio/ratioTimeFrame, phaseShiftingFollowPhase11);  // ici, le temps que les points attendent pour se suivre est de 5 frames, et il faut un espace entre eux de QUARTER_PI/6

    //*****   drawBall(i, phaseMapped[i] );
 //  drawBall(i, phases[i][frameCount % nbMaxDelais] );

  }

  /*
   for(int i = 0; i < nbBall; i++) { //Animation brute sans suivi, juste avec une formule
   //drawBall(i, PI + (i * frameCount / 50.0) * cos (frameCount / 500.0) );
   }*/  // A COMPRENDRE

  if (frameCount > nbMaxDelais/10 && firstFollowingLast == true && abs(diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais])) < deltaFollow ) {
    colorMode(RGB, 255, 255, 255);
    fill( 0, 0, 255 );
 //   println("diffangle" + ": " + diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais]));
//    firstFollowingStarted = true;
    debug ="First follow last";
 //   firstFollowingLast = false;
    println (debug);
  }

  if (firstFollowingStarted) {
    colorMode(RGB, 255, 255, 255);
    fill( 255, 0, 0 );
    debug ="firstFollowingStarted";
  //**  follow(nbBall-1, 0, delayTimeFollowPhase11*frameRatio/ratioTimeFrame , phaseShiftingFollowPhase11);  // Modifier les deux derniers paramètres : délais et phase  delayTimeFollowPhase11, 
  //***  drawBall(0, phases[0][frameCount % nbMaxDelais]);
 //   println ("PHASE MAPPED firstFollowing ");
 //   println("diffangle" + ": " + diffAngle(phases[0][frameCount % nbMaxDelais], phases[nbBall-1][frameCount % nbMaxDelais]));
    
  }
  
 
  for (int i = 0; i <  networkSize-0; i+=1) {// networkSize-0
 //    print (net.oldPhase[i]); print (" 12448 ");   println (net.phase[i]); 
 //   net.oldPhase[i]=phaseMapped[i];
   // phaseMapped[i] = phases[i-2][frameCount % nbMaxDelais]; // JUST ADDED
   phaseMapped[i] = phases[i-0][frameCount % nbMaxDelais]; // JUST ADDED
    phaseMapped[i] = phaseMapped[i] + phaseMappedFollow[i]+phasePatternFollow[i];  // JUST ADDED
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 

 
    if (phaseMapped[i]<0){
   
    DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);
       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep);
    net.oldPhase[i]=net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);
  }

   
  // phasePatternToFollow only when a key is pressed

     if (key != '#'  ) {
       
       phasePattern();
            
    for (int i = 0; i < networkSize; i+=1) { 
 

    phasePatternFollow[i] = net.phase[i];
    phaseMapped[i] =  phaseMapped[i] + phasePatternFollow[i]; // phaseMapped[i] +  //phaseMapped[i]+ add offset given by pendularPattern
    phaseMapped[i] = phaseMapped[i]%TWO_PI; 
    
   
   
    if (phaseMapped[i]<0){
   
     DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (phaseMapped[i], 0, -TWO_PI, numberOfStep, 0)); 
   
    net.oldPhase[i]= net.phase[i];
    net.phase[i]= map (DataToDueCircularVirtualPosition[i], numberOfStep, 0, 0, -TWO_PI);

       }
       
   else
    
    DataToDueCircularVirtualPosition[i]= (int) map (phaseMapped[i], 0, TWO_PI, 0, numberOfStep); 
    net.oldPhase[i]=net.phase[i];

    net.phase[i]= map (DataToDueCircularVirtualPosition[i], 0, numberOfStep, 0, TWO_PI);

  }
 
 } 
//END phasePatternToFollow only when a key is pressed
 
  sendToTeensyTurnOnDriver();
} 

 public void formerKeyo() { 
  print ("circularMov "); 
  println (circularMov);
  //print("inspired from u$ and v$.  funny  "); 

  if (circularMov==false) {
    memoryi=0;
    if (d>=0) {
      timeOffset=d/10;
    }

    if (k>=0) { // k goes from -8 to 8.   you can paramater it at increase phase shifting
      phiShift=k*-PI/32;
      mapShiftPendular= map (phiShift, 0, 16*-PI/32, 0, 1600);
    }
    print (" mapShiftPendular "); 
    println (mapShiftPendular); 

    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= PendularLeftVirtualPosition[i];// -800 à gauche 800 à droite
      PendularOldLeftVirtualPosition[i]=  PendularOldLeftVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= PendularLeftVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]=  PendularOldLeftVirtualPosition[i+1];
    }

    // for (int i = 2; i < (net.size()-1); i++) {//
    for (int i = 2; i < (3); i++) {//test only point 2 and 3

      if (  circularMov==false  && 
        (
        (
        // deplacement point vers la droite

        (PendularOldLeftVirtualPosition[i] <= PendularLeftVirtualPosition[i+1]+mapShiftPendular) && (PendularLeftVirtualPosition[i] >= PendularLeftVirtualPosition[i+1]+mapShiftPendular) &&
        (PendularOldLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i]+800))

        ||


        ((PendularOldLeftVirtualPosition[i] >= PendularLeftVirtualPosition[i+1]-mapShiftPendular) && (PendularLeftVirtualPosition[i] <= PendularLeftVirtualPosition[i+1]-mapShiftPendular) &&
        (PendularOldLeftVirtualPosition[i]+800 > PendularLeftVirtualPosition[i]+800))// movement to the left

        )
        )

      { 
        memoryi=i;
        print (" Before timer net.phase[i] ") ;  
        print (i+1); 
        print (" ") ; 
        println (net.phase[i]) ; //  println();
        print (" metroPhase[i+1] ") ;  
        print (i); 
        print (" ") ; 
        println (metroPhase[i+1]) ; //  println();


        println ("***********************TIME BEFORE TIME OFFSET*******************************************************************") ;  
        print ("Before Automation1[100+i] ") ;  
        print (i); 
        print (" ") ; 
        println (Automation1[100+3]) ; //  println();
        currentTime=millis();
        timer[i]= currentTime - Automation1[100+i+0];
        //  Automation1[100+i+0]=currentTime;
        print ("timer ") ;  
        print (i) ; 
        print (" ");  
        println (timer[i]);  
        pseudoTimer[i]=timer[i];// something to add to the timer?
      }

      if (pseudoTimer[i]>=timeOffset && (PendularOldLeftVirtualPosition[i]+800 <= PendularLeftVirtualPosition[i]+800)// to the right
        ) {

        print (" After timer net.phase[i] ") ;  
        print (i); 
        print (" ") ; 
        println (net.phase[i]) ; //  println();
        net.phase[i+1]=   net.phase[i]-phiShift*0; 
        net.phase[i+1]=   net.phase[i+1]%TWO_PI; 
        print (" metroPhase[i+1] ") ;  
        print (i+1); 
        print (" ") ; 
        println (metroPhase[i+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=i;  

        Automation1[100+i+0]=currentTime;

        println ("***********************TIME AFTER TIME OFFSET*******************************************************************") ;  

        print ("After  Automation1[100+i] ") ;  
        print (i); 
        print (" ") ; 
        print (Automation1[100+i]) ; //  println();
        print (" pseudoTimer[i] to compare at timer ") ;  
        print (i); 
        print (" ") ; 
        print (pseudoTimer[i]) ; //  println();
        print (" memoryi= ");  
        println (memoryi); // to show which point is changing its position
      }

      if (pseudoTimer[i]>=timeOffset && (PendularOldLeftVirtualPosition[i]+800 >= PendularLeftVirtualPosition[i]+800)// to the right
        ) {

        net.phase[i+1]=   net.phase[i]+phiShift*0; 
        net.phase[i+1]=   net.phase[i+1]%TWO_PI; 

        /*
           metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */

        memoryi=i;  

        Automation1[100+i+0]=currentTime;

        println ("***********************TIME AFTER TIME OFFSET*******************************************************************") ;  

        print ("After  Automation1[100+i] ") ;  
        print (i); 
        print (" ") ; 
        print (Automation1[100+i]) ; //  println();
        print (" pseudoTimer[i] ") ;  
        print (i); 
        print (" ") ; 
        print (pseudoTimer[i]) ; //  println();
        print (" memoryi= ");  
        print (memoryi); // to show which point is changing its position
      }
    }
    // }
    //  OSCILLATOR 11 give his position to oscillator 2
    ///*
    if ((  circularMov==false  && 
      (PendularOldLeftVirtualPosition[11] <= PendularLeftVirtualPosition[2]+mapShiftPendular) && (PendularLeftVirtualPosition[11] >= PendularLeftVirtualPosition[2]+mapShiftPendular) &&
      (PendularOldLeftVirtualPosition[11]+800*0.01f < PendularLeftVirtualPosition[11]+800*0.01f))

      ||

      //((PendularLeftVirtualPosition[2+1]>PendularLeftVirtualPosition[2]&&PendularLeftVirtualPosition[2+1]>-400 && PendularLeftVirtualPosition[2]>-400  )) && 

      ((PendularOldLeftVirtualPosition[11] >= PendularLeftVirtualPosition[2]-mapShiftPendular) && (PendularLeftVirtualPosition[11] <= PendularLeftVirtualPosition[2]-mapShiftPendular) &&
      (PendularOldLeftVirtualPosition[11]+800*0.01f > PendularLeftVirtualPosition[11]+800*0.01f))

      )

    { 

      println ("******************************TIME 11 BEFORE TIME OFFSET************************************************************") ;  
      print ("Before Automation1[100+11] ") ;  
      print (11); 
      print (" ") ; 
      println (Automation1[100+11]) ; //  println();
      int currentTime=millis();
      timer[11]= currentTime - Automation1[100+11+0];
      //  Automation1[100+11+0]=currentTime;
      print ("timer ") ;   
      println (timer[11]) ;  
      pseudoTimer[11]=timer[11];

      if (pseudoTimer[11]>=timeOffset //&& (Automation1[100+2]>Automation1[100+3])
        ) {
        /*
           net.phase[2]=   net.phase[11]-phiShift*0; 
         net.phase[2]=   net.phase[2]%TWO_PI;
         */
        /*
           metroPhase[2]=   metroPhase[11]+phiShift; 
         metroPhase[2]=   metroPhase[2]%TWO_PI;
         net.phase[2]=    metroPhase[2]%TWO_PI; 
         */
        memoryi=11;  
        //   Automation1[100+2]=Automation1[100+2];
        Automation1[100+11+0]=currentTime;

        println ("******************************AFTER 11 BEFORE TIME OFFSET************************************************************") ;  
        print ("After Automation1[100+11] ") ;  
        print (11); 
        print (" ") ; 
        println (Automation1[100+11]) ; //  println();

        print ("pseudoTimer[i] ") ;  
        print (11); 
        print (" ") ; 
        print (pseudoTimer[11]) ; //  println();

        print (" memoryi= ");  
        print (memoryi);
      }
    }
  } 
  //*/
  ///*******end of pendular shifting




  if (circularMov==true ) { 
    print ("Beginning circularMov "); 
    println (circularMov);
    if (d>=0) {
      timeOffset=d; // timeOffset in millis (50,.. 1000 ms),  before changing phase i+1 with the phase from i
    }   
    if (k>=0) {
      phiShift=k*-PI/64; // here the position to add or substrat to the next point (i+1)
      mapShiftCircular= map (phiShift, 0, 16*-PI/16, 0, 6400);   // one revolution is 6400 step 
      //  mapShiftCircular is the space to reach in order to follow the previous point
    }
    formerEvent[0]=millis();   // time from the beginning of the launch of the program.
    print (" timeOffset "); 
    print ( timeOffset ); 
    print ( "mapShiftCircular ");   
    print ( mapShiftCircular ); 

    for (int j = 2; j < (4); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("2**********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();

        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("2**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }


      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];
      }
    }     




    // end 2 3 

    for (int j = 3; j < (5); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("3**********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();


        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("3**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }

      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];

        //   CircularOldVirtualPosition[j]= CircularOldVirtualPosition[j];
      }

      // end 3 4
    }

    for (int j = 4; j < (5); j++) {

      if ( circularMov==true  && //( // circularMov==true

        ((CircularOldVirtualPosition[j] <= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[j+1]+mapShiftCircular) &&
        (CircularOldVirtualPosition[j] < CircularVirtualPosition[j]))// space CW
      /*
      ||
       
       ((CircularOldVirtualPosition[j] >= CircularOldVirtualPosition[j+1]+mapShiftCircular) && (CircularVirtualPosition[j] <= CircularVirtualPosition[j+1]+mapShiftCircular) &&
       (CircularOldVirtualPosition[j] >= CircularVirtualPosition[j]))// time CCW
       */
        )

      {  
        println ("4 *********************TRIGGED with PHASE OFFSET*******************") ;
        print ("before net.phase[j+1]= "); 
        print (j+1); 
        print (" ");  
        println (net.phase[j+1]);
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        print ("formerEvent[2] ") ;  
        print (2); 
        print (" ") ; 
        println (formerEvent[2]) ; //  println();
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        followNumber[j]= true;
        formerEvent[j]=formerEvent[0]; // set formerEvent[j] to actual time
      }

      //   else followNumber[j]= false;

      if ( formerEvent[0]>=formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j]<= CircularVirtualPosition[j]) && followNumber[j]== true//
        ) {

        print ("CW After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
        //  net.phase[j+1]=(net.phase[j]);// 

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();


        followNumber[j]= false;
        memoryi=j;  
        //    formerEvent[j]=formerEvent[0];


        println ("4**********************TIME AFTER TIME  OFFSET CW") ;  

        //   print ("After  Automation1[100+i] ") ;  print (j); print (" ") ; print (Automation1[100+j]) ; //  test with pendular
        //    print (" pseudoTimer[i] to compare at timer ") ;  print (j); print (" ") ; print (pseudoTimer[j]) ; //  test with pendular
        print (" Timer[j+1] to compare at timer ") ;  
        print (j+1); 
        print (" ") ; 
        print (formerEvent[j+1]) ; //  test with pendular
        print (" memoryiCircular= ");  
        print (memoryi);
        print (" followNumber "); 
        print (j); 
        print (" "); 
        println (followNumber[j]);
      }
      if ( formerEvent[0]>formerEvent[j]+timeOffset  && (CircularOldVirtualPosition[j] > CircularVirtualPosition[j])// CCW && followNumber[j]== false
        ) {
        // background(50);
        print ("After timer formerEvent[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (formerEvent[j+1]) ; //  println();
        print ("CCW After timer net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]);
        //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4

        net.phase[j+1]=(net.phase[j])-phiShift*0;// 
        net.phase[j+1]= net.phase[j+1]%(TWO_PI*1);//  keep phase between 0 and TWO_PI

        print ("CCW After timer & phase net.phase[j]= ");  
        print (j+1); 
        print (" ") ;
        println (net.phase[j+1]); 
        print (" metroPhase[j+1] ") ;  
        print (j+1); 
        print (" ") ; 
        println (metroPhase[j+1]) ; //  println();
        /* 
         print (" metroPhase[i+1] ") ;  print (i+1); print (" ") ; println (metroPhase[i+1]) ; //  println();
         metroPhase[i+1]=   metroPhase[i]+phiShift*0; 
         metroPhase[i+1]=   metroPhase[i+1]%-TWO_PI;
         net.phase[i+1]=    metroPhase[i+1]%TWO_PI;
         */


        memoryi=j;  
        //      formerEvent[j]=formerEvent[0];
      }

      // end 4 5
    } 

    // OSCILLATOR 11 gives its position to 2
    /*
      for (int j = 11; j < (12); j++) {
     
     if ( circularMov==true  && //( // circularMov==true
     
     ((CircularOldVirtualPosition[j] <= CircularVirtualPosition[2]+mapShiftCircular) && (CircularVirtualPosition[j] >= CircularVirtualPosition[2]+mapShiftCircular) &&
     (CircularOldVirtualPosition[j]+800*0.1 < CircularVirtualPosition[j]+800*0.1))
     
     ||
     
     ((CircularOldVirtualPosition[j]+mapShiftCircular >= CircularVirtualPosition[2]) && (CircularVirtualPosition[j]<= CircularVirtualPosition[2]+mapShiftCircular) &&
     (CircularOldVirtualPosition[j]+800*0.1 > CircularVirtualPosition[j]+800*0.1))
     
     )
     
     { 
     followNumber[j]= true;
     formerEvent[12]=formerEvent[0];
     }
     else followNumber[j]= false;
     
     if  (
     formerEvent[0]>formerEvent[12]+timeOffset && followNumber[j]== false
     ){
     //  background (127, 50,50);
     print ("formerEvent[0] ") ;  print (2); print (" ") ; print (formerEvent[0]) ; //  println();
     print ("formerEvent[2] ") ;  print (2); print (" ") ; println (formerEvent[2]) ; //  println();
     //  net.phase[i+1]=(net.phase[i])+phiShift;// fun at speed -4
     net.phase[2]=(net.phase[j]);// 
     net.phase[2]= net.phase[2]%TWO_PI;//  keep phase between 0 and TWO_PI
     
     memoryi=j;  
     formerEvent[2]=formerEvent[0];
     
     print (" memoryiCircular= ");  print (memoryi);
     print (" followNumber ");  print (followNumber[j]);
     
     }
     
     }
     */
  }// end formerKeyO
}
//upstairv

 public void formerKeyv(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) { 

  print (" phaseDecay ");  
  print (phaseDecay);
  float PhaseDecay=phaseDecay*QUARTER_PI/4; // if K=8 --> PhaseDecay=HALF_PI
  int PhaseDecayMapped = (int)  map (PhaseDecay, 0, HALF_PI, 0, 800);
  print (" PhaseDecay ");
  print (PhaseDecay);  
  print (" PhaseDecayMapped ");
  print (PhaseDecayMapped);
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );

  if ( metroPhase[memoryi]<=0 &&  metroPhase[memoryi]>=-PI ) {
    factorWay[memoryi]=true;
    print ("  factorWay "); 
    print (memoryi);  
    print (" "); 
    print (factorWay[memoryi]);
  } else factorWay[memoryi]=false;  

  if ( metroPhase[oldMemoryi]<=0 &&  metroPhase[oldMemoryi]>=-PI) {
    factorWay[oldMemoryi]=true;
  } else factorWay[oldMemoryi]=false; 

  print ("  factorWayO "); 
  print (oldMemoryi);  
  print (" "); 
  print (factorWay[oldMemoryi]);     
  print ("  factorWayM "); 
  print (memoryi);  
  print (" "); 
  print (factorWay[memoryi]);     

  for (int j = 2; j < 12; j++) {

    if ((metroOldPhase[j] <= PI && metroOldPhase[j] >= 0 &&  metroPhase[j] <= metroOldPhase[j] )||   //CCW
      (metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j] <= metroOldPhase[j] )) {
      clockWay[j]= false;
    }
    if ((metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j]<=0 &&  metroPhase[j] >= metroOldPhase[j] )||
      (metroOldPhase[j] <= PI  && metroOldPhase[j] >= 0 &&  metroPhase[j]>=0 &&  metroPhase[j] >= metroOldPhase[j] )) { 
      clockWay[j]= true;
    }



    //       metroOldOldPhase[j]=metroOldPhase[j];
    metroOldPhase[j]= (metroPhase[j]);
    //**       PhaseDecay[j]=factorWay[j]*phaseDecay*QUARTER_PI/2;
    //       PhaseDecay[j]= phaseDecay*QUARTER_PI/2;
  }

  //**    PhaseDecay[memoryi]=factorWay[memoryi]*phaseDecay*QUARTER_PI/2;
  print ("  clockWay "); 
  print (memoryi);  
  print (" "); 
  println ( clockWay[memoryi]);
  print ("  clockWayOld "); 
  print (oldMemoryi);  
  print (" "); 
  println ( clockWay[oldMemoryi]);
  // print ("  clockWaySuiv "); print (memoryi+1);  print (" "); println ( clockWay[memoryi+1]);

  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-0); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];      
      print ("PendularLeftVirtualPosition ");
      print (i);
      print (" "); 
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      println (CircularVirtualPosition[i]);
    }
  } 
  if (circularMov==false ) {
    for (int i = 0; i < (net.size()-0); i++) {
      upstairOldVpos[i] = upstairVpos[i];
      upstairVpos[i]= (int) map (PendularLeftVirtualPosition[i], -800, 800, 0, 3200);
      print (" PendularOldLeftVirtualPosition[i] ");
      print (i);
      print (" ");  
      print (PendularOldLeftVirtualPosition[i]);   
      print (" upstairOldVpos ");
      print (i);
      print (" "); 
      print (upstairOldVpos[i]); 
      print ("upstairVpos "); 
      print (i); 
      print (" ");   
      println (upstairVpos[i]);
    }
  } 
  //  deblockPendular(); 

  if ( memoryi<net.size()-1   ) {// oldMemory=memoryi+1; 4<=5 for example
    if ((((upstairOldVpos[memoryi]%3200 <= upstairVpos[oldMemoryi]%3200+PhaseDecayMapped*ClockWay[memoryi]*0) && (upstairVpos[memoryi]%3200 > upstairVpos[oldMemoryi]%3200+PhaseDecayMapped*ClockWay[memoryi]*0) && 
      (upstairOldVpos[memoryi]%3200 < upstairVpos[memoryi]%3200)) ||  //CW
      ( (upstairOldVpos[memoryi]%3200 >= upstairVpos[oldMemoryi]%3200+PhaseDecayMapped*ClockWay[memoryi]*0) && (upstairVpos[memoryi]%3200 < upstairVpos[oldMemoryi]%3200+PhaseDecayMapped*ClockWay[memoryi]*0) &&
      (upstairOldVpos[memoryi]%3200 > upstairVpos[memoryi]%3200) ) ) ||  // CCW
      (   (metroPhase[2]-metroPhase[11] <=0)  ||  (metroPhase[11]-metroPhase[2] <=0)  )
      ) {

      if (memoryi>1  && memoryi<11 ) { //  &&   clockWay[memoryi]== false

        net.phase[memoryi]= net.phase[memoryi+1]-PhaseDecay*0;// 
        //   net.phase[memoryi+1]= net.phase[memoryi+1]+PhaseDecay*1;//%TWO_PI;// +PhaseDecay is Clock WAY =0 
        net.phase[memoryi+1]= (net.phase[memoryi+1]-PhaseDecay*1)%TWO_PI;//;// +PhaseDecay is Clock WAY =0 

        net.naturalFrequency[memoryi+1]= net.naturalFrequency[memoryi];
        net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi-1];

        oldMemoryi=memoryi;      
        OldoscillatorMoving=oldMemoryi;
        oldMemoryi=OldoscillatorMoving;
        oscillatorMoving=memoryi+1;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame you'll moving to  ");
        println (oscillatorMoving);
      } 
      /* 
       if (memoryi>1  &&   clockWay[memoryi]== true && memoryi<11 ) {
       
       metroPhase[memoryi]=   metroPhase[memoryi+1]+PhaseDecay;// 
       metroPhase[memoryi+1]= metroPhase[memoryi+1]-PhaseDecay;// +PhaseDecay is Clock WAY =0 
       
       net.naturalFrequency[memoryi+1]=  net.naturalFrequency[memoryi];
       net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi-1];
       
       oldMemoryi=memoryi;      
       OldoscillatorMoving=oldMemoryi;
       oldMemoryi=OldoscillatorMoving;
       oscillatorMoving=memoryi+1;
       memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
       print ("Next frame  and clock way = true you'll moving to  ");
       println (oscillatorMoving);         
       } 
       */
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;

      key='z';
    }
  }
  //  deblockPendular();     
  if ((upstairOldVpos[net.size()-1]%3200 <= upstairVpos[10]%3200) && (upstairVpos[net.size()-1]%3200 > upstairVpos[10]%3200)&& (upstairOldVpos[net.size()-1]%3200 < upstairVpos[net.size()-1]%3200) ||
    ( (upstairOldVpos[net.size()-1]%3200 >= upstairVpos[10]%3200) && (upstairVpos[net.size()-1]%3200 < upstairVpos[10]%3200)&& (upstairOldVpos[net.size()-1]%3200 > upstairVpos[net.size()-1]%3200+800)) ||
    (  (metroPhase[11]-metroPhase[2] <=-PI+PhaseDecay)  ||  (metroPhase[2]-metroPhase[11] <=-PI+PhaseDecay) ) //(metroPhase[memoryi]-metroPhase[oldMemoryi] <=-PI-PhaseDecay)  ||  (metroPhase[memoryi]-metroPhase[oldMemoryi] >=PI+PhaseDecay) //  (metroPhase[memoryi]-metroPhase[oldMemoryi] <=-PI-PhaseDecay)  ||  (metroPhase[oldMemoryi]-metroPhase[memoryi] <=-PI-PhaseDecay)
    ) {
    net.phase[2]=   net.phase[1]-PhaseDecay*0;


    net.phase[11]=  (net.phase[11]-PhaseDecay*1)%TWO_PI;//%TWO_PI; //No sens , but to do when phase is <0
    net.naturalFrequency[2]=   net.naturalFrequency[11];
    net.naturalFrequency[11]= net.naturalFrequency[10];

    print ("Where is you oscillator, your memory ? ");
    println (oscillatorMoving); 
    print (" "); 
    println (memoryi);
    print ("you are coming back to  oscillatorMoving 2   ");

    OldoscillatorMoving=net.size()-1;
    oldMemoryi=OldoscillatorMoving; 

    oscillatorMoving=2 ;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving

    println (oscillatorMoving); 
    print (" "); 
    println (memoryi);

    oldOscillatorMoving[net.size()-1]= false;
    OscillatorMoving[memoryi]= true;

    print ("oldOscillatorMoving "); 
    print (11); 
    print (" ");   
    print (oldOscillatorMoving[11]); 
    print ("OscillatorMoving "); 
    print (2); 
    print (" ");   
    println (OscillatorMoving[2]); 

    key='e';
  }
  // deblockPendular();
  print (" ENDUPSTAIRv " ); 
  
  print (" BeforeOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OldoscillatorMoving ");     
  println ( oldOscillatorMoving[OldoscillatorMoving]);

  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOldoscillatorMoving ");  
  println ( oldOscillatorMoving[oscillatorMoving] );
}  
//upstairwi;
// upstairwioppositeway
//starterw
 public void formerKeyCopposite(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) {   // based on i$ 6, 5, 4 ...,  2, 11

pendularPatternLFO();  // function at the top of function with starter in main program

 // PhaseDecay[5]=k*QUARTER_PI/8;
// PhaseDecay[5]=k;
 PhaseDecay[5]=QUARTER_PI/8;
    print (" phaseDecay in starterw ");  print (phaseDecay);  print (" phaseDecay5 ");   print (PhaseDecay[5]); 

  float PhaseDecayBis=phaseDecay*QUARTER_PI/8; // QUARTER_PI/8 if K=8 --> PhaseDecay=HALF_PI/2
  int PhaseDecayMapped = (int)  map (PhaseDecayBis, 0, HALF_PI, 0, 800); 
 
  print (" PhaseDecayMapped ");  print (PhaseDecayMapped);  print (" oldMemoryi ");    print (oldMemoryi );  print (" memoryi ");    println ( memoryi );

  if ( metroPhase[memoryi]<=0 &&  metroPhase[memoryi]>=-PI ) { // to know where the ball moving is (left or right)
    factorWay[memoryi]=true;
    print ("  factorWay ");     print (memoryi);      print (" ");     print (factorWay[memoryi]);
  } else factorWay[memoryi]=false;  // memoryi is on the part right  

  if ( metroPhase[oldMemoryi]<=0 &&  metroPhase[oldMemoryi]>=-PI) {
    factorWay[oldMemoryi]=true;
  } else factorWay[oldMemoryi]=false; 

  print ("  factorWayO ");   print (oldMemoryi);    print (" ");   print (factorWay[oldMemoryi]);      print ("  factorWayM ");   print (memoryi);    print (" ");  print (factorWay[memoryi]);     
  for (int j = 0; j < networkSize; j++) { // to know if the ball turns on ClockWise or counterclockwise

    if ((metroOldPhase[j] <= PI && metroOldPhase[j] >= 0 &&  metroPhase[j] <= metroOldPhase[j] )||   //CCW
        (metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j] <= metroOldPhase[j] )) {
      clockWay[j]= false;
    }
    if ((metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j]<=0 &&  metroPhase[j] >= metroOldPhase[j] )||
        (metroOldPhase[j] <= PI  && metroOldPhase[j] >= 0 &&  metroPhase[j]>=0 &&  metroPhase[j] >= metroOldPhase[j] )) { 
      clockWay[j]= true;
    }
    PhaseDecay[j]= phaseDecay*QUARTER_PI/16;    // specif decay used in deblock
  }

  print ("  clockWay ");  print (memoryi);  print (" ");  println ( clockWay[memoryi]); print ("  clockWayOld ");  print (oldMemoryi);   print (" "); println ( clockWay[oldMemoryi]);

  if ( memoryi<=net.size()-0  ) {  // oldMemory=memoryi+1; 4<=5 for example
    print (" BEFORE CHRO WI upstair Time ");          println (  upstairTime );  // condition below is not always respected

    if (( millis()>= upstairTime-10 && ( (net.phase[memoryi]) >=  (interPhase[memoryi]+PhaseDecay[5]) ) && net.naturalFrequency[memoryi]>0   )  
      ||     ( millis()>= upstairTime-10 && ( (net.phase[memoryi]) <=  (interPhaseCircular[oldMemoryi]-PhaseDecay[5]) ) && net.naturalFrequency[memoryi]<0 )
      ) { //  ||  (  (net.phase[memoryi]) <=  (A-interPhase[memoryi]-PhaseDecay[5]) ))) {
      print (" AFTER  CHRO WI  Frequencey > O upstair Time");                  println (upstairTime); 
      upstairTime = millis()+d;

      oldMemoryi=memoryi-1;
      if ( oldMemoryi<=1) {
        oldMemoryi=11;
      }   

      metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];
      net.phase[oldMemoryi]=  net.phase [memoryi];
      interPhase[memoryi]=  net.phase[oldMemoryi]; 
      interPhaseCircular[memoryi]=  net.phase[oldMemoryi]; 

      key='e'; //restart test condition
      net.naturalFrequency[memoryi]= 0;

      if ( millis()>=  TimeTrigged ) {

        TimeTrigged = millis() + d/10;
        key='#'; // do not use interphase[memoryi] from beginning       
        net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
      }

      interFrequency[oldMemoryi]= interFrequency[memoryi];

      print (" FIRST CHRO WI upstairTime");          println (upstairTime); 
      OldoscillatorMoving=memoryi;
      oldMemoryi=OldoscillatorMoving;

      memoryi=(memoryi-1)%networkSize;
      print (" memoryi "); println (memoryi);
      if ( memoryi<=1) {
        memoryi=11;
      }

      oscillatorMoving=memoryi;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
      print ("Next frame  and clock way = true you'll moving to  ");     println (oscillatorMoving); 
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;
      key='e';
    }
    deblockPendulari(); // only work in pendular way
    deblockCircularwi(); // only work in circular way
  }   

  print (" ENDformerKeyCopposite " );   print (" BeforeOscillatorMoving ");    println ( OldoscillatorMoving );
  print (" OldoscillatorMoving ");       println ( oldOscillatorMoving[OldoscillatorMoving]); 
  print (" BeginINToscillatorMoving ");    println ( oscillatorMoving );  print (" BOOLoscillatorMoving ");    println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOldoscillatorMoving ");   println ( oldOscillatorMoving[oscillatorMoving] );

  if (circularMov==false ) {
    for (int j = 0; j < (networkSize-0); j++) {
      metroOldPhase[j]= (metroPhase[j]);
    }
  }
}
//upstairwi;

 public void formerKeyC(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) {   // based on i$ 6, 5, 4 ...,  2, 11

  print (" phaseDecay ");  
  print (phaseDecay);
  print (" phaseDecay5 ");  
  print (PhaseDecay[5]); 
  float PhaseDecayBis=phaseDecay*QUARTER_PI/8; // if K=8 --> PhaseDecay=HALF_PI    /// QUARTER_PI/8 if K=8 --> PhaseDecay=HALF_PI/2
  int PhaseDecayMapped = (int)  map (PhaseDecayBis, 0, HALF_PI, 0, 800);
  print (" PhaseDecay ");
  print (PhaseDecay);  
  print (" PhaseDecayMapped ");
  print (PhaseDecayMapped);
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );

  if ( metroPhase[memoryi]<=0 &&  metroPhase[memoryi]>=-PI ) {
    factorWay[memoryi]=true;
    print ("  factorWay "); 
    print (memoryi);  
    print (" "); 
    print (factorWay[memoryi]);
  } else factorWay[memoryi]=false;  // memoryi is on the part right  

  if ( metroPhase[oldMemoryi]<=0 &&  metroPhase[oldMemoryi]>=-PI) {
    factorWay[oldMemoryi]=true;
  } else factorWay[oldMemoryi]=false; 

  print ("  factorWayO "); 
  print (oldMemoryi);  
  print (" "); 
  print (factorWay[oldMemoryi]);     
  print ("  factorWayM "); 
  print (memoryi);  
  print (" "); 
  print (factorWay[memoryi]);     

  for (int j = 0; j < networkSize; j++) {

    if ((metroOldPhase[j] <= PI && metroOldPhase[j] >= 0 &&  metroPhase[j] <= metroOldPhase[j] )||   //CCW
      (metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j] <= metroOldPhase[j] )) {
      clockWay[j]= false;
    }
    if ((metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j]<=0 &&  metroPhase[j] >= metroOldPhase[j] )||
      (metroOldPhase[j] <= PI  && metroOldPhase[j] >= 0 &&  metroPhase[j]>=0 &&  metroPhase[j] >= metroOldPhase[j] )) { 
      clockWay[j]= true;
    }
    //*     PhaseDecay[j]=factorWay[j]*phaseDecay*QUARTER_PI/2;
    PhaseDecay[j]= phaseDecay*QUARTER_PI/16;    // specif decay used in deblock
  }

  //**    PhaseDecay[memoryi]=factorWay[memoryi]*phaseDecay*QUARTER_PI/2;
  print ("  clockWay "); 
  print (memoryi);  
  print (" "); 
  println ( clockWay[memoryi]);
  print ("  clockWayOld "); 
  print (oldMemoryi);  
  print (" "); 
  println ( clockWay[oldMemoryi]);
  // print ("  clockWaySuiv "); print (memoryi+1);  print (" "); println ( clockWay[memoryi+1]);

  deblockPendulari(); // only work in pendular way
  deblockCirculari(); // only work in pendular way

  if ( memoryi<=networkSize-0  ) {  // oldMemory=memoryi+1; 4<=5 for example

    println (" BEFORE CHRO ");      
    println (  upstairTime );

    //      when you tap x interphase[memoryi] is recorded as metroPhase [memoryi];          
    //     interPhase[memoryi]= metroPhase[memoryi]; do not work
    //      interPhaseCircular[memoryi]= net. phase[oldMemoryi];


    if ( millis()>= upstairTime-10 && net.phase[memoryi]>= interPhase[memoryi]+(PhaseDecay[5]/5)) {


      if ( memoryi>1  && memoryi<networkSize  && net.phase[memoryi]>= interPhase[memoryi]+(PhaseDecay[5]/5)

        //   || ( (TrigmodPos[memoryi]>=0 && TrigmodPos[memoryi]<=0  ) || (  revolution[memoryi]>=0 && revolution[memoryi]<=0  ))  

        ) {


        print (" AFTER  CHRO ");            
        println (upstairTime); 
        upstairTime = millis()+10;

        oldMemoryi=memoryi-1;
        if ( oldMemoryi<=-1) {
          oldMemoryi=networkSize-1;
        }   

        metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];

        net.phase[oldMemoryi]=  net.phase [memoryi];

        interPhase[memoryi]=  net.phase[oldMemoryi]; 

        //   key='#'; // do not use interphase[memoryi] from beginning  
        key='e'; //restart test condition
        net.naturalFrequency[memoryi]= 0;

        if ( millis()>=  TimeTrigged ) {

          TimeTrigged = millis() +d/10;
          key='#'; // do not use interphase[memoryi] from beginning       
          net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
        }

        interFrequency[oldMemoryi]= interFrequency[memoryi];

        print (" FIRST CHRO ");          
        println (upstairTime); 

        //   upstairTime = millis() + 500;

        OldoscillatorMoving=memoryi;
        oldMemoryi=OldoscillatorMoving;

        memoryi=(memoryi-1)%networkSize;
        print (" memoryi ");
        println (memoryi);
        if ( memoryi<=-1) {
          memoryi=networkSize-1;
        }

        oscillatorMoving=memoryi;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame  and clock way = true you'll moving to  ");
        println (oscillatorMoving); 
        oldOscillatorMoving[oldMemoryi]= false;
        OscillatorMoving[memoryi]= true;
        key='e';
      }
      print (" ENDupstairi?? " ); 
      print (" END FUNCTION SITUATION " ); 
      print (" END FUNCTION SITUATION " );   
      print (" BeforeOscillatorMoving ");  
      println ( OldoscillatorMoving );
      print (" OldoscillatorMoving ");     
      println ( oldOscillatorMoving[OldoscillatorMoving]);

      print (" BeginINToscillatorMoving ");  
      println ( oscillatorMoving );
      print (" BOOLoscillatorMoving ");  
      println ( OscillatorMoving[oscillatorMoving] );
      print (" BOOLOldoscillatorMoving ");  
      println ( oldOscillatorMoving[oscillatorMoving] );

      if (circularMov==false ) {
        for (int j = 0; j < (networkSize); j++) {
          metroOldPhase[j]= (metroPhase[j]);
        }
      }
    }
  }
}
//upstairw call formerKeyw
 public void formerKeyCu$(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) {   // based on u$ 4, 5, 6....

  print (" phaseDecay ");  
  print (phaseDecay);
  print (" phaseDecay5 ");  
  print (PhaseDecay[5]); 
  float PhaseDecayBis=phaseDecay*QUARTER_PI/4; // if K=8 --> PhaseDecay=HALF_PI
  int PhaseDecayMapped = (int)  map (PhaseDecayBis, 0, HALF_PI, 0, 800);
  print (" PhaseDecay ");
  print (PhaseDecay);  
  print (" PhaseDecayMapped ");
  print (PhaseDecayMapped);
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );

  if ( metroPhase[memoryi]<=0 &&  metroPhase[memoryi]>=-PI ) {
    factorWay[memoryi]=true;
    print ("  factorWay "); 
    print (memoryi);  
    print (" "); 
    print (factorWay[memoryi]);
  } else factorWay[memoryi]=false;  // memoryi is on the part right  

  if ( metroPhase[oldMemoryi]<=0 &&  metroPhase[oldMemoryi]>=-PI) {
    factorWay[oldMemoryi]=true;
  } else factorWay[oldMemoryi]=false; 

  print ("  factorWayO "); 
  print (oldMemoryi);  
  print (" "); 
  print (factorWay[oldMemoryi]);     
  print ("  factorWayM "); 
  print (memoryi);  
  print (" "); 
  print (factorWay[memoryi]);     

  for (int j = 0; j < networkSize; j++) {

    if ((metroOldPhase[j] <= PI && metroOldPhase[j] >= 0 &&  metroPhase[j] <= metroOldPhase[j] )||   //CCW
      (metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j] <= metroOldPhase[j] )) {
      clockWay[j]= false;
    }
    if ((metroOldPhase[j] >= -PI && metroOldPhase[j] <= 0 &&  metroPhase[j]<=0 &&  metroPhase[j] >= metroOldPhase[j] )||
      (metroOldPhase[j] <= PI  && metroOldPhase[j] >= 0 &&  metroPhase[j]>=0 &&  metroPhase[j] >= metroOldPhase[j] )) { 
      clockWay[j]= true;
    }
    //*     PhaseDecay[j]=factorWay[j]*phaseDecay*QUARTER_PI/2;
    PhaseDecay[j]= phaseDecay*QUARTER_PI/16;    // specif decay used in deblock
  }

  //**    PhaseDecay[memoryi]=factorWay[memoryi]*phaseDecay*QUARTER_PI/2;
  print ("  clockWay "); 
  print (memoryi);  
  print (" "); 
  println ( clockWay[memoryi]);
  print ("  clockWayOld "); 
  print (oldMemoryi);  
  print (" "); 
  println ( clockWay[oldMemoryi]);
  // print ("  clockWaySuiv "); print (memoryi+1);  print (" "); println ( clockWay[memoryi+1]);

  deblockPendularu();
  deblockCircularu();

  if ( memoryi<=net.size()-0  ) {  // oldMemory=memoryi+1; 4<=5 for example

    println (" BEFORE CHRO ");      
    println (  upstairTime );

    //      when you tap x interphase[memoryi] is recorded as metroPhase [memoryi];          
    //     interPhase[memoryi]= metroPhase[memoryi]; do not work
    //      interPhaseCircular[memoryi]= net. phase[oldMemoryi];


    if ( millis()>= upstairTime && net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) {

      if (memoryi>1  && memoryi<networkSize  && net.phase[memoryi]>= interPhase[memoryi]+PhaseDecay[5]) { //  &&   clockWay[memoryi]== false
        print (" AFTER  CHRO ");            
        println (upstairTime); 
        upstairTime = millis()+10;

        oldMemoryi=(memoryi+1)%networkSize;
        if ( oldMemoryi<=0) {
          oldMemoryi=0;
        }

        metroPhase[oldMemoryi]= metroPhase [memoryi];// TrigRightTemp[oldMemoryi];

        net.phase[oldMemoryi]=  net.phase [memoryi];

        interPhase[memoryi]=  net.phase[oldMemoryi]; 

        //   key='#'; // do not use interphase[memoryi] from beginning  
        key='e'; //restart test condition
        net.naturalFrequency[memoryi]= 0;
        if ( millis()>=  TimeTrigged ) {
          TimeTrigged = millis() +10;
          key='#'; // do not use interphase[memoryi] from beginning       
          net.naturalFrequency[oldMemoryi]=   interFrequency[memoryi];
        }

        interFrequency[oldMemoryi]= interFrequency[memoryi];

        print (" FIRST CHRO ");          
        println (upstairTime); 

        //   upstairTime = millis() + 500;

        OldoscillatorMoving=memoryi;
        oldMemoryi=OldoscillatorMoving;
        //   oldMemoryi=memoryi;
        memoryi=(memoryi+1)%12;
        print (" memoryi ");
        println (memoryi);
        if ( memoryi<=0) {
          memoryi=0;
        }

        oscillatorMoving=memoryi;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame  and clock way = true you'll moving to  ");
        println (oscillatorMoving); 
        oldOscillatorMoving[oldMemoryi]= false;
        OscillatorMoving[memoryi]= true;
        key='e';
      }
    }
  } 
  // deblockPendular();
  print (" END FUNCTION SITUATION " ); 
  print (" END FUNCTION SITUATION " ); 
  print (" END FUNCTION SITUATION " );   
  print (" BeforeOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OldoscillatorMoving ");     
  println ( oldOscillatorMoving[OldoscillatorMoving]);

  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOldoscillatorMoving ");  
  println ( oldOscillatorMoving[oscillatorMoving] );

  if (circularMov==false ) {
    for (int j = 0; j < (net.size()-0); j++) {
      metroOldPhase[j]= (metroPhase[j]);
    }
  }
} 

//  upstairx Trig normally formerKeyCTRUE

 public void formerKeyCTRUE(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) { 
  // netOldPhaseToMetroPhase();
  println (" Shift with C.  Oscillator <- one by one by keeping last position switched "); // based on u$
  for (int j = 11; j > 1; j--) {

    print (" m "); 
    print(j); 
    print ("  ");  
    print ( (metroPhase[j]));// -PI to PI
    print (" o "); 
    print(j); 
    print ("  ");  
    println ( (metroOldPhase[j]));// -PI to PI  
    //    metroOldPhase[j]=abs (metroPhase[j]);
    metroOldPhase[j]= (metroPhase[j]);
  }
  print (" phaseDecay ");  
  print (phaseDecay);
  float PhaseDecay; // TAKE OFF if you want to use several different decay with [] and not just one float
  PhaseDecay=phaseDecay*QUARTER_PI/2;  
  print (" PhaseDecay ");
  println (PhaseDecay);
  print (" BEGIN OF FUNCTION ");  
  print (" BEGIN OF FUNCTION ");  
  print (" oldMemoryi ");  
  print (oldMemoryi ); 
  println (" memoryi ");  
  print ( memoryi ); 
  print (" OLDOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OLDBOOOLDLoscillatorMoving ");     
  print ( oldOscillatorMoving[OldoscillatorMoving]);   
  print (" oscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  print ( OscillatorMoving[oscillatorMoving] ); 
  print (" BOOLOLD "); 
  println (" oscillatorMoving ");  
  print ( oscillatorMoving ); 
  print ("  ");
  println ( oldOscillatorMoving[oscillatorMoving] ); //     print (" BeforeOscillatorMoving ");  print ( OldoscillatorMoving ); print (" BeginINToscillatorMoving ");  println ( oscillatorMoving ); print ("formerFormerKey c?  ");  println (char (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==false) {
    print ("PendularOldOldOldLeftVirtualPosition "); 
    print ("mem "); 
    print (memoryi); 
    print (" ");   
    print(PendularOldOldOldLeftVirtualPosition[memoryi]);
    print ("PendularOldOldLeftVirtualPosition ");
    print ("mem "); 
    print (memoryi);
    print (" ");   
    print(PendularOldOldLeftVirtualPosition[memoryi]);
    print ("PendularOldLeftVirtualPosition "); 
    print ("mem "); 
    print (memoryi); 
    print (" ");   
    print(PendularOldLeftVirtualPosition[memoryi]);
    print ("PendularLeftVirtualPosition "); 
    print ("mem "); 
    print (memoryi); 
    print (" ");  
    println (PendularLeftVirtualPosition[memoryi]);       
    print ("PendularLeftVirtualPosition ");
    print ("old "); 
    print (oldMemoryi);
    print (" ");   
    println (PendularLeftVirtualPosition[oldMemoryi]);
  }

  if (circularMov==true ) {
    for (int i = 2; i < (net.size()-0); i++) {   
      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      println (CircularVirtualPosition[i]);
    }
  } 
  // deblockPendular();
  // 2 from 11 
  print (" A Time is && upstairShifting is "); 
  print (millis());     
  print (" memory "); 
  print (memoryi);  
  print (upstairShifting[memoryi]);
  print (" oldMemory "); 
  print (oldMemoryi);  
  println (upstairShifting[oldMemoryi]);

  //******NO INTERST
  if ( 
    (((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[oldMemoryi]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi])) ||
    ((PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[oldMemoryi]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])) ||
    ((PendularOldLeftVirtualPosition[memoryi]%6400 >= 6300 &&  (PendularLeftVirtualPosition[memoryi]%6400 <=  PendularOldLeftVirtualPosition[memoryi]%6400 ) && // you turn on cw
    (PendularLeftVirtualPosition[oldMemoryi]%6400 >= 0 && PendularOldLeftVirtualPosition[oldMemoryi]%6400 <= 100))))
    ) {
  } 
  //******NO INTERST  

  if ( memoryi<net.size()-1) {
    if ( ( millis()>1) && // upstairTime go down    10 to 9; 9 to 8 so old is 10 then 9 and memoryi 8 then 7

      (((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[oldMemoryi]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi])) ||
      ((PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[oldMemoryi]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])) ||
      ((PendularOldLeftVirtualPosition[memoryi]%6400 >= 6300 &&  (PendularLeftVirtualPosition[memoryi]%6400 <=  PendularOldLeftVirtualPosition[memoryi]%6400 ) && // you turn on cw
      (PendularLeftVirtualPosition[oldMemoryi]%6400 >= 0 && PendularOldLeftVirtualPosition[oldMemoryi]%6400 <= 100))))
      ) {  
      if (memoryi>2 ) {//&& OscillatorMoving[oldMemoryi]== false
        timeTrigged[memoryi]=millis();
        LasttimeTrigged[memoryi] =  timeTrigged[memoryi]-timeTrigged[oldMemoryi];
        interPosition[0] =   metroPhase[memoryi]- metroPhase[oldMemoryi];
        interPosition[1] =   net.oldPhase[memoryi]- net.oldPhase[oldMemoryi];
        print ( "interpositionMETRO " ) ; 
        print (0);  
        print ( " " ) ; 
        println (map  ((interPosition[0]/TWO_PI*360), 0, 360, 0, 1600));
        print ( "interpositionPHASE " ) ; 
        print (1);  
        print ( " " ) ; 
        println (map  ((interPosition[1]/TWO_PI*360), 0, 360, 0, 1600));

        interPosition[2] =   abs (metroPhase[memoryi]) - abs (metroPhase[oldMemoryi]);
        interPosition[3] =  abs (  net.oldPhase[memoryi]- net.oldPhase[oldMemoryi] ) ;
        print ( "ABSinterposition" ) ; 
        print (2);  
        print ( " " ) ; 
        println (map  ((interPosition[2]/TWO_PI*360), 0, 360, 0, 1600));
        print ( "ABSinterposition" ) ; 
        print (3);  
        print ( " " ) ; 
        println (map  ((interPosition[3]/TWO_PI*360), 0, 360, 0, 1600));

        print ( "PhaseDecay" ) ; 
        print (memoryi);  
        print ( " " ) ;
        println (map ((PhaseDecay/TWO_PI*360), 0, 360, 0, 1600)); // 45 degre = 400 points
        //  lastTimeTrigged

        print ( "timeTrigged" ) ; 
        print (memoryi);  
        print ( " " ) ;
        println ( timeTrigged[memoryi]);
        print ( "timeTrigged" ) ; 
        print (oldMemoryi);  
        print ( " " ) ;
        println ( timeTrigged[oldMemoryi]);
        print ( "LasttimeTrigged" ) ; 
        print (memoryi);  
        print ( " " ) ;
        println ( LasttimeTrigged[memoryi]);
        print ( "LasttimeTrigged" ) ; 
        print (oldMemoryi);  
        print ( " " ) ;
        println ( LasttimeTrigged[oldMemoryi]);
        //  lastTimeTrigged
        if (LasttimeTrigged[memoryi]>= TimeTrigged ) { 

          //  TimeTrigged= millis() +200;
          TimeTrigged= 0;
          // timeTrigged[memoryi]= millis() +200;
          print ( "  OSCILLATOR 3 to 10 "); 
          print ( "  lastTimeTrigged "); 
          print (lastTimeTrigged);
          print ( "  TimeTrigged "); 
          print (TimeTrigged);
          print ( "  Actual "); 
          println (millis());
          key='e'; 


          metroPhase[1]=metroPhase[0];
          oldMemoryi=memoryi;


          metroPhase[memoryi-1]= metroPhase[memoryi];  // l'oscillateur suivant se met à la position de l'oscillateur actuelle
          //**   metroPhase[memoryi-1]= metroPhase[memoryi]+PhaseDecay;
          //**   metroPhase[memoryi-1]= metroPhase[memoryi-1]%TWO_PI;
          metroPhase[memoryi]= metroPhase[memoryi+1]+PhaseDecay*1;//      l'oscillateur actuelle se met à la position de l'oscillateur precedent + un decalahe de phase en CW
          metroPhase[memoryi]= metroPhase[memoryi]%PI; // si on ajoute la phasedecay, il faut qu'il reste en -pi et pi
          net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi]; // l'oscillateur suivant  va à la vitesse de l'oscillateur actuelle
          net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi+1]; //  l'oscillateur actuelle  va à la vitesse de l'oscillateur precedent

          OldoscillatorMoving=oldMemoryi;
          oldMemoryi=OldoscillatorMoving;
          print ("you were still here "); 
          println (oldMemoryi);
          oscillatorMoving=memoryi-1;
          memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
          print ("Next frame are different memory here? ");
          println (oscillatorMoving);

          bg = rcolor();


          oldOscillatorMoving[oldMemoryi]= false;
          OscillatorMoving[memoryi]= true;


          lastTimeTrigged= TimeTrigged;
          //  lastTimeTrigged= timeTrigged[memoryi];

          //  key='+';
        }
      }
    }
  }  
  // 11 from 2
  if ((PendularOldLeftVirtualPosition[2] <= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[2] > PendularLeftVirtualPosition[oldMemoryi])  && (PendularOldLeftVirtualPosition[2] < PendularLeftVirtualPosition[2])||
    (PendularOldLeftVirtualPosition[2] >= PendularLeftVirtualPosition[oldMemoryi]) && (PendularLeftVirtualPosition[2] < PendularLeftVirtualPosition[oldMemoryi])  && (PendularOldLeftVirtualPosition[2] > PendularLeftVirtualPosition[2])||
    ((PendularOldLeftVirtualPosition[2] >= 6300 &&  (PendularLeftVirtualPosition[2] <=  PendularOldLeftVirtualPosition[2] ) && // you turn on cw
    (PendularLeftVirtualPosition[oldMemoryi] >= 0 && PendularOldLeftVirtualPosition[oldMemoryi] <= 100)))
    ) { 

    if (memoryi>1 && memoryi<3 ) {

      if (LasttimeTrigged[memoryi]>= TimeTrigged ) { 

        //  TimeTrigged= millis() +200;
        TimeTrigged= 0;
        // timeTrigged[memoryi]= millis() +200;
        print ( " OSCILLATOR 11 from 2  "); 
        print ( "  lastTimeTrigged "); 
        println (lastTimeTrigged);
        print ( "  TimeTrigged "); 
        println (TimeTrigged);
        print ( " Actual "); 
        println (millis());
        key='e'; 



        metroPhase[1]=metroPhase[0];
        print ("memoryi upstairx = 2? ");
        print (memoryi);
        //***     metroPhase[memoryi-1]= metroPhase[memoryi];
        //**    metroPhase[net.size()-1]= metroPhase[2]+PhaseDecay;
        //***   metroPhase[net.size()-1]= metroPhase[11]%TWO_PI;
        //    metroPhase[2]= metroPhase[11]+PhaseDecay*1;
        //      metroPhase[2]= metroPhase[2]%TWO_PI;

        metroPhase[11]= metroPhase[2];
        net.naturalFrequency[11]= net.naturalFrequency[2];
        //***      metroPhase[2]= metroPhase[1];

        //    metroPhase[2]= metroPhase[1]+PhaseDecay;
        //    metroPhase[2]= metroPhase[2]%TWO_PI;

        metroPhase[2]= metroPhase[3]+PhaseDecay;
        metroPhase[2]= metroPhase[2]%PI;

        net.naturalFrequency[2]=net.naturalFrequency[1];
        oldMemoryi=2;     
        OldoscillatorMoving=2;
        oldMemoryi=OldoscillatorMoving;      
        oscillatorMoving=net.size()-1 ;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print (" oscillator moving gonna be  = 11 ? ");
        println (oscillatorMoving); 
        print (" "); 
        println (memoryi);          
        oldOscillatorMoving[oldMemoryi]= false;
        OscillatorMoving[memoryi]= true; 
        //  key='f';
      }
    }
  } 

  //  deblockPendular();
  // 11 from 2 ou le contraire
  if ( memoryi>=net.size()-1 ) {


    if ((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= 3200 &&  (PendularLeftVirtualPosition[memoryi] <=  PendularOldLeftVirtualPosition[memoryi] ) && // you turn on cw
      (PendularLeftVirtualPosition[2] >= 0 && PendularOldLeftVirtualPosition[2] <= 3200))
      ) { 

      if (LasttimeTrigged[memoryi]>= TimeTrigged ) { 

        //  TimeTrigged= millis() +200;
        TimeTrigged= 0;
        // timeTrigged[memoryi]= millis() +200;
        print ( " OSCILLATOR 2 from 11  "); 
        print ( "  lastTimeTrigged "); 
        println (lastTimeTrigged);
        print ( "  TimeTrigged "); 
        println (TimeTrigged);
        print ( " Actual "); 
        println (millis());
        key='e'; 



        metroPhase[1]=metroPhase[0];
        print ("memoryi upstairx = 11? ");
        print (memoryi);
        oldMemoryi=memoryi;

        metroPhase[memoryi-1]= metroPhase[memoryi]; //phase 10= phase 11
        //**      metroPhase[memoryi-1]= metroPhase[memoryi]+PhaseDecay;
        //***      metroPhase[memoryi-1]= metroPhase[memoryi-1]%TWO_PI;
        net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
        metroPhase[memoryi]= metroPhase[2]+PhaseDecay*1; // what it has been changed with formerkeyc
        metroPhase[memoryi]= metroPhase[memoryi]%PI; // what it has been changed with formerkeyc
        net.naturalFrequency[memoryi]=net.naturalFrequency[2];
        // ***   oldMemoryi=memoryi;
        OldoscillatorMoving=oldMemoryi;     
        oscillatorMoving=10 ;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving   
        print ("Next frame oscillator Moving will be 10 ?");      
        println (oscillatorMoving); 
        print (" "); 
        println (memoryi);         
        oldOscillatorMoving[oldMemoryi]= false;
        OscillatorMoving[memoryi]= true;


        //    lastTimeTrigged= timeTrigged[memoryi];
        //    TimeTrigged= millis ();
      }
    }
  }


  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-0); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
    }
    print (" AFTER OLD PendularLeftVirtualPosition "); 
    print (oldMemoryi); 
    print (" ");   
    print (PendularLeftVirtualPosition[oldMemoryi]); 
    print ("CircularVirtualPosition "); 
    print (oldMemoryi); 
    print (" ");   
    println (CircularVirtualPosition[oldMemoryi]);

    print (" AFTER PendularLeftVirtualPosition "); 
    print (memoryi); 
    print (" ");   
    print (PendularLeftVirtualPosition[memoryi]); 
    print ("CircularVirtualPosition "); 
    print (memoryi); 
    print (" ");   
    println (CircularVirtualPosition[memoryi]);
  }  
  print (" ENDUPSTAIRX ");   
  print (" oldMemoryi ");  
  print (oldMemoryi ); 
  println (" memoryi ");  
  println ( memoryi );
  print (" OLDOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OLDBOOOLDLoscillatorMoving ");     
  println ( oldOscillatorMoving[OldoscillatorMoving]);   
  print (" oscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOLD "); 
  println (" oscillatorMoving ");  
  println ( oscillatorMoving ); 
  println ("  "); 
  println ( oldOscillatorMoving[oscillatorMoving] );
}




 public void formerKeyCoriginal(int oscillatorMoving, int OldoscillatorMoving, float phaseDecay) {     
  println (" Shift with C.  Oscillator <- one by one by keeping last position switched "); // based on u$
  print (" phaseDecay ");  
  print (phaseDecay);
  float PhaseDecay=phaseDecay*QUARTER_PI/2;
  print (" PhaseDecay ");
  print (PhaseDecay);
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );
  print (" BeforeOscillatorMoving ");  
  print ( OldoscillatorMoving );
  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );  
  print ("formerFormerKey c?  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= CircularVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]= CircularOldVirtualPosition[i+1];
      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      println (CircularVirtualPosition[i]);
    }
  }  
  if ( memoryi>=net.size()-1) {
    if ((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])
      ) { 
      print ("memoryi upstairx = 11? ");
      print (memoryi);
      metroPhase[memoryi-1]= metroPhase[memoryi]+PhaseDecay;
      metroPhase[memoryi-1]= metroPhase[memoryi-1]%TWO_PI;
      net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
      metroPhase[memoryi]= metroPhase[2]+PhaseDecay;
      metroPhase[memoryi]= metroPhase[memoryi]%TWO_PI;
      net.naturalFrequency[memoryi]=net.naturalFrequency[2];
      oldMemoryi=memoryi;
      OldoscillatorMoving=oldMemoryi;     
      oscillatorMoving=memoryi-1 ;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving      
      println (oscillatorMoving); 
      print (" "); 
      println (memoryi);         
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;
      key='&';
    }
  }  
  if ( memoryi<net.size()-1) {
    if ((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[memoryi+1]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi+1]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[memoryi+1]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi+1]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])
      ) {  
      if (memoryi>2 ) {
        metroPhase[1]=metroPhase[0];
        print ("you were here: ");
        oldMemoryi=memoryi;
        print (oldMemoryi); 

        metroPhase[memoryi-1]= metroPhase[memoryi]+PhaseDecay;
        metroPhase[memoryi-1]= metroPhase[memoryi-1]%TWO_PI;
        metroPhase[memoryi]= metroPhase[memoryi+1]+PhaseDecay;//      
        metroPhase[memoryi]= metroPhase[memoryi]%TWO_PI;
        net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
        net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi+1];

        OldoscillatorMoving=oldMemoryi;
        oldMemoryi=OldoscillatorMoving;
        print ("you were still here "); 
        println (oldMemoryi);
        oscillatorMoving=memoryi-1;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame are different memory here? ");
        println (oscillatorMoving);
      }

      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;

      key='+';
    }
  }

  if ((PendularOldLeftVirtualPosition[2] <= PendularLeftVirtualPosition[11]) && (PendularLeftVirtualPosition[2] > PendularLeftVirtualPosition[11])  && (PendularOldLeftVirtualPosition[2] < PendularLeftVirtualPosition[2])||
    (PendularOldLeftVirtualPosition[2] >= PendularLeftVirtualPosition[11]) && (PendularLeftVirtualPosition[2] < PendularLeftVirtualPosition[11])  && (PendularOldLeftVirtualPosition[2] > PendularLeftVirtualPosition[2])
    ) { 
    print ("memoryi upstairx = 2? ");
    print (memoryi);

    metroPhase[net.size()-1]= metroPhase[2]+PhaseDecay;
    metroPhase[net.size()-1]= metroPhase[11]%TWO_PI;     
    metroPhase[2]= metroPhase[11]+PhaseDecay;
    metroPhase[2]= metroPhase[2]%TWO_PI;
    net.naturalFrequency[net.size()-1]= net.naturalFrequency[2];
    net.naturalFrequency[2]=net.naturalFrequency[1];
    oldMemoryi=2;     
    oldMemoryi=OldoscillatorMoving;      
    oscillatorMoving=net.size()-1 ;
    memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
    println (oscillatorMoving); 
    print (" "); 
    println (memoryi);          
    oldOscillatorMoving[oldMemoryi]= false;
    OscillatorMoving[memoryi]= true;      
    key='&';
  }
  print (" END OF FUNCTION ");  
  print (" END OF FUNCTION ");  
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );
  print (" BeforeOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OldoscillatorMoving ");     
  println ( oldOscillatorMoving[OldoscillatorMoving]);   
  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOldoscillatorMoving ");  
  println ( oldOscillatorMoving[oscillatorMoving] );

  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= CircularVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]= CircularOldVirtualPosition[i+1];
      print (" AFTER PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      println (CircularVirtualPosition[i]);
    }
  }
} 

 public void formerKeyc(int oscillatorMoving, int OldoscillatorMoving) { 

  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );
  print (" BeforeOscillatorMoving ");  
  print ( OldoscillatorMoving );
  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );  
  print ("formerFormerKey c?  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==true ) {
    for (int i = 2; i < (net.size()-0); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];

      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      println (CircularVirtualPosition[i]);
    }
  }  
  if ( memoryi>=net.size()-1) {
    println (" Shift  Oscillator <- one by one by keeping last position switched "); // based on u$
    if ((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[2]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[2]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])
      ) { 

      print ("memoryi actuelle = 11? ");
      print (memoryi);
      metroPhase[memoryi-1]= metroPhase[memoryi];
      net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
      metroPhase[memoryi]= metroPhase[2];
      net.naturalFrequency[memoryi]=net.naturalFrequency[2];
      oldMemoryi=memoryi;
      OldoscillatorMoving=oldMemoryi;     
      oscillatorMoving=memoryi-1 ;
      memoryi=oscillatorMoving; //
      print ("onscreen actual oscillatorMoving ");      
      println (oscillatorMoving); 
      print (" "); 
      println (memoryi);         
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;
      key='&';
    }
  }

  if ( memoryi<net.size()-1) {

    if ((PendularOldLeftVirtualPosition[memoryi] <= PendularLeftVirtualPosition[memoryi+1]) && (PendularLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi+1]) && (PendularOldLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi]) ||
      (PendularOldLeftVirtualPosition[memoryi] >= PendularLeftVirtualPosition[memoryi+1]) && (PendularLeftVirtualPosition[memoryi] < PendularLeftVirtualPosition[memoryi+1]) && (PendularOldLeftVirtualPosition[memoryi] > PendularLeftVirtualPosition[memoryi])
      ) {  
      if (memoryi>2 ) {
        metroPhase[1]=metroPhase[0];
        print ("you were here: ");
        oldMemoryi=memoryi;
        print (oldMemoryi); 

        metroPhase[memoryi-1]= metroPhase[memoryi];
        metroPhase[memoryi]= metroPhase[memoryi+1];// net.oldPhase[memoryi] keep phase at    
        net.naturalFrequency[memoryi-1]= net.naturalFrequency[memoryi];
        net.naturalFrequency[memoryi]= net.naturalFrequency[memoryi+1];

        OldoscillatorMoving=oldMemoryi;
        oldMemoryi=OldoscillatorMoving;
        print ("you were still here "); 
        println (oldMemoryi);
        oscillatorMoving=memoryi-1;
        memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
        print ("Next frame are different memory here? ");
        println (oscillatorMoving);
      }

      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;

      key='+';
    }
  }

  if ((PendularOldLeftVirtualPosition[2] <= PendularLeftVirtualPosition[11]) && (PendularLeftVirtualPosition[2] > PendularLeftVirtualPosition[11])  && (PendularOldLeftVirtualPosition[2] < PendularLeftVirtualPosition[2])||
    (PendularOldLeftVirtualPosition[2] >= PendularLeftVirtualPosition[11]) && (PendularLeftVirtualPosition[2] < PendularLeftVirtualPosition[11])  && (PendularOldLeftVirtualPosition[2] > PendularLeftVirtualPosition[2])
    ) { 
    //        if (   oldOscillatorMoving[2]= true) {
    if (memoryi>1 && memoryi<3 ) {
      print ("memoryi actuelle = 2? ");
      print (memoryi);

      metroPhase[11]= metroPhase[2];
      net.naturalFrequency[11]= net.naturalFrequency[2];
      metroPhase[2]= net.phase[1];
      net.naturalFrequency[2]=net.naturalFrequency[1];
      oldMemoryi=2;     
      OldoscillatorMoving=2;
      oldMemoryi=OldoscillatorMoving;      
      oscillatorMoving=net.size()-1 ;
      memoryi=oscillatorMoving; //print onscreen actual oscillatorMoving
      print (" oscillator moving gonna be  = 11 ? ");
      println (oscillatorMoving); 
      print (" "); 
      println (memoryi);          
      oldOscillatorMoving[oldMemoryi]= false;
      OscillatorMoving[memoryi]= true;      
      key='&';
    }
  }
  print (" AFTER "); 
  print (" oldMemoryi ");  
  print (oldMemoryi );
  print (" memoryi ");  
  println ( memoryi );
  print (" BeforeOscillatorMoving ");  
  println ( OldoscillatorMoving );
  print (" OldoscillatorMoving ");     
  println ( oldOscillatorMoving[OldoscillatorMoving]);   
  print (" BeginINToscillatorMoving ");  
  println ( oscillatorMoving );
  print (" BOOLoscillatorMoving ");  
  println ( OscillatorMoving[oscillatorMoving] );
  print (" BOOLOldoscillatorMoving ");  
  println ( oldOscillatorMoving[oscillatorMoving] );
} 

 public void formerKeyI() {  


  print ("char formerFormerKey  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= CircularVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]= CircularOldVirtualPosition[i+1];
      //     print ("PendularLeftVirtualPosition "); print (i); print (" ");   print (PendularLeftVirtualPosition[i]); 
      //     print ("CircularVirtualPosition "); print (i); print (" ");   print (CircularVirtualPosition[i]);
    }
  } 



  println (" void c$  Shift frequencies <- one by one by keeping last position switched and multipied *2"); // based on u$
  for (int i = 2; i < (net.size()-1); i++) {    
    if ((PendularOldLeftVirtualPosition[i]+800 <= PendularLeftVirtualPosition[i+1]+800) && (PendularLeftVirtualPosition[i]+800 > PendularLeftVirtualPosition[i+1]+800)&& (PendularOldLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i]+800) ||
      (PendularOldLeftVirtualPosition[i]+800 >= PendularLeftVirtualPosition[i+1]+800) && (PendularLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i+1]+800)&& (PendularOldLeftVirtualPosition[i]+800 > PendularLeftVirtualPosition[i]+800)

      ) { //  && (PendularOldLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i]+800) 
      //     print ("PendularLeftVirtualPosition "); print (i); print (" ");   print (PendularLeftVirtualPosition[i]); 
      //     print ("CircularVirtualPosition "); print (i); print (" ");   print (CircularVirtualPosition[i]); 
      key='+';     
      net.phase[1]=net.phase[0];
      print ("phase 1  ");  
      print (net.phase[1]);
      if (i==2) {
        //     if (i!=1000){

        println ("i 1 à 10  usefull when you go from behind to the front or inverse");
        net.phase[1]=net.phase[0];
        print ("phase 1  ");  
        print (net.phase[1]);

        //  net.phase[2]=  net.oldPhase[net.size()-1];
        net.naturalFrequency[net.size()-1]=net.naturalFrequency[2]; 
        net.phase[net.size()-1]=net.phase[2];
        OldFrequency[i-0]= net.naturalFrequency[i];
        memoryi=42; //usefull when you go from behind to the front or inverse? c to v?
      } else memoryi=i;
      print ("else memoryi: ");
      print (memoryi); 
      key  = '#'; 
      formerKey = '#';

      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularVirtualPosition[i]); 
      print ("PendularOldLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularOldLeftVirtualPosition[i]); 
      print ("CircularOldVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularOldVirtualPosition[i]); 


      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]);   
      print ("  OldPendularLeftVirtualPosition[i-1] "); 
      print (i-1);  
      print (" ");   
      print (   PendularOldLeftVirtualPosition[i-1]); 
      print (" "); 
      print ("  net.naturalFrequency[i] "); 
      print (i); 
      print (" ");    
      print  (  net.naturalFrequency[i]);    
      print ("  net.naturalFrequency[i-1] "); 
      print (i-1); 
      print (" ");    
      println  (  net.naturalFrequency[i-1]); 

      net.phase[i-1]= net.phase[i];
      net.phase[i]= net.phase[i+1];// net.oldPhase[i] keep phase at    
      net.naturalFrequency[i-1]= net.naturalFrequency[i];
      net.naturalFrequency[i]= net.naturalFrequency[i+1];

      print ("After phase memoryi"); 
      print (11);  
      print ("  ") ;  
      print ( net.phase[11]);  
      print ("  net.naturalFrequency[11] ");   
      print (  net.naturalFrequency[11]);  
      print ("  OldFrequency[11] ");   
      println  (  OldFrequency[11]); 
      print ("   pass Old oscillator  "); 
      print (2);  
      print ("  ") ;  
      print ( net.phase[2]);  
      print ("  net.naturalFrequency[i] ");   
      print  (  net.naturalFrequency[2]);  
      print ("  OldFrequency[2] ");   
      println  (  OldFrequency[2]);  

      print ("memoryi=i ");
      print (memoryi);
      print ("summary?  "); 
      printSummary(i);    
      print ("summaryi-1  "); 
      printSummary(i-1);   

      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularVirtualPosition[i]); 
      print ("PendularOldLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularOldLeftVirtualPosition[i]); 
      print ("CircularOldVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularOldVirtualPosition[i]); 


      if (i<11) {
        //    if (memoryi<11){ dont work
      }
      print ("After phase  "); 
      print (11);  
      print ("  ") ;  
      print ( net.phase[11]);  
      print ("  net.naturalFrequency[i] ");   
      println  (  net.naturalFrequency[11]); 
      print ("  OldFrequency[11] ");   
      println  (  OldFrequency[11]); 
      print ("   pass Old oscillator  "); 
      print (2);  
      print ("  ") ;  
      print ( net.phase[2]);  
      print ("  net.naturalFrequency[i] ");   
      println  (  net.naturalFrequency[2]);  
      print ("  OldFrequency[2] ");   
      println  (  OldFrequency[2]);
    }
  }


  // if (memoryi==11||memoryi==42||memoryi==3 ||memoryi==10){

  if (memoryi!=1000) {
    if ((PendularOldLeftVirtualPosition[11]+800 <= PendularLeftVirtualPosition[10]+800) && (PendularLeftVirtualPosition[11]+800 > PendularLeftVirtualPosition[10]+800)  && (PendularOldLeftVirtualPosition[11]+800 < PendularLeftVirtualPosition[11]+800)||
      (PendularOldLeftVirtualPosition[11]+800 >= PendularLeftVirtualPosition[10]+800) && (PendularLeftVirtualPosition[11]+800 < PendularLeftVirtualPosition[10]+800)  && (PendularOldLeftVirtualPosition[11]+800 > PendularLeftVirtualPosition[11]+800)
      ) { 
      key='#'; 

      print ("memoryi!=1000 ");
      print (memoryi);
      print ("summary11  "); 
      printSummary(11);    
      print ("summaryi10  "); 
      printSummary(10);   

      print ("before i+1==11   pass Old oscillator  "); 
      print (11);  
      print ("  ") ;  
      print ( net.phase[11]);  
      print ("  net.naturalFrequency[i] ");   
      println  (  net.naturalFrequency[11]); 
      print ("  OldFrequency[11] ");   
      println  (  OldFrequency[11]); 
      print ("   pass Old oscillator+1  "); 
      print (2);  
      print ("  ") ;  
      print ( net.phase[2]);  
      print ("  net.naturalFrequency[i] ");   
      println  (  net.naturalFrequency[2]);  
      print ("  OldFrequency[2] ");   
      println  (  OldFrequency[2]);  
      net.phase[10]= net.phase[11];
      net.naturalFrequency[10]= net.naturalFrequency[11];
      ///  net.naturalFrequency[10]=OldFrequency[11];
      net.phase[11]= net.phase[2];
      net.naturalFrequency[11]=net.naturalFrequency[2];
      //  net.naturalFrequency[11]=OldFrequency[2];

      //   memoryi=42;
      print ("after memoryi!=1000  pass Old oscillator  "); 
      print (11);  
      print ("  ") ;  
      print ( net.phase[11]);  
      print ("  net.naturalFrequency[11] ");   
      println  (  net.naturalFrequency[11]); 
      print ("   pass Old oscillator+1  "); 
      print (2);  
      print ("  ") ;  
      print ( net.phase[2]);  
      print ("  net.naturalFrequency[i] ");   
      println  (  net.naturalFrequency[2]);  

      print ("PendularLeftVirtualPosition "); 
      print (10); 
      print (" ");   
      print (PendularLeftVirtualPosition[10]); 
      print ("CircularVirtualPosition "); 
      print (10); 
      print (" ");   
      print (CircularVirtualPosition[10]); 
      print ("PendularOldLeftVirtualPosition "); 
      print (10); 
      print (" ");   
      print (PendularOldLeftVirtualPosition[10]); 
      print ("CircularOldVirtualPosition "); 
      print (10); 
      print (" ");   
      print (CircularOldVirtualPosition[10]);
    }
  } 


  if (key=='#' || key=='+') {
    //net.shiftFrequencies(-2);
    //net.shiftPhases(-2); 
    //key='#'; keyPressed();
    key='I'; 
    keyReleased();  
    println ("I  Released ");
    key='#'; 
    formerKey='#';//keyPressed();
  }
}



 public void formerKeyV() { // inspired from  formerKey=='v' with two shift
  //  if (formerKey == 'U') { println ("former v$  Shift frequencies <- one by one by keeping last position switched"); }
  print ("char formerFormerKey V?  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("char formerFormerKey v?  ");  
  println (PApplet.parseChar (formerFormerKey));
  print ("circularMov  ");  
  println (circularMov);
  if (circularMov==true ) {
    for (int i = 0; i < (net.size()-1); i++) {  
      PendularLeftVirtualPosition[i]= CircularVirtualPosition[i];
      PendularOldLeftVirtualPosition[i]= CircularOldVirtualPosition[i];
      PendularLeftVirtualPosition[i+1]= CircularVirtualPosition[i+1];
      PendularOldLeftVirtualPosition[i+1]= CircularOldVirtualPosition[i+1];
      print ("PendularLeftVirtualPosition "); 
      print (i); 
      print (" ");   
      print (PendularLeftVirtualPosition[i]); 
      print ("CircularVirtualPosition "); 
      print (i); 
      print (" ");   
      print (CircularVirtualPosition[i]);
    }
  } 



  for (int i = 2; i < (net.size()-1); i++) {
    if ((PendularOldLeftVirtualPosition[i]+800 <= PendularLeftVirtualPosition[i+1]+800) && (PendularLeftVirtualPosition[i]+800 > PendularLeftVirtualPosition[i+1]+800)&& (PendularOldLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i]+800) ||
      (PendularOldLeftVirtualPosition[i]+800 >= PendularLeftVirtualPosition[i+1]+800) && (PendularLeftVirtualPosition[i]+800 < PendularLeftVirtualPosition[i+1]+800)&& (PendularOldLeftVirtualPosition[i]+800 > PendularLeftVirtualPosition[i]+800)

      ) {
      key='+'; 
      // formerKey = '+' ;   
      //  net.phase[1]=net.phase[0];

      print("pendularOld " ); 
      print (i); 
      print(" " );   
      print (PendularOldLeftVirtualPosition[i]+800); // probleme dscrimination
      print("pendular " ); 
      print (i+1); 
      print(" " );   
      print (PendularOldLeftVirtualPosition[i+1]+800); // probleme dscrimination
      println("pendular i+1 > pendularOld i ? ou dans le sens oppose " );

      //      print("pendularOld" ); print (i); print(" " )   print (PendularOldLeftVirtualPosition[i]+800); // probleme dscrimination
      //      print("pendular" ); print (i+1); print(" " )   print (PendularOldLeftVirtualPosition[i+1]+800); // probleme dscrimination
      if (i!=i+1) {




        net.phase[0]= net.phase[11];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[0]= net.naturalFrequency[11];
        net.phase[1]= net.phase[0];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[1]= net.naturalFrequency[0];


        net.phase[i+1]= net.phase[i];// net.oldPhase[i] keep phase at 0
        net.phase[i]= net.phase[i-1];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[i+1]= net.naturalFrequency[i];
        net.naturalFrequency[i]= net.naturalFrequency[i-1];
      }       

      memoryi=i;
      println("summary before");
      printSummary(i-1);  
      printSummary(i);  
      printSummary(i+1);  

      if (i==10) {
        println ("é");
        key='é';// go from 10 to 2 (2 is the first oscillator)
        net.phase[2]= net.phase[11];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[2]= net.naturalFrequency[11];
        net.phase[11]= net.phase[10];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[11]= net.naturalFrequency[10];
        net.phase[1]= net.phase[0];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[1]= net.naturalFrequency[0];
        net.phase[0]= net.phase[11];// net.oldPhase[i] keep phase at 0
        net.naturalFrequency[0]= net.naturalFrequency[11];
      } else {
        key='+';
      }

      if (i<1) {// really better than that? if (i<11){
        //if (i<11){
        println ("i 1 à 10  usefull when you go from behind to the front or inverse");
        net.phase[0]=net.phase[1];
        print ("phase 1  ");  
        print (net.phase[1]);

        //  net.phase[2]=  net.oldPhase[net.size()-1];
        //   net.naturalFrequency[net.size()-1]=OldFrequency[2]; 
        net.naturalFrequency[2]=OldFrequency[net.size()-1]; 
        ///  net.phase[net.size()-1]=net.oldPhase[2];
        net.phase[2]=net.oldPhase[net.size()-1];
        OldFrequency[i]= net.naturalFrequency[i];

        println("summary after");
        printSummary(i-1);  
        printSummary(i);  
        printSummary(i+1);
      }
    }
  }   
  if ((PendularOldLeftVirtualPosition[net.size()-1]+800 <= PendularLeftVirtualPosition[2]+800) && (PendularLeftVirtualPosition[net.size()-1]+800 > PendularLeftVirtualPosition[2]+800)&& (PendularOldLeftVirtualPosition[net.size()-1]+800 < PendularLeftVirtualPosition[net.size()-1]+800) ||
    (PendularOldLeftVirtualPosition[net.size()-1]+800 >= PendularLeftVirtualPosition[2]+800) && (PendularLeftVirtualPosition[net.size()-1]+800 < PendularLeftVirtualPosition[2]+800)&& (PendularOldLeftVirtualPosition[net.size()-1]+800 > PendularLeftVirtualPosition[net.size()-1]+800)

    ) {



    //   net.phase[2]=  net.oldPhase[net.size()-1];
    net.phase[2]=   net.phase[11];
    //   net.phase[2]=   net.phase[10];
    //   net.naturalFrequency[2]= OldFrequency[net.size()-1];


    net.naturalFrequency[2]= net.naturalFrequency[11];

    net.phase[11]= net.phase[10];
    net.naturalFrequency[11]= net.naturalFrequency[10];
    key='&';  
    println("summary other");
    printSummary(2);  
    printSummary(10);  
    printSummary(11);  
    /* 
     if ((PendularOldLeftVirtualPosition[net.size()-1]+800 <= PendularLeftVirtualPosition[2]+800) && (PendularLeftVirtualPosition[net.size()-1]+800 > PendularLeftVirtualPosition[2]+800)&& (PendularOldLeftVirtualPosition[net.size()-1]+800 < PendularLeftVirtualPosition[net.size()-1]+800) ||
     (PendularOldLeftVirtualPosition[net.size()-1]+800 >= PendularLeftVirtualPosition[2]+800) && (PendularLeftVirtualPosition[net.size()-1]+800 < PendularLeftVirtualPosition[2]+800)&& (PendularOldLeftVirtualPosition[net.size()-1]+800 > PendularLeftVirtualPosition[net.size()-1]+800)
     
     ){
     
     println("summary other after");
     printSummary(2);  
     printSummary(10);  
     printSummary(11);  
     } 
     */

    // net.shiftPhases(-2);
  }


  if (key=='&' || key=='+') {

    net.shiftFrequencies(+1);
    net.shiftPhases(+1);
  }
}  

int actualSec,lastSec, lastLastSec, measure;  // trig internal clock each seconde as a measure  (period of 1 seconde)

int currTime;
boolean bRecording = true;
boolean mouseRecorded = true;
float movementInterpolated, oldMovementInterpolated;
int Movement;



class Sample {
  int t, x, y;
  Sample( int t, int x, int y ) {
    this.t = t;  this.x = x;  this.y = y;
  }
}
class Sampler {
  ArrayList<Sample> samples;
  int startTime;
  int playbackFrame;
  Sampler() {
    samples = new ArrayList<Sample>();
    startTime = 0;
  }
   public void beginRecording() {
    samples = new ArrayList<Sample>();
    playbackFrame = 0;
  }
   public void addSample( int x, int y ) {
    int now = millis();
    if( samples.size() == 0 ) startTime = now;
    samples.add( new Sample( now - startTime, x, y ) );
  }
   public int fullTime() {
    return ( samples.size() > 1 ) ? 
      samples.get( samples.size()-1 ).t : 0;
  }
   public void beginPlaying() {
    startTime = millis();
    playbackFrame = 0;
    println( samples.size(), "samples over", fullTime(), "milliseconds" );
  }
   public void draw() {
    stroke( 255 );
    beginShape(LINES);
    for( int i=1; i<samples.size(); i++) {
      vertex( samples.get(i-1).x, samples.get(i-1).y );
      vertex( samples.get(i).x, samples.get(i).y );
    }
    endShape();
    int now = (millis() - startTime) % fullTime();
    if( now < samples.get( playbackFrame ).t ) playbackFrame = 0;
    while( samples.get( playbackFrame+1).t < now )
      playbackFrame = (playbackFrame+1) % (samples.size()-1);
    Sample s0 = samples.get( playbackFrame );
    Sample s1 = samples.get( playbackFrame+1 );
    float t0 = s0.t;
    float t1 = s1.t;
    float dt = (now - t0) / (t1 - t0);
    
    float x = mlerp( s0.x, s1.x, dt, 400 ); // interpolation with 'cylical datas'
    float y = mlerp( s0.y, s1.y, dt, 400 ); // interpolation with 'cylical datas'
       
    oldYsampled=ySampled;
    ySampled=y;   
    println (" ySampled ", ySampled , " oldYSampled ", oldYsampled, "  movementInterpolated ", movementInterpolated,
             " oldmovementInterpolated ", oldMovementInterpolated );
    oldMovementInterpolated = movementInterpolated;

    if (oldYsampled>=  ySampled){ // go down

  //    if (oldMovementInterpolated>=   movementInterpolated){
     
      
    movementInterpolated= map (y, 0, 400, TWO_PI , 0); 
      }
    else { 
    movementInterpolated= map (y, 0, 400, 0, TWO_PI);
     }
   
    noStroke();
    fill( 255, 40, 40 );
    rotate (HALF_PI);
    
    float time= (millis()/5)%1000;
//    circle ( time+400, 100*sin (movement)+400, 20);
    circle ( time+400, 100*sin (movementInterpolated) +net.phase[2] + net.phase[3] + net.phase[4] + net.phase[5], 20) ;//+ net.phase[6]+ net.phase[7]+ net.phase[8]+ net.phase[9]+ net.phase[10]+400, 20);
    addPhase =sin (movementInterpolated) + net.phase[2] + net.phase[3] + net.phase[4] + net.phase[5];//+ net.phase[6]+ net.phase[7]+ net.phase[8]+ net.phase[9]+ net.phase[10];
    addPhase= map (addPhase, -(networkSize-1)*TWO_PI, (networkSize-1)*TWO_PI, -TWO_PI, TWO_PI);
    print ( "addPhase "); println (addPhase); 
    fill( 2500 , 40, 255 );
    circle ( time, 100 * addPhase, 20); //
 //   circle ( time, 200*(sin (net.phase[2])+ sin (net.phase[3])+ sin (net.phase[4])), 20); //+net.phase[5]+net.phase[6]+net.phase[7]+net.phase[8]+net.phase[9]+net.phase[10]+net.phase[11]
    rotate (-HALF_PI);
}
}
Sampler sampler;

//******************         END INTERPOLATION SamplingMovement
// MANAGE SOUND


 // for AudioRecordingStream


Minim minim;
AudioPlayer song; // not used any more
BeatDetect beat;
BeatDetect snare;
BeatListener bl;

TickRate rateControl;
FilePlayer filePlayer;
AudioOutput out;

//String fileName = "09-The Secret Agent Ending.mp3";
String fileName = "again_loop.aif";


float kickSize, snareSize, hatSize;
int V, K, S, H;
int snareSizeBis;

class BeatListener implements AudioListener
{
  private BeatDetect beat;
  private AudioPlayer source;

  BeatListener(BeatDetect beat, AudioPlayer source)
  {
    this.source = source;
    // *** this.source.addListener(this);
    this.beat = beat;
  }

   public void samples(float[] samps)
  {
    beat.detect(source.mix);
  }

   public void samples(float[] sampsL, float[] sampsR)
  {
    beat.detect(source.mix);
  }
}

//MANAGE VARIABLE TO MODULATE SOUND
int freqMin = 0;
int freqMax= 14000;
float phaz, freq;
float rez;
float[] phazi;
float[] speedi;
float[] freqi;
float[] volumei;
 public void methodAbleton()  {
   for (int i = 0; i < networkSize; i++) {
     newPosF[i]=phaseAbleton[i]; // to see display phase on screen and count revolution
  
   }
//   countRevsContinue();
  
   for (int i = 0; i < networkSize; i++) {

    phaseAbleton[i]= map (ableton[i], 0, 1, 0, TWO_PI);  // display in main loop
   
    phaseAbleton[networkSize-1]= map (automationLFO[networkSize-1] , 0, 1, 0, TWO_PI);  // display in main loop
   
    phaseAbleton[i]= constrain (phaseAbleton[i], 0, TWO_PI);
// oldPhaseAbleton[i] = phaseAbleton[i];
 
//  ableton[i]= map (ableton[i], 0, TWO_PI, 0, numberOfStep);  
//  DataToDueCircularVirtualPosition[i] = (int) ableton[13-i];
   }
   
     countRevsContinue();
      
      
   for (int i = 0; i < networkSize; i++) {
  //   newPosF[i]=phaseAbleton[i];
 
     oldPosF[i]=newPosF[i];
     net.phase[i]=phaseAbleton[i]; // trig data from arduinoPos to Oscsend

      //*******************************  ASSIGN MOTOR WITH POSITION

      if (rev[i]!=0  && (newPosF[i] >  0) ) { // number of revolution is even and rotation is clock wise   
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep))+ (rev[i]*numberOfStep);
      }

      if (rev[i]!=0  && (newPosF[i] <  0)) { // number of revolution is even and rotation is Counter clock wise          // pos[i]= int (map (net.phase[i], 0, -TWO_PI, 0,  numberOfStep))+ (rev[i]*numberOfStep);
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0)) +(rev[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (rev[i]==0 && (newPosF[i] < 0) ) { //  number of revolution is 0 and rotation is counter clock wise 
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, -TWO_PI, numberOfStep, 0));        
      }         
      if (rev[i]==0 && (newPosF[i] > 0) ) {  //  number of revolution is 0 and rotation is clock wise     
        pos[i]= PApplet.parseInt (map (newPosF[i], 0, TWO_PI, 0, numberOfStep));                //      print ("pos "); print (i); print (" CW rev=0 ");println (pos[i]);
      }
      DataToDueCircularVirtualPosition[i]= (int) pos[i];
            
    }
  
   send24DatasToTeensy6motors( 7, 3, -3, -1); 

  } 
  
 public void lfoPattern(){

   if (formerKeyMetro == 'c') {   //followsignalLfo signal 10 et signal 11 from 0 to 1
   
     signal[4] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;
    
     signal[5] = (0*PI + (frameCount / 30.0f) * cos (1000 / 500.0f)*-1)%1;  // ==> 15 = 8 sec
    
      println (" pattern cccccccc ",   " signal[10] ", signal[10],   " signal[11] ", signal[11]); 
      
    lfoPhase[1] = (0*PI + (frameCount / 25.0f) * cos (1000 / 500.0f)*-1)%TWO_PI;
    
    lfoPhase[2] = (PI + (frameCount / 10.0f) * cos (1000 / 500.0f)*-1)%TWO_PI;  // ==> 15 = 8 sec
    
    lfoPhase[3] = map ((((cos  (frameCount / 10.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoida
 
    signalToSplit= lfoPhase[3];
    
    
    println (" pattern cccccccc ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3]= signalTosplit ", lfoPhase[3]); 

  }
  
  else if (formerKeyMetro != 'c') { 
     signal[2] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;
    
     signal[3] = (0*PI + (frameCount / 300.0f) * cos (1000 / 500.0f)*-1)%1;  // ==> 15 = 8 sec
  
    lfoPhase[1] = (0*PI + (frameCount / 50.0f) * cos (1000 / 500.0f)*-1)%TWO_PI;
    
    lfoPhase[2] = (PI + (frameCount / 5.0f) * cos (1000 / 500.0f)*-1)%TWO_PI;  // ==> 15 = 8 sec
 // propagationSpeed
 propagationSpeed=200;
  //  lfoPhase[3] = map (( cos  (frameCount / propagationSpeed) %TWO_PI), 0, 1, 0, TWO_PI);  // sinusoid  //  lfoPhase[3] = map (( cos  (frameCount / 22.0) %TWO_PI), 0, 1, -TWO_PI, TWO_PI);
    
        lfoPhase[3] = map ((((cos  (frameCount / 20.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoida

    signalToSplit= lfoPhase[3];
    
  //  println (" pattern lfoPhase[1] ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3] ", lfoPhase[3]);
     text (" propagationSpeed " + propagationSpeed + " key " + key, -width + 1000, -height- 0 );

    
    }
}

 
 public void  modePendulaireModeCirculaire() {
  for (int i = 0; i <networkSize-0; i++) {
   
    pushMatrix();

    // ***************************************DATA TO MANAGE SOUND in Processing USELESS
    j[i]= rev[i]%2; // if j==0 the number of revolution is pair, j==1 -->impair, j==-1--> impair and negative
    if (net.naturalFrequency[i] < 0) {
      freqi[i] = constrain( map( net.naturalFrequency[i], 0, -5, 200, 16000 ), freqMin, 12000 );
    } else {
      freqi[i]=  constrain( map( net.naturalFrequency[i], 0, 5, 200, 16000 ), freqMin, 12000 );
    }
    //**************** TRANSFORM CIRCULAR PHASE INTO METRO PHASE ********* SET AMPLITUDE
    if (formerKeyMetro == '$' || trigFollowSampling == true   ) { //&& formerSartKey == 'x'//|| formerKeyMetro == 'J'
     text ( " mapped GENERAL pendular way $ ", 400, 600);
      //  println (" you are in $ et non x ");
      if (net.phase[i] >= PI ) { 
        metroPhase[i]= map( net.phase[i], 0, TWO_PI, 1.5f*PI, -0.5f*PI);
      }
      if (net.phase[i] >= 0 && net.phase[i] < PI ) {
        metroPhase[i]= map( net.phase[i], 0, TWO_PI, -0.5f*PI, 1.5f*PI);
      }
      if (net.phase[i] <= -PI) { 
        metroPhase[i]= map( net.phase[i], 0, -TWO_PI, 1.5f*PI, -0.5f*PI);
      }  
      if (net.phase[i] < 0  && net.phase[i] > -PI) {   
        metroPhase[i]= map( net.phase[i], 0, -TWO_PI, -0.5f*PI, 1.5f*PI );
      }

      x = displacement*cos(metroPhase[i]);
      y = displacement*sin(metroPhase[i]);
    } 


    if (formerKeyMetro == '$' && (formerSartKey == 'X' || formerSartKey == 'x' ) ) {  // circular to pendular) //|| formerSartKey == 'w' || formerSartKey == 'W'
    if (overKeyMode != " null ")  {  
  text ( " mapped SECOND pendular way $ ", 400, 700);
     

      if (net.phase[i] >= 0 && net.phase[i] <= PI ) {
        metroPhase[i]= map( net.phase[i], 0, PI, -HALF_PI, HALF_PI);
      }

      if (net.phase[i] >= PI  && net.phase[i] <= TWO_PI) {   
        metroPhase[i]= map( net.phase[i], PI, TWO_PI, HALF_PI, -HALF_PI );
      }

      if (net.phase[i] <= 0 && net.phase[i] >= -PI ) {
        metroPhase[i]= map( net.phase[i], 0, -PI, HALF_PI, -HALF_PI);
      }

      if (net.phase[i] >= -PI  && net.phase[i] <= -TWO_PI) {   
        //    metroPhase[i]= map( net.phase[i], -PI, -TWO_PI, -HALF_PI, HALF_PI );
      }

      for (int n = 0; n < (1); n++) {// pendular from -800 to 800
/*
        print (" interPhas "); 
        print (memoryi); 
        print (" "); 
        print (interPhase[memoryi]); 
        print (" interPCia "); 
        print (memoryi); 
        print (" "); 
        print (interPhaseCircular[memoryi]);

        print (" metroPhas "); 
        print (memoryi); 
        print (" "); 
        print (metroPhase[memoryi]); 
        print (" meOldPhas "); 
        print (memoryi); 
        print (" "); 
        print (metroOldPhase[memoryi]);

        print (" net.phase "); 
        print (memoryi); 
        print (" "); 
        print (net.phase[memoryi]); 
        print (" netOphase "); 
        print (memoryi); 
        print (" "); 
        println (net.oldPhase[memoryi]);

        print (" interPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (interPhase[oldMemoryi]); 
        print (" interPCia "); 
        print (oldMemoryi); 
        print (" "); 
        print (interPhaseCircular[oldMemoryi]);

        print (" metroPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (metroPhase[oldMemoryi]); 
        print (" meOldPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (metroOldPhase[oldMemoryi]);

        print (" net.phase "); 
        print (oldMemoryi); 
        print (" "); 
        print (net.phase[oldMemoryi]); 
        print (" netOphase "); 
        print (oldMemoryi); 
        print (" "); 
        println (net.oldPhase[oldMemoryi]);
        */
      }  

      x = displacement*cos(metroPhase[i]);
      y = displacement*sin(metroPhase[i]);
    }
   }

    if ((formerKeyMetro == '$' || formerKeyMetro == '*' || formerKeyMetro == '@'  ) && (formerSartKey == 'w' || formerSartKey == 'W' ) ) {  // circular to pendular) //|| formerSartKey == 'w' || formerSartKey == 'W'
    if (overKeyMode != " null " ) {   
    
     text ( " mapped to THIRD pendular way 2$ ", 400, 800);
      if (net.phase[i] <= 0 && net.phase[i] >= -PI ) {   
        metroPhase[i]= (map( net.phase[i], 0, -PI, HALF_PI, -HALF_PI));
      }

      if (net.phase[i] <= -PI && net.phase[i] >= -TWO_PI ) {   
        metroPhase[i]= (map( net.phase[i], -PI, -TWO_PI, -HALF_PI, HALF_PI ));
      }

      if (net.phase[i] >= 0 && net.phase[i] <= PI ) {
        metroPhase[i]= (map( net.phase[i], 0, PI, -HALF_PI, HALF_PI));
      }

      if (net.phase[i] >= PI  && net.phase[i] <= TWO_PI) {   
        metroPhase[i]= (map( net.phase[i], PI, TWO_PI, HALF_PI, -HALF_PI ));
      }


      /*  
       if (net.phase[i] <= 0 && net.phase[i] >= -PI ) {
       metroPhase[i]=abs (map( net.phase[i], 0, -PI, HALF_PI, -HALF_PI));
       }
       */
      if (net.phase[i] >= -PI  && net.phase[i] <= -TWO_PI) {   
        //    metroPhase[i]= map( net.phase[i], -PI, -TWO_PI, -HALF_PI, HALF_PI );
      }

      for (int n = 0; n < (1); n++) {// pendular from -800 to 800
/*
        print (" interPhas "); 
        print (memoryi); 
        print (" "); 
        print (interPhase[memoryi]); 
        print (" interPCia "); 
        print (memoryi); 
        print (" "); 
        print (interPhaseCircular[memoryi]);

        print (" metroPhas "); 
        print (memoryi); 
        print (" "); 
        print (metroPhase[memoryi]); 
        print (" meOldPhas "); 
        print (memoryi); 
        print (" "); 
        print (metroOldPhase[memoryi]);

        print (" net.phase "); 
        print (memoryi); 
        print (" "); 
        print (net.phase[memoryi]); 
        print (" netOphase "); 
        print (memoryi); 
        print (" "); 
        println (net.oldPhase[memoryi]);

        print (" interPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (interPhase[oldMemoryi]); 
        print (" interPCia "); 
        print (oldMemoryi); 
        print (" "); 
        print (interPhaseCircular[oldMemoryi]);

        print (" metroPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (metroPhase[oldMemoryi]); 
        print (" meOldPhas "); 
        print (oldMemoryi); 
        print (" "); 
        print (metroOldPhase[oldMemoryi]);

        print (" net.phase "); 
        print (oldMemoryi); 
        print (" "); 
        print (net.phase[oldMemoryi]); 
        print (" netOphase "); 
        print (oldMemoryi); 
        print (" "); 
        println (net.oldPhase[oldMemoryi]);
 */       
      }  

      x = displacement*cos(metroPhase[i]);
      y = displacement*sin(metroPhase[i]);
    }
  }


    if (formerKeyMetro == '£' || formerKeyMetro == '*' ) { //&& formerKeyMetro != 'à' && formerKeyMetro != '$'
 text ( " mapped to GENERAL CIRCULAR way 2$ ", 400, 900);
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);
    }

    if (formerKeyMetro == 'J') { //USELLL play sample recorded with s
     text ( " mapped to J CIRCULAR or PENDULAR way 2$ ", 400, 1000);

      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);
  
    }
    if (formerKeyMetro == 's') { //drive ball with lfo
         text ( " mapped to s CIRCULAR or PENDULAR way 2$ ", 400, 1100);


      //    net.phase[i]=net.phase[i]+LFO[i];
      //     net.phase[i]=LFO[i];
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);
    }


    if (formerKeyMetro == '<') { //experimental pattern of phases

      //  abstractPhase[networkSize-0-i]=((net.phase[networkSize-0-i+1])+(TWO_PI/(40+i)*net.phase[networkSize-0-i+1])); // faucille
      //***     abstractPhase[networkSize-2-i]=((net.phase[networkSize-2-i+1])+(TWO_PI/(40+i)*net.phase[networkSize-2-i+1])); // faucille      
      //***     net.phase[networkSize-0-i]= abstractPhase[networkSize-0-i];

    }
 
    //end of experimental pattern of phases 
    if (frameCount%15==0) {
      //   print (" abstractPhase[i]: "); print ( networkSize+1-i);  print ("  ") ; print ( net.phase[networkSize+1-i]);
      //   print (" modPos[i]: "); print ( networkSize+1-i);  print ("  ") ; println ( modPos[networkSize+1-i]);
    }

    translate(-w2, -h2, -1000); // Set the perspective 3D with two fingers on the trackpad
    line (250, 250, 250, 250);  // line showing how ball will behang by the motor's axe.
    fill (123);
    //line (0,0,0,0,0, 11*250+200+250); //axe helping the 3D representation. axe qui relie les pendules
    noFill (); 

  //  sphere(side*3); // this sphere serves as a reference
   

    // Color sphere and Draw them, depending of acceleration or later with "chimera state"
    mapAcceleration[i]= constrain ((PApplet.parseInt (map (abs(net.acceleration[i] *100), 0, 150, 0, 255))), 0, 255); 
    mapAccelerationinversed[i]= abs (PApplet.parseInt (map ((net.acceleration[i] *100), -200, 200, 0, 255)));
    //********************************************************* BEGIN GRAPHIC CHIMERA STATE
    colorMode(HSB, TWO_PI, 100, 100);
    noStroke();
    // chimera state
    // mouseXY (); // no effect
    // initializeCoupling(net.coupling, sigma);
    /* 
     for (int k = 0; k < numRows; k++) {
     for (int l = 0; l < numCols; l++) {
     int x = l * gridSize;
     int y = k * gridSize;
     int index = k * numCols + l;
     fill(netG.phase[index], 100, 100);
     rect(x, y, gridSize, gridSize);
     }
     } 
     */
    //********************************************************* END GRAPHIC CHIMERA STATE
    translate (x*1, y*1, 200+(50*5*i));  //*-1 go in clockwise, *1 go in CCW
    colorMode(RGB, 255, 255, 255);
//    fill( mapAccelerationinversed[i], 255, 0 ); // Sepheres are all modulated with the same color. depending of acceleration
      fill( 255, 255, 255 );
     if (formerKeyMetro !='B' ) { //drive ball with lfo
          if (formerKeyMetro != '<' ) {
             if (formerKeyMetro != '@' ) {
                     if (keyMode != " addSignalOneAndTwo " ) {
                         if (keyMode != " addSignalOneAndTwoBis " ) {
                             if (keyMode != " addSignalOneAndTwoTer " ) {
                               if (keyMode != " followDistribueAddLfoPattern " ) {
                                  if (keyMode != " samplingModeInternal " ) {
           
                       text (  " lllllll ", -width/4, -height/4 ) ;           
                       
    //     println (" NormalformerKeyMetro  ", i, " ",  formerKeyMetro ); 
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);
  
    sphere(side*3);
    sphereDetail( 4*5);
     }
     }
     }
     }
    }
       }
      }
    } 
    
       if (formerKeyMetro == 'B' ) { //mode signal
     fill( 255, 255, 0 ); // Spheres are all modulated with the same color. depending of acceleration
   //   followLFO();  // better to repare
   //  followLFObis(); // same as below
         println (" formerKeyMetro  ", i, " ",  formerKeyMetro );    

      x = displacement*cos(newPosX[i]);
      y = displacement*sin(newPosX[i]);   
      sphere(side*3);
      sphereDetail( 4*5);
  //    followMovementAll();
  //    displayfollowMovementAll();
      }

         if (keyMode == " addSignalOneAndTwoQuater "  ) { //drive ball with lfo
     fill( mapAccelerationinversed[i], 255, 255 ); // Sepheres are all modulated with the same color. depending of acceleration
     fill (100, 155, 100);
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);    
//      print (" keyMode ", i, " ",  newPosXaddSignal[i] );    
      sphere(side*3);
      sphereDetail( 4*5);
      }
          
       if (keyMode == " addSignalOneAndTwoTer "  ) { //drive ball with lfo
     fill( mapAccelerationinversed[i], 255, 255 ); // Sepheres are all modulated with the same color. depending of acceleration
     fill (100, 155, 255);
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);    
//      print (" keyMode ", i, " ",  newPosXaddSignal[i] );    
      sphere(side*3);
      sphereDetail( 4*5);
      }

         if (keyMode == " addSignalOneAndTwoBis "  ) { //drive ball with lfo
     fill( mapAccelerationinversed[i], 255, 255 ); // Sepheres are all modulated with the same color. depending of acceleration
     fill (255, 0 , 255);
    //  x = displacement*cos(newPosXaddSignal[i]);
    //  y = displacement*sin(newPosXaddSignal[i]); 
       x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);    
//      print (" keyMode ", i, " ",  newPosXaddSignal[i] );    
      sphere(side*3);
      sphereDetail( 4*5);
      }
      
      
     
       if (keyMode == " addSignalOneAndTwo "  ) { //drive ball with lfo
     fill( mapAccelerationinversed[i], 255, 255 ); // Sepheres are all modulated with the same color. depending of acceleration
    // fill (100, 255, 255);
    //   net.phase[i]=newPosF[i];
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]); 

 //     print (" keyMode ", i, " ",  newPosXaddSignal[i] );    
      sphere(side*3);
      sphereDetail( 4*5);
      }
      
       if (keyMode == " samplingModeBis "  ) { //drive ball with lfo
     fill( mapAccelerationinversed[i], 255, 255 ); // Sepheres are all modulated with the same color. depending of acceleration
     fill (100, 110, 120);
     samplingMovementPro();
      x = displacement*cos(net.phase[i]); //);
      y = displacement*sin(net.phase[i]);      // display ball in blue lagub
      print (" keyMode ", i, " ",  newPosXaddSignal[i] );    
      sphere(side*3);
      sphereDetail( 4*5);
      }
    
 if ( overKeyMode == " null " ) {      
    if ( keyMode == " methodAbleton " ) { //drive ball with lfo   
  
    println ( "****************************** DISPLAY ", keyMode );   
    fill (255, 0, 255);
      x = displacement*cos(phaseAbleton[i]); //);
      y = displacement*sin(phaseAbleton[i]);    
      sphere(side*3);
      sphereDetail( 4*5);
      }
      
    if ( keyMode == " signal " ) { //drive ball with lfo
    println ( "****************************** DISPLAY ", keyMode );    
    fill (100, 100 , 255);
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);    
      sphere(side*3);
      sphereDetail( 4*5); 
      }
    if ( keyMode == " followDirectLfo " ) { //drive ball with lfo    
      println ( "****************************** DISPLAY ", keyMode );    
      fill (255, 100 , 255);    
      x = displacement*cos(newPosF[i]);
      y = displacement*sin(newPosF[i]);
      net.phase[i]=newPosF[i];   
      sphere(side*3);
      sphereDetail( 4*5);
      } 
      
    if ( keyMode == " followDistribueAddPhasePattern " ) { //drive ball with lfo    
      println ( "****************************** DISPLAY ", keyMode );    
      fill (100, 255 , 255);    
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);    
      sphere(side*3);
      sphereDetail( 4*5); 
      }
      
    if ( keyMode == " followDistribueAddLfoPattern " ) { //drive ball with lfo
      println ( "****************************** DISPLAY ", keyMode ); 
      text ( PApplet.parseChar (formerKeyMetro), 100,100);
      fill (100, 255 , 150);    
      x = displacement*cos(newPosF[i]);
      y = displacement*sin(newPosF[i]);
    //  x = displacement*cos(net.phase[i]);
    //  y = displacement*sin(net.phase[i]);   
      sphere(side*3);
      sphereDetail( 4*5); 
      }


    if ( keyMode == " followDistribueAddLfoPatternControl " ) { //drive ball with lfo
    
   
      println ( "****************************** DISPLAY ", keyMode, controlTrigLfoPattern ); 
    //  text ( " CRL ", 100,100);
      text ( PApplet.parseChar (formerKeyMetro) , 100,100);
      fill (127, 127 , 255);    
      x = displacement*cos(net.phase[i]);
      y = displacement*sin(net.phase[i]);   
      sphere(side*3);
      sphereDetail( 4*5); 
      }  

    if ( modeStartKeyToFollow  == " followDistribueAddLfoPattern " ) {

        text ( PApplet.parseChar (formerKeyMetro) , 100,100);
      fill (127, 127 , 0);    
      x = displacement*cos(newPosF[i]);
      y = displacement*sin(newPosF[i]);   
      sphere(side*3);
      sphereDetail( 4*5); 
      } 

    if ( modeStartKeyToFollow  == " followDistribueAddLfoPattern " ) {

        text ( PApplet.parseChar (formerKeyMetro) , 100,100);
      fill (127, 127 , 0);    
      x = displacement*cos(newPosF[i]);
      y = displacement*sin(newPosF[i]);   
      sphere(side*3);
      sphereDetail( 4*5); 
      } 

    if ( keyMode  == " samplingModeInternal " ) {

        text ( PApplet.parseChar (formerKeyMetro) , 100,100);
      fill (127, 127 , 0);    
      x = displacement*cos(newPosF[i]);
      y = displacement*sin(newPosF[i]);   
      sphere(side*3);
      sphereDetail( 4*5); 
      } 





  }    
                                                                                                                                                                                                                                                                                                                                                                                                                                  
    popMatrix();
  
  }  

  net.step(); 
  netG.step(); //Does it make any meaning?
  
    } 
   
 public void phasePattern() { // trigged with $ or *
  //************************************ DONT TOUCH

//  if  (   formerKeyMetro != 'c') {  // VERY IMPORTANT with CASE c
 if  (   keyMode != " truc "  ) {
      if  (   keyMode != " abletonPattern "  ) {


  for (int i = 0; i < (networkSize); i++) { 
    {
      OldFrequency[i]=  net.naturalFrequency[i];  //************************************ SET LAST FREQUENCIES as OLD FREQUENCIES
    }
  }
  if  (   formerSartKey!= 'J')  
  if (key == 'W') { // follow mode. What is w?  (formerKey=='w')
    formerW();
    key ='#';
    //  pendular=5;
  }
 
                                                                                                                                                                                                                                                                                                                                                                                                                               

  //********** ********** ********** ********** ********** ********** ********** INCREASE FREQUENCIES in $ mode PENDULAR PATTERN
  if (keyCode == RIGHT) {  
    /*
      println( " right INCREASE timeOffset    from F0 (the behind one  the fastest) F1 very slow =0.021 ")  ; // Incremente together without changing phases   
     if ( formerSartKey != 'w'){
     d+=250;
     d=d%1750;
     println ("d= timeOffsetRatio: "); 
     println (d);
     oscillatorBlocked++;
     print ("  oscillatorBlocked ");     
     println (oscillatorBlocked); 
     if (oscillatorBlocked > (networkSize-1)) { 
     oscillatorBlocked=2;    
     }
     keyCode = SHIFT; // to trig only once
     }
     */
  }

  if (keyCode == RIGHT) {  
    println( " pendularPattern right DECREASE phase shifting   witch formerStartKey ")  ; // Incremente together without changing phases   
    if ((formerSartKey == 'X' || formerSartKey == 'x' || formerSartKey == 'W' || formerSartKey == 'w' || formerKeyMetro  == 'J')) {
      k--;

      if (k<-8) { 
        k=8;
      }    
      println ("k= shiftingPhaseRatio ");
      println (k);
      keyCode = SHIFT; // to trig only once
    }
  }
  if (keyCode == LEFT) { 
    println("pendularPattern left INCREASE phase shifting"); // Incremente together without changing phases  
    if ((formerSartKey == 'X' || formerSartKey == 'x' || formerSartKey == 'W' || formerSartKey == 'w' || formerKeyMetro == 'J')) {
      k++;
      k=k%8;
    } else 
    k++;
    k=k%10;
    if (k>8) { 
      k=-8;
    }    
    println ("k= shiftingPhaseRatio ");
    println (k);
    keyCode = SHIFT; // to trig only once
  } 

  if (keyCode == DOWN) { 
   //  d-=5;
    println(" pendularPattern DOWN by 2 and change way of signal : LFO2 for example "); // 
    for (int i = 2; i < 3; i++) { 
      LFO[i]= map (LFO[i], 0, 1, 0, TWO_PI*2);
      printSummary(i);
    }
  }  
  if (keyCode == UP) { 
  //   d+=5;
    println(" pendularPattern UP by 2 and change way of signal : LFO2 for example "); //   TAB -
    for (int i = 2; i < 3; i++) { 
      LFO[i]= map (LFO[i], 0, 1, 0, PI);
      printSummary(i);
    }
  }


  if (key == '1') { 
    println("Set Frequencies to 1+ harmonic distance with maxim different between them "); // boost l'effet du case é 
    for (int i = 0; i < networkSize; i++) {
      net.naturalFrequency[i] =    1.2f-((i+0)*(1.0f*0.1f));
      printSummary(i);
    }
  }
  if (key == '&') {
    println ("Opoosite of 1");
    for (int i = 0; i < networkSize; i++) {
      net.naturalFrequency[i]= ((i+1)*0.10f);   // equivalent à     net.naturalFrequency[i] =1.2- (((networkSize-1)-i)*0.1 );
      printSummary(i);
    }
  } else if (key == '2') { 
    println("2$ Set Frequencies to 2+ harmonic distance from F0 "); 
    for (int i = 0; i < networkSize-0; i++) {

      //       net.naturalFrequency[i] =    2.4-((i+0)*(1.0*0.2)); //   
      net.naturalFrequency[i]+=1.2f-((i+0)*(1.0f*0.1f)); //F11 not affected if (i+1)
      // net.naturalFrequency[i]=(i+1)*0.24;  
      printSummary(i);
    }
  } 
  if (key == 'é') { // e$  éà dans pendularpattern e$  Shift frequencies one by one.  //  0 to 9,  1 to 8, 2 to 7.....9 to 0 

    //    if ( net.naturalFrequency[11]>net.naturalFrequency[0]){

    println (" Shift frequencies one by one 0 <-- 11. ");

    net.naturalFrequency[2]= OldFrequency[(networkSize-1)]; 

    for (int i = 2; i < (networkSize-1); i++) {
      print (i+1); 

      println ((networkSize+1)-(i+1));
      net.naturalFrequency[i+1]= OldFrequency[(networkSize+1)-(i+1)];
    }

    //}
  } else if (key == '3') {  
    println(" Set Frequencies to 3 + harmonic distance ");// boost l'effet 1  
    for (int i = 0; i < networkSize; i++) {  
      net.naturalFrequency[i]  +=  OldFrequency[i]/2;
      //    net.naturalFrequency[i]= 3.0-((i+0)*(3.0*0.1));
      // net.naturalFrequency[i]= 2.4-((i+0)*(2.4*0.1));

      printSummary(i);
    }
  } else if (key == '4') {  
    println(" Set Frequencies to 4 + harmonic distance from F0 "); 
    for (int i = 0; i < networkSize; i++) { 
      //   net.naturalFrequency[i]=(i+1)*(0.30*1); 
      //  net.naturalFrequency[i]=(i+1)*(0.24*1); 
      net.naturalFrequency[i]+=(i+1)*(0.24f*1); 
      printSummary(i);
    }
  } else if (key == '5') {  
    println(" 5 : Minus frequency by F0 in CCW "); // good with 1 and 3
    for (int i = 0; i < networkSize; i++) {  
      // net.naturalFrequency[i] -=2.0-((i+0)*(2.0*0.1));
      net.naturalFrequency[i] -=1.0f-((i+0)*(1.0f*0.1f));

      //**************** I have to try to be proportionnal with frequencies in case 1, 2, 3..

      printSummary(i);
    }
  } else if (key == '6') {  
    println(" 6 : Minus frequency by F9 in CCW"); // the bottom turns the most quickly on the CW way // good with 1 and 3
    for (int i = 0; i < networkSize; i++) { 

      //      net.naturalFrequency[i]-=(i+1)*0.20; 
      net.naturalFrequency[i]-=(i+1)*0.10f; 
      printSummary(i);
    }
  } else if (key == '7') {  
    println(" 7 : Add frequency from F0(the front one) in CCW "); 
    for (int i = 0; i < networkSize; i++) { 
      //          net.naturalFrequency[i]+=2.0-((i+0)*(2.0*0.1));  
      net.naturalFrequency[i]+=1.0f-((i+0)*(1.0f*0.1f));  
      printSummary(i);
    }
  } else if (key == '8') {  
    println(" 8:  Add frequency from F0(the front one) in CW "); 
    for (int i = 0; i < networkSize; i++) {
      //     
      net.naturalFrequency[i]+=(i+1)*0.10f;  
      printSummary(i);
    }
  } else if (key == '°') {  
    println(" 8:  Add frequency from F0(the front one) in CW "); 
    for (int i = 0; i < networkSize; i++) {    
      net.naturalFrequency[i] =0;  
      printSummary(i);
    }
  }
  if (key == 'Q') { //Q$   
    println ("F1, F3, F5.. are multipied 2");
    for (int i = 0; i < (networkSize); i++) { 
      //   net.naturalFrequency[i]= net.naturalFrequency[0];
      int impair = 0;
      int impairmodulo;
      impairmodulo = (i+impair)%2;
      print ("impairmodulo "); 
      println (impairmodulo);
      if (impairmodulo==1) {
        net.naturalFrequency[i]= OldFrequency[i]*2;
        printSummary(i);
      }
    }
  } else if (key == 'q') {//q$    println ("F1, F3, F5.. are divided /2");
    for (int i = 0; i < (networkSize); i++) { 
      //   net.naturalFrequency[i]= net.naturalFrequency[0];
      int impair = 0;
      int impairmodulo;
      impairmodulo = (i+impair)%2;
      print ("impairmodulo "); 
      println (impairmodulo);
      if (impairmodulo==1) {
        net.naturalFrequency[i]= OldFrequency[i]/2;
        printSummary(i);
      }
    }
  }

  if (key == 'N') { //N$   println ("F1, F3, F5.. are divided /2");
    println ("FO, F2, F5.. are multipied 2");
    for (int i = 0; i < (networkSize); i++) { 
      //net.naturalFrequency[i]= net.naturalFrequency[0];
      int pair = 1;
      int pairmodulo;
      pairmodulo = (i+1)%2;
      print ("pairmodulo "); 
      println (pairmodulo);
      if (pairmodulo==1) {
        net.naturalFrequency[i]= OldFrequency[i]*2;
        printSummary(i); 
        key='#';
      }
    }
  }
  if (key == 'n') {//N$    println ("F1, F3, F5.. are divided /2");
    println ("FO, F2, F5.. are divided 2");
    for (int i = 0; i < (networkSize); i++) { 
      int pair = 1;
      int pairmodulo;
      pairmodulo = (i+1)%2;
      print ("pairmodulo "); 
      println (pairmodulo);
      if (pairmodulo==1) {
        net.naturalFrequency[i]= OldFrequency[i]/2;
        printSummary(i);
        key='#';
      }
    }
  }
  /*
        if (key == 'T') {  print ("EXPERIMENTAL T$"); 
   float delaPhase    = map ((float (mouseY)/width*1), 0, 1, 0, QUARTER_PI ); 
   //*********
   for(int i = 0; i < (networkSize); i++) { 
   if ( abs (net.naturalFrequency[2]) > abs (net.naturalFrequency[networkSize-1])){
   net.naturalFrequency[i]= net.naturalFrequency[2];
   
   }
   else net.naturalFrequency[i]= net.naturalFrequency[networkSize-1];
   printSummary(i);  
   }
   }
   */
  if (key == 'T') {  
    print ("EXPERIMENTAL T$"); 
    for (int i = 0; i < (networkSize-1); i++) { 
      if ( (abs (net.naturalFrequency[i]) < abs (net.naturalFrequency[i+1])) // || 
        )
        net.naturalFrequency[i]=net.naturalFrequency[i+1];
    }
    if ( (abs (net.naturalFrequency[networkSize-1]) < abs (net.naturalFrequency[networkSize-1]))
      )
      net.naturalFrequency[networkSize-1]=net.naturalFrequency[0];
  }   

  if (key=='t') {  
    print ("EXPERIMENTAL t$");

    float delaPhase    = map ((PApplet.parseFloat (mouseY)/width*1), 0, 1, 0, QUARTER_PI );                
    for (int i = 0; i < (networkSize-0); i++) {          
      {
        net.phase[i]= averagePhase;  
        //    net.phase[i]= net.phase[i]%PI/2; 
        net.phase[i]= net.phase[i]%TWO_PI;
      } 
      printSummary(i);
    }
  }

  if (key == 'i') { 

  
    if (memoryi>=0) {
    oldMemoryi=memoryi;
    memoryi=(memoryi-1);
    }
      
  if ( memoryi<=-1) {
      memoryi=networkSize-1;
      oldMemoryi=0;
    println (" your herreeeeeee iiiiiiiiiiiii ");
    text (" your herreeeeeee iiiiiiiiiiiii ", 200, 200);


   }

        for (int i = 1; i < (networkSize-0); i++) {  

      net.phase[i-1]= net.oldPhase[i];
      net.naturalFrequency[i-1]= net.naturalFrequency[i];
  //    net.phase[i]= net.phase[i+1];// net.oldPhase[i] keep phase at    
  //    net.naturalFrequency[i]= net.naturalFrequency[i+1];
    }

     net.phase[networkSize-1]=  net.oldPhase[0];
    net.naturalFrequency[networkSize-1]= OldFrequency[0];
   
  }

  text ( " memoryi " +  memoryi + " oldMemoryi " + oldMemoryi, 800, 400)  ;



  if (key == 'u'  ) { 
    println ("U$=85  Shift frequencies <- one by one by keeping last position switched"); // && circularMov == false
    oldMemoryi=memoryi;
    memoryi=(memoryi+1)%networkSize;

    if ( memoryi<=0) {
      memoryi=0;
    }

    for (int i = 1; i < (networkSize-1); i++) {
      net.phase[i+1]= net.oldPhase[i];// net.oldPhase[i] keep phase at 0
      net.naturalFrequency[i+1]= OldFrequency[i];
      net.phase[i]= net.oldPhase[i-1];// // useless
      net.naturalFrequency[i]= OldFrequency[i-1]; // useless

      printSummary(i);
    }
    net.phase[0]=  net.oldPhase[networkSize-1];
    net.naturalFrequency[0]= OldFrequency[networkSize-1];
    net.phase[networkSize-1]=  net.oldPhase[networkSize-1-1]; // useless
    net.naturalFrequency[networkSize-1]= OldFrequency[networkSize-1-1];// // useless
  } 

  if (key == 'U' && formerKeyMetro == '<') { 

    println ("U$<  add phase from the previous oscillator"); // && circularMov == false
    print (" U$< oldActualVirtualPosition2 ");
    println (oldActualVirtualPosition[2]);
    print (" U$< ActualVirtualPosition2 ");
    println (ActualVirtualPosition[2]);

    print (" U$< oldVirtualPosition2 ");
    println (oldVirtualPosition[2]);
    print (" U$< virtualPosition[2] ");
    println (VirtualPosition[2]);

    oldMemoryi=memoryi;
    memoryi=(memoryi+1)%12;

    if ( memoryi<=0) {
      memoryi=0;
    }
    for (int i = 0; i < (networkSize-1); i++) {

      net.phase[i]=  net.oldPhase[i+1];
      net.naturalFrequency[i+1]= net.naturalFrequency[i];
      //**   net.naturalFrequency[2]= OldFrequency[networkSize-1];
      //  VirtualPosition[i]=VirtualPosition[i+1];
      ActualVirtualPosition[i]=VirtualPosition[i];
      // ActualVirtualPosition[i+1]= ActualVirtualPosition[i+1]+1600;
      //  

      printSummary(i);
    }

    //   ActualVirtualPosition[2]= ActualVirtualPosition[networkSize-1];
    //   net.naturalFrequency[2]= net.naturalFrequency[networkSize-1];

    net.phase[0]=  net.oldPhase[networkSize-1];
    net.naturalFrequency[0]= OldFrequency[networkSize-1];
    //  VirtualPosition[2]=VirtualPosition[networkSize-1];
    ActualVirtualPosition[0]=VirtualPosition[0];
    // net.phase[networkSize-1]=  net.oldPhase[networkSize-1-1]; // useless

    // net.naturalFrequency[networkSize-1]= OldFrequency[networkSize-1-1];// // useless
  } 

  if (key == 'J') { 
    println ("J$  Shift frequencies -> one by one by keeping last position switched and divide /2");// based on i
    for (int i = 0; i < (networkSize-0); i++) {    

      net.phase[i]+= QUARTER_PI/(10);
      printSummary(i);
    }
  }  

  if (key == 'K') { //K$ invisible
    println ("I$ Shift frequencies -> one by one by keeping last position switched and divide /2");// based on i
    for (int i = 0; i < (networkSize-0); i++) {    

      //     net.phase[i]-= QUARTER_PI/(10);
          net.phase[i]-=HALF_PI;
       // net.phase[i]=net.phase[i]-QUARTER_PI;
     // ActualVirtualPosition[i]+=0;  

      /*
        ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;
       ActualVirtualPosition[i]=ActualVirtualPosition[i]%numberOfStep;
       ActualVirtualPosition[i]+=ActualVirtualPosition[i];
       
       //*****
       
       ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/3*i;// less conventional than numberOfStep/6*i
       ActualVirtualPosition[i]+=ActualVirtualPosition[i]%numberOfStep;
       ActualVirtualPosition[i]=ActualVirtualPosition[i]%numberOfStep*5;
       */

      ActualVirtualPosition[i]=ActualVirtualPosition[i]+numberOfStep/8;

      printSummary(i);
    }
  } 


  if (key == 'L') { 
    println ("L$  Shift frequencies -> one by one by keeping last position switched and divide /2");// based on i
    for (int i = 0; i < (networkSize-0); i++) {    
      //   net.phase[i]+= PI/(20+i);
      //    net.phase[i]+= PI/(i+1)/10; // good
      //  automatiseWithNote();
      printSummary(i);
    }
  }    



  if (key == 'l') { 
    println ("l$  Shift frequencies <- one by one by keeping last position switched and multipied *2"); // based on u || key == 'L'

    // autoNote1();
    for (int i = 0; i < (networkSize-0); i++) { 
      //   net.phase[i]+= PI/(20+(networkSize-1-i));
      //   net.phase[i]+= PI/(networkSize-0-i)/10; // good
      //   automatiseWithNote();
    }
  }     

  if (key == 'c') { 
    println ("c$  Shift frequencies <- one by one by keeping last position switched and multipied *2"); // based on i$ || key == 'L'
    // net.shiftFrequencies(1);  net.shiftPhases(-1);
    formerKey = 'c';
  }
 
  if (key == 'X') { //trigx
    println (" Shift phase and frequencies  as a upstairx, based on x RECORD interphase when x Keyreleased"); // based on i$ || key == 'L'
    //   interPhase[memoryi]= metroPhase[memoryi];
    interPhase[memoryi]= net.phase[memoryi];

    interPhaseCircular[memoryi]= net.phase[memoryi];
    interFrequency[memoryi]= net.naturalFrequency[memoryi]; 
    formerKey='X'; // to trig directly, before the next frame
  } 
  if (key == 'x') { //trigx
    println (" Shift phase and frequencies  as a DOWNSTAIRx, based on w RECORD interphase when w Keyreleased"); // based on i$ || key == 'L'
    //   interPhase[memoryi]= metroPhase[memoryi];
    interPhase[memoryi]= net.phase[memoryi];

    interPhaseCircular[memoryi]= net.phase[memoryi];
    interFrequency[memoryi]= net.naturalFrequency[memoryi]; 
    formerKey='x'; // to trig directly, before the next frame
  } 
  if (key == 'W') { //trigW
    println (" Shift phase and frequencies  as a upstairW, based on x RECORD interphase when x Keyreleased"); // based on i$ || key == 'L'
    //   interPhase[memoryi]= metroPhase[memoryi];
    interPhase[memoryi]=  (net.phase[memoryi]);

    interPhaseCircular[memoryi]=  (net.phase[memoryi]);
    interFrequency[memoryi]= net.naturalFrequency[memoryi]; 
    formerKey='W'; // to trig directly, before the next frame
  } 
  if (key == 'w' ) { //trigw   || key== 'O'
    println (" Shift phase and frequencies  as a DOWNSTAIRw, based on w RECORD interphase when w Keyreleased"); // based on i$ || key == 'L'
    //   interPhase[memoryi]= metroPhase[memoryi];
    interPhase[memoryi]=  (net.phase[memoryi]);

    interPhaseCircular[memoryi]= abs (net.phase[memoryi]);
    interFrequency[memoryi]= net.naturalFrequency[memoryi]; 
    formerKey='w'; // to trig directly, before the next frame
  } 


  if (key == 'v') { //TRIGGERV
    println ("v$  Shift OSCILLATOR WHEN POSITION MATCH   "); // based on i$ || key == 'L'
    formerKey = 'v';
    ///    formerKeyv();
  } 

  if (key == 'V'  ) { //&& keyCode== SHIFT
    println ("V$  Shift frequencies <- Two by one by keeping last position switched and multipied *2"); // based on i$ ||
    formerKey = 'V';
    //    formerKeyv();
  } 
  /*
    if (key == 'x') { 
   println ("x$  FOLLOW OSCILLATOR 11"); // based on  ||
   //if ( formerKey == 'l') { println ("L$  Shift frequencies <- one by one by keeping last position switched and multipied *2"); // based on u || key == 'L'
   formerKey = 'x';
   //    formerKeyL();
   } 
   */

  if (key == 'i') { 
    println ("= c$+I$  Shift frequencies -> one by one by keeping last position switched");
    formerKey = 'i';
  }  

  //**************************************************PLAY WITH PHASES

  if (key == 'k') { //  Shift frequencies one by one.  //  2 to 11,  3 to 10, 4 to 9.....11 to 2 

    println (" MIROR ? k$ Shift phase one by one 9 <-- 0. ");

    for (int i = (networkSize-1); i > 1; i--) {

      print (i); 
      println ( (networkSize-1)-i);

      net.phase[i]=net.oldPhase[(networkSize+1)-i];
      net.naturalFrequency[i]=OldFrequency[(networkSize+1)-i];
    }   

    net.phase[0]=net.oldPhase[(networkSize-1)];
     net.naturalFrequency[0]=OldFrequency[(networkSize-1)];
    
  }
    if (key == 'A') { //A$  Shift frequencies one by one. 
    float speeed    = map ((PApplet.parseFloat (mouseY)/width*1.0f), 0, 1, -4.34f, 4.34f); 
    for (int i = 0; i < networkSize; i++) {
      net.naturalFrequency[i]=OldFrequency[i]; 
      printSummary(i);
    }
    memoryi=0;
    net.naturalFrequency[memoryi]= speeed;//4.68/2; // 124 bpm
  }

  if (key == 'a') { //A$  Shift frequencies one by one. 
    float speeed    = map ((PApplet.parseFloat (mouseY)/width*1.0f), 0, 1, -4.34f, 4.34f); 
    for (int i = 0; i < networkSize; i++) {    
      net.naturalFrequency[i]=OldFrequency[i]; 
      printSummary(i);
    }
    memoryi=0;
    net.naturalFrequency[0]= speeed;//4.68/2; // 124 bpm  4=108 bpm

  }


  if (key == 'Z') { 
    println (" Z$  Divide frequencies F11 by 12/2, F9 by 10/2 and, F7 by 8/2 so on. ");// fonctionne si F11=X et les autres vont à la meme vitesse
    // " Z$  Divide frequencies F1 by 12/2, F3 by 10/2 and, F5 by 8/2, F7 by 6/2, F9 by 4/2, F11 by 2/2 so on. ");// fonctionne si F11=X et les autres vont à la meme vitesse
    float speeed    = map ((PApplet.parseFloat (mouseY)/width*1.0f), 0, 1, -2, 2);

    //    net.naturalFrequency[i]= OldFrequency[networkSize-1]; 

    net.naturalFrequency[networkSize-1]= OldFrequency[networkSize-1]; 
    //    net.naturalFrequency[networkSize-1]= 4;

    //    net.naturalFrequency[networkSize-3]= OldFrequency[networkSize-1]/2; 

    // affecting only F1, F3...
    for (int i = 0; i < (networkSize); i++) { 
      //    net.naturalFrequency[i]=  net.naturalFrequency[networkSize-1];

      //   net.naturalFrequency[i]= net.naturalFrequency[0];
      int pair = 0; // impair

      int pairmodulo;
      pairmodulo = (i+pair)%2;
      //     print ("pairmodulo "); println (pairmodulo);
      if (pairmodulo==1) {
        //    if (i%1==0){
        // net.naturalFrequency[i]=  net.naturalFrequency[networkSize-1]/(i+1); // du plus haut au plus bas
        // net.naturalFrequency[networkSize-i]= net.naturalFrequency[networkSize-1]/((i+1)/2.0);
        // " Z$  Divide frequencies F1 by 12/2, F3 by 10/2 and, F5 by 8/2, F7 by 6/2, F9 by 4/2, F11 by 2/2 so on. ");// fonctionne si F11=X et les autres vont à la meme vitesse
        //    divideFrequency[networkSize-i] = net.naturalFrequency[networkSize-1]/((i+1)/2.0);
        //   divideFrequency[networkSize-i] = net.naturalFrequency[networkSize-1]/((i+1)/(8.0/12.0));


        //      net.naturalFrequency[networkSize-i]= net.naturalFrequency[networkSize-1]/((i+1)/2.0);

        //*********************
        //        divideFrequency[networkSize-i] = net.naturalFrequency[networkSize-1]/((i+1)/(12/8.0));
        //      net.naturalFrequency[networkSize-i]=  divideFrequency [networkSize-i];

        print(" ");  
        print (i); 
        print ("  Oscillator pair : "); 
        print (networkSize-i-1); 
        print (" affected by the division: "); 
        print  ((i+1)/(12/8.0f)); // Oscillator 0 when i=11 Oscillator 10 when i = 1;
        //      printSummary(networkSize-i);
      }
    }
    println (" ");
    // affecting only F0, F2.. divied with 7,6.. and F10 divided with 2 

    for (int i = 0; i < (networkSize); i++) { 
      //net.naturalFrequency[i]= net.naturalFrequency[0];
      int pair = 1;
      int pairmodulo;
      pairmodulo = (i+1)%2;
      //     print ("pairmodulo "); println (pairmodulo);
      if (pairmodulo==1) {
        //     net.naturalFrequency[networkSize-0-i]= net.naturalFrequency[networkSize-1]/((i+1)/2.0); // (multipild F11 of 2)

        //       net.naturalFrequency[networkSize-i-2]= net.naturalFrequency[networkSize-1]/((i+4)/2.0); // (multipild F11 of 2) bug 

        //*********
        //          divideFrequency[networkSize-i-1] = net.naturalFrequency[networkSize-1]/((i+0.75)/(12/8.0));
        //           net.naturalFrequency[networkSize-i-1]=  divideFrequency [networkSize-i-1];

        //          print(" ");  print (i); print ("Oscillator impair : "); print (networkSize-i-1); print ("  affected by the division: "); println ((i+0.75)/(12/8.0));  //Oscillator 1 it's i=10  Oscillator 11 it's i= 0
        //        printSummary(networkSize-i-1);
        //       printSummary(i);
      }
    }
  }
  if (key == 'z') {  
    println ("//z$  Shift frequencies one by one") ;
    float speeed    = map ((PApplet.parseFloat (mouseY)/width*1.0f), 0, 1, -2, 2);
    net.naturalFrequency[networkSize-1]= OldFrequency[networkSize-1]/1; 

    for (int i = 2; i < (networkSize-0); i++) { 
      //    for (int i = networkSize-2; i > -1; i--) { 
      //   net.naturalFrequency[i]= net.naturalFrequency[0];
      int pair = 0;
      if (pair==(i+1)%2) {
        //    if (i%1==0){
        //    net.naturalFrequency[i]=  net.naturalFrequency[networkSize-1]/(i+1);
        //  net.naturalFrequency[networkSize-0-i]= net.naturalFrequency[networkSize-1]/((((i/2)*1)));
        net.naturalFrequency[networkSize-i]= net.naturalFrequency[networkSize-1]/((i+1)/2.0f);
        print (i);
        printSummary(i);
      }
    }
  }
  /*
        if (key == 'a') { // a$
   print("a");  println ("Incremente Same offset of phases 12hit");    
   for (int i = 0; i < networkSize; i++) { 
   net.phase[i] += (TWO_PI/(networkSize/1))*(i+1); // TRES BIEN 
   net.phase[i]=  net.phase[i]%TWO_PI; //
   printSummary(i);
   }
   } 
   */
   
 //} //ENDFORMERSARTKEYJ
 
  if (key == 'e') { 
    println ("Incremente positions  12/3 hit");  //e$
    for (int i = 0; i < networkSize; i++) {    
      //    net.phase[i] -= (QUARTER_PI/(networkSize-0))*(i+1); // TRES BIEN

      net.phase[i] = net.phase[i] + ((TWO_PI/(networkSize/1))*(i+1)); // TRES BIEN  ==     net.phase[i] += (i+1)*TWO_PI/4; //4hit  ==   net.phase[i] +=  (i+1)*3.5*PI; 
      net.phase[i] = net.phase[i] % TWO_PI; // TRES BIEN

      printSummary(i);
      key ='#'; keyReleased();
    }
  }  



  if (key == 'E') {   
    print ("Add 2PI/3: PENDULAR $ 3 HIT TO COME BACK" );  print (" Add 2PI/3: PENDULAR $ 3 HIT TO COME BACK" ); //e$
    print ("FormerkeyMetro"); 
    print (PApplet.parseChar(formerKeyMetro));
    print ("keyNow"); 
    println (PApplet.parseChar(key));
    for (int i = 0; i < networkSize; i++) {
      //  net.oldPhase[i] += (i+1)*4%TWO_PI; 
      //   net.phase[i] +=  (i+1)*3*PI;  // one on two move an offset of PI
      
     // net.phase[i] += (i+1)*TWO_PI/3; //3hit  <=>   net.phase[i] += (i+1)*TWO_PI/1.5; 
     
        net.phase[i] = net.phase[i] + (i+1)*TWO_PI/3; //3hit  <=>   net.phase[i] += (i+1)*TWO_PI/1.5; 
     

      net.phase[i]=  net.phase[i]%TWO_PI;
        key ='#';// keyReleased();
    }
  }



  /*
     if (key == 'w')  {   println ("Add PI/3 : 12HIT : Clock Wise"); //w$
   
   for (int i = 0; i < networkSize; i++) {
   
   net.phase[networkSize-1-i] -= (i*TWO_PI/10)%PI/3;    //PAS TOUCHER 
   net.phase[i]=  net.phase[i]%TWO_PI;
   }     
   }
   */
  if (key == 'r') {
    println ("Soubstract PI/6 PENDULAR $"); // R$ +1.5*HALF_PI; 


    for (int i = 0; i < networkSize; i++) {
      //   net.phase[i] += (i+1) *(TWO_PI/12); // 12 hit


      //    net.phase[i] +=  -(i+2)%PI/6; // mieux
      //   net.phase[networkSize-1-i] -= (i*TWO_PI/3)%PI/11; // fonctionne seulement anti clockwise
      //        net.phase[i] -= (i*TWO_PI/3)%PI/11; // fonctionne seulement anti clockwise
      net.phase[i] += (i*TWO_PI/5)%PI/10; // 

      //    net.phase[i] -=  +(i+1)%PI/6; 

      // net.phase[i]=  net.phase[i]%(TWO_PI/2) ; // bien en circulaire?
      net.phase[i]=  net.phase[i]%(TWO_PI/1) ; // bien en pendulaire?
      // net.shiftPhases(-2); 
      // net.oldPhase[i]=  net.phase[i];
      printSummary(i);
    }
  }


  if (key == 'R') {
    println ("Add PI/6 PENDULAR $ without move 11, 8, 5"); // R$
    for (int i = 0; i < networkSize; i++) {
      //   net.phase[i] += (i+1) *(TWO_PI/12); // 12 hit
      // if (  net.naturalFrequency[networkSize-1]>=0 ) {
      print (" Avant ");    
      print (net.phase[networkSize-1-i]); 
      print ("  ");
      //   net.phase[networkSize-1-i] += (i*TWO_PI/3)%PI/11;    //PAS TOUCHER
      net.phase[i] -= (i*TWO_PI/5)%PI/10;
      //   net.phase[networkSize-1-i] += (i*TWO_PI/3)%PI/10;    //PAS TOUCHER
      //    net.phase[networkSize-1-i] += (i*TWO_PI/3)%TWO_PI/10;    //PAS TOUCHER // ne va pas avec P
      //     net.phase[networkSize-1-i] += (i*TWO_PI/3)%TWO_PI/11;    //PAS TOUCHER


      //   net.phase[i] += (1*TWO_PI/(11-i+1))%PI/6;
      //   net.phase[i]  += ((PI/(networkSize/6))*(i+1))%PI/3; // OK
      //   net.phase[i]  +=  net.phase[i] +(PI/((networkSize-i/12))*(i+1))%PI/12; // OK


      print (" ApresR ");  
      print (net.phase[networkSize-1-i]); 
      print ("  "); 
      net.phase[i]=  net.phase[i]%TWO_PI;
      //   net.oldPhase[i]=  net.phase[i];
      printSummary(i);
    }
    // }
  } else if (key == 's') {
    println(" s$s: Reduce the gap between phases by f0 "); //S$
    for (int i = 0; i < networkSize-0; i++) {

      //  net.phase[i] -=(9-i)*0.05;
      //   net.phase[i] -=(networkSize-1-i)*0.05; // oscillator 11 do not move
    //  net.phase[i] -= (networkSize- oscillatorBlocked-i)*0.05;
    //  net.phase[i]=  net.phase[i]%TWO_PI;

      printSummary(i);
    }
  } else if (key == 'S') { 
    println(" S$: Reduce the gap between phases by f0  ");    
    for (int i = 0; i < networkSize; i++) {      
      //   net.phase[i] -=(networkSize-1-i)*0.1;
      //   net.phase[i]=  net.phase[i]%TWO_PI;
      //***    net.phase[i] -= (networkSize- oscillatorBlocked-i)*0.05;
      //***    net.phase[i]=  net.phase[i]%TWO_PI;
      printSummary(i);
    }
  }
  else if (key == 'd') {
    println(" d$: INCREASE (clock way) the gap between phases of 5% from the oscillator " + oscillatorBlocked + " called with the same number as memoryi " + memoryi );
    for (int i = 0; i < networkSize; i++) {

      //      net.phase[i] +=(10-i)*0.1; // oscillator 10 do not nove
      //  net.phase[i] +=(networkSize-1-i)*0.1;
      net.phase[i] += (networkSize- oscillatorBlocked-i)*0.05f;
      //     net.phase[i] += (oscillatorBlocked+i)*0.05; reciproque de f ne fonctionne pas
      net.phase[i] =  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  }
  
  else if (key == 'D') { 
    println(" D$: Increase the gap between phases by f0  ");    
    for (int i = 0; i < networkSize; i++) {

      net.phase[i]+= (networkSize-1-i)*0.1f;
      net.phase[i] =  net.phase[i]%TWO_PI;
      printSummary(i);
    }
  }
  /*
    else if (key == 'x') {//x$
   formerKey= 'x';
   fmemory+=f;
   for (int i = 0; i < networkSize-1; i++) {
   
   print ("f: "); 
   println (f);
   
   abstractPhase[networkSize-2-i] += net.oldPhase[networkSize-1]+(i*TWO_PI/3)%PI/12;
   
   net.phase[i]=  abstractPhase[networkSize-2-i]%TWO_PI;
   
   //    printSummary(i);
   
   
   print ("fmemory: "); 
   println (fmemory);
   
   //  key='#';
   }
   
   println(" Increase the gap  fmemory between phases by f9 ");
   
   } 
   */
  else if (key == 'f') { 
    println(" F: Increase the gap between phases by f9 ");    
    for (int i = 0; i < networkSize; i++) {

      //  net.phase[i] +=(i+1)*0.05;
      //    net.phase[i] +=(i+1)*0.005;
      //  net.phase[i] += (oscillatorBlocked+i)*0.05;  // l'oscillateur ne se bloque pas
      net.phase[i] -= (networkSize- oscillatorBlocked-i)*0.05f;

      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'F') { 
    println(" F: Increase the gap between phases by f9 ");    
    for (int i = 0; i < networkSize; i++) {

      net.phase[i] +=(i+1)*0.1f;
      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'g') { 
    println(" Decrease the gap between phases of 5% from the oscillator " + oscillatorBlocked + " called with the same number as memoryi " + memoryi   );  
    for (int i = 0; i < networkSize; i++) {
      //       net.phase[i] -=i*0.01;
      //         net.phase[i] -=i*0.05;

      net.phase[i] -=      (oscillatorBlocked+i)*0.05f;
      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'G') { 
    println(" G: Decrease the gap between phases by f9 ");  
    for (int i = 0; i < networkSize; i++) {
      //       net.phase[i] -=i*0.01;
      net.phase[i] -=i*0.1f;
      net.phase[i]=  net.phase[i]%TWO_PI;
      printSummary(i);
    }
  }

    //****************** To TEST when frequencies are set at 0
  else if (keyCode == CONTROL) { 
    println("INCREASE phases with special modulo   "); //P$ 
    //else if (key == 'π') { println("INCREASE phases with special modulo   "); //P$ 

    for (int i = 0; i < networkSize; i++) {

    //  net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-1-i)); // TWOPI/10--> 10 hit and oscillator11 not affected thanks to -1 in second part of equation
    //  net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-3-i)); // TWOPI/10--> 10 hit and oscillator9 not affected thanks to -3 in second part of equation 
    //** net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-1-i)); // TWOPI/10--> 10 hit * 3%PI/3 with and oscillator11 not affected

     net.phase[i]+=   (PI/(networkSize-2))*(1*(networkSize-1-i)); // TWOPI/10--> 10 hit * 3%PI/3 with and oscillator11 not affected


      //     net.phase[networkSize-1-i] += (i*TWO_PI/10)%PI/3;  // 10*3 hit//same effect as above 
    //  net.phase[i]=  net.phase[i]%(TWO_PI/1); // try without dataMarkedToTeensyJo

    //  for (int i = 0; i < networkSize; i++) {
      
      if (net.phase[i] >=  0) { // number of revLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (net.phase[i], 0, TWO_PI, 0, numberOfStep)); //
        }
      
     }
   
      keyCode = BACKSPACE;
    
    int speedLocalDelta=4; 
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy

    String dataMarkedToTeensyPhasePattern  ="<" //   

     
     + DataToDueCircularVirtualPosition[5]+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","
     + DataToDueCircularVirtualPosition[1]+","+DataToDueCircularVirtualPosition[0]    //+          ","+ 0 + ","+ 0","+ 0","+ 0 +","
    
     +  speedLocalDelta + ","
      // + driverOnOff +","+dataToTeensyNoJo+","+decompte[8]+","+decompte[7]+","+decompte[6]+","
     +decompte[5]+","+decompte[4]+","+decompte[3]+","+decompte[2]+"," // to manage 12 note +decompte[1]+","+decompte[0]+ ","

      +  decompte[1]+"," +cohesionCounterLow +","+ cohesionCounterHigh +","+ PApplet.parseInt (map (LevelCohesionToSend, 0, 1, 0, 100))+">";    

    println(frameCount + ": " +  " dataMarkedToTeensyPhasePattern " + ( dataMarkedToTeensyPhasePattern ));
   // teensyport.write(dataMarkedToTeensyPhasePattern); // Send data to Teensy. only the movement


  }


 
  else if (key == 'P') { 
    println("INCREASE phases with special modulo P$   "); //P$ 
    for (int i = 0; i < networkSize; i++) {

      //     net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-1-i)); // TWOPI/10--> 10 hit and oscillator11 not affected thanks to -1 in second part of equation
      //  net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-3-i)); // TWOPI/10--> 10 hit and oscillator9 not affected thanks to -3 in second part of equation 
      net.phase[i]+=   (TWO_PI/(networkSize-2))*(1*(networkSize-1-i))%PI/3; // TWOPI/10--> 10 hit * 3%PI/3 with and oscillator11 not affected

      //     net.phase[networkSize-1-i] += (i*TWO_PI/10)%PI/3;  // 10*3 hit//same effect as above 
      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'M') { 
    println("INCREASE phases with 0.5   "); //
    for (int i = 0; i < networkSize; i++) {
      //       net.phase[i] += QUARTER_PI/2 * net.phase[1*(networkSize-1-i)] ;//
      net.phase[i] += QUARTER_PI/2 * net.phase[i] ;//

      //      net.phase[i] = net.phase[i] - QUARTER_PI  i;
      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'p') {
    println("DECREASE  phases with special modulo    "); // UTILISE SI ELLES ONT deja un ecart equidistant
    for (int i = 0; i < networkSize; i++) {  

      net.phase[i]-= ((TWO_PI/(networkSize-2))*(1*(networkSize-1-i)))%PI/6; // 
      net.phase[i]=  net.phase[i]%TWO_PI;
      key='#';
      printSummary(i);
    }
  } else if (key == 'm') {
    println("DECREASE phases with 0.5   "); // UTILISE SI ELLES ONT deja un ecart equidistant
    for (int i = 0; i < networkSize; i++) {  
      //   net.phase[i] -= PI/32 * net.oldPhase[i] ;//
      //   net.phase[i] -= PI/8 * net.phase[i] ;//OK
      
          net.phase[i] -=net.phase[i]- PI/8;
   
  /*   
      if  (net.phase[i]<PI/2) { 
        net.phase[i] = PI/10*net.phase[i];// effet torune à l'envers? 

        //      net.phase[i] =-  (net.phase[i]-QUARTER_PI/2 )+ PI/2;// effet torune à l'envers?
        net.phase[i]=  net.phase[i]%-PI/2- PI/2;// COME BACK TO MIDDLE
      } else if (net.phase[i]>PI/2) { 
        net.phase[i] = PI/10*net.phase[i];// effet torune à l'envers? 

        //      net.phase[i] =-  (net.phase[i]-QUARTER_PI/2 )+ PI/2;// effet torune à l'envers?
        net.phase[i]=  net.phase[i]%-PI/2+ PI/2;// COME BACK TO MIDDLE
      }
   */   
      //      net.phase[i] -= averagePhase* net.oldPhase[i] ;// 
      //  net.phase[i] -= PI/8 * net.phase[i]* averagePhase ;//
      printSummary(i);
      key='#';
    } 
  }   
  // ****************** ALIGNEMENT of PHASES --- thus, phases alignement depend of coupling.

  else if (key == '9')//9$

  { 
    println(" Align oscillator vertically to the top  ");
    for (int i = 0; i < networkSize; i++) {
      net.phase[i]= 0-PI/2; 
      //      net.phase[i]= 0; 
      printSummary(i);
    }
  } else if (key == 'ç') {
    if (circularMov==true) {

      for (int i = 0; i < networkSize; i++) {
        net.phase[i]= 0;
      }
    }
    if (circularMov==false) {
      println(" Align oscillator vertically to the down  ");
      formerKey = 'o';
      for (int i = 0; i < networkSize; i++) {
        //   net.phase[i]=-PI+0.5*PI+PI/12; // position 0+PI/2  
        net.phase[i]= 0+PI/2  ; // position 0+PI/2  

        //     net.phase[i]=net.phase[i]+PI/3;    // position 0+PI/2   add 90° turning in CW
        printSummary(i);
      }
    }
  } 
  ///******************************==================================================== MODULATE SPEED of ALL FREQUENCIE MORE OR LESS FASTLY in PENDULAR $
  /// ****************************  How could i modulate the couple?

  else if (key == 'y') { 
    println("y= Increase last frequencies + 0.05*i ");
    for (int i = 0; i < networkSize; i++) {   
      net.naturalFrequency[i] = net.naturalFrequency[i]*(1.05f);
      printSummary(i);
    }
  } else if (key == 'h') { 
    println(" Decrease last frequencies - 0.05*i"); 
    for (int i = 0; i < networkSize; i++) { 
      net.naturalFrequency[i] = net.naturalFrequency[i]*(.95f);            
      printSummary(i);
    }
  } else if (key == 'Y') { 
    println("y= Increase last frequencies + 0.05*i ");
    for (int i = 0; i < networkSize; i++) {   
      net.naturalFrequency[i] = net.naturalFrequency[i]*(1.10f);
      key='#';
      printSummary(i);
    }
  } else if (key == 'H') { 
    println(" Decrease last frequencies - 0.05*i"); 
    for (int i = 0; i < networkSize; i++) { 
      net.naturalFrequency[i] = net.naturalFrequency[i]*(.90f);   
      key='#';
      printSummary(i);
    }
  } 


  //************************** CHANGE THE WAY OF ROTATION O$
  else if (key == 'o') 
  { 
    if ( keyMode != " phasePattern "){
  // for (int i = 0; i < networkSize; i++) {
   //  net.naturalFrequency[i]=signal[2]; 
     signal[2]= - signal[2]; 
   //  } 
     }  
    println("  Changes way of rotation  "); 
    for (int i = 0; i < networkSize; i++) {
      background(120, 20, 20);
      net.naturalFrequency[i] = -1* net.naturalFrequency[i];

      // interFrequency[memoryi] = -1* net.naturalFrequency[i];
      printSummary(i);
    }
  } else if (key == '0') {//Set all frequencies at 2.0");
    for (int i = 0; i < networkSize-0; i++) {   
      //  net.naturalFrequency[i]=2.0; 
      net.naturalFrequency[i]=1.0f;
    }
    //  printSummary(i);
  } else if (key == '°') {//Set all frequencies at 2.0");
    for (int i = 0; i < networkSize; i++) {   
      //  net.naturalFrequency[i]=2.0; 
      net.naturalFrequency[i]=0;
    }
    //  printSummary(i);
  } else if (keyCode == CONTROL) {  
    println(" RECORD COUPLING "); 

    text ( coupling, - 400, height - 1000); // coupling appears on screen and is recorded on the file data.txt
    net.setCoupling(coupling);
  } 
  key ='#';
  //************************************ ENDPENDULARPATTERN  //************************************ END OF PENDULARRRRRRR  $
  //************************************ DONT TOUCH  //************************************ END OF PENDULARRRRRRR  $
  //************************************ DONT TOUCH  //************************************ END OF PENDULARRRRRRR  $
  }
 }
}
 public void send24DatasToTeensy6motors(int accelerationRatio, int driver0_On_Off, int computeData, int eraseProcessingData){  // dataMarkedToTeensyArevoir

  
       dataFromMode ="<"

      + DataToDueCircularVirtualPosition[5]+ ","+ DataToDueCircularVirtualPosition[4]+ ","+ DataToDueCircularVirtualPosition[3]+","+ DataToDueCircularVirtualPosition[2]+ ","
      + DataToDueCircularVirtualPosition[1]+ ","+ DataToDueCircularVirtualPosition[0]+ ","
       +0+","+0+","+0+","+0+","

      +  accelerationRatio +","+ driver0_On_Off +","+ computeData +","+ eraseProcessingData + ","
      
  //    + TrigmodPos[11]+","+TrigmodPos[10]+","+TrigmodPos[9]+","+TrigmodPos[8]+","+TrigmodPos[7]+","+TrigmodPos[6]+","

      +0+","+0+","+0+","+0+","+0+","+","
      
    //  +TrigmodPos[5]+","+TrigmodPos[4]+","+TrigmodPos[3]+","+TrigmodPos[2]+","+TrigmodPos[1]+","+TrigmodPos[0]+ ">";  // to manage 12 note
    // //     +0+","+0+","+0+","+0+","+0+","+0+","+0+","

       +0+","+0+","+0+","+0+">";    

     if (computeData<2){
       dataTransformed = " dataNotComputeInTeensy from mode ";
            println(frameCount + ": " + dataTransformed +  keyMode + " " +   dataFromMode );

  }
  
     else dataTransformed = " dataComputeInTeensy from mode ";
     println(frameCount + ": " + dataTransformed +  keyMode + " " +   dataFromMode );
  //  DueSerialNativeUSBport101.write(dataMarkedToTeensyNoJo);// Send data to Arduino.
    teensyport.write(dataFromMode);
      }


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--stop-color=#cccccc", "NAOP" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
